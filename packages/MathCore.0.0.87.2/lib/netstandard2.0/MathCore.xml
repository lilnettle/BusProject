<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MathCore</name>
    </assembly>
    <members>
        <member name="T:MathCore.ActionList">
            <summary>Список действий <see cref="T:System.Action"/></summary>
        </member>
        <member name="M:MathCore.ActionList.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList"/></summary>
        </member>
        <member name="M:MathCore.ActionList.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList.#ctor(System.Collections.Generic.IEnumerable{System.Action})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList.Invoke">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`1">
            <summary>Список действий <see cref="T:System.Action`1"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`1"/></summary>
        </member>
        <member name="M:MathCore.ActionList`1.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`1"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`1.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`1"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`1.Invoke(`0)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`2">
            <summary>Список действий <see cref="T:System.Action`2"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`2.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`2"/></summary>
        </member>
        <member name="M:MathCore.ActionList`2.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`2"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`2.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`2"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`2.Invoke(`0,`1)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`3">
            <summary>Список действий <see cref="T:System.Action`3"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`3.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`3"/></summary>
        </member>
        <member name="M:MathCore.ActionList`3.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`3"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`3.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`3"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`3.Invoke(`0,`1,`2)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`4">
            <summary>Список действий <see cref="T:System.Action`4"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
            <typeparam name="T4">Тип 4 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`4.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`4"/></summary>
        </member>
        <member name="M:MathCore.ActionList`4.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`4"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`4.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2,`3}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`4"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`4.Invoke(`0,`1,`2,`3)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`5">
            <summary>Список действий <see cref="T:System.Action`5"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
            <typeparam name="T4">Тип 4 параметра действия</typeparam>
            <typeparam name="T5">Тип 5 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`5.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`5"/></summary>
        </member>
        <member name="M:MathCore.ActionList`5.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`5"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`5.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2,`3,`4}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`5"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`5.Invoke(`0,`1,`2,`3,`4)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`6">
            <summary>Список действий <see cref="T:System.Action`6"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
            <typeparam name="T4">Тип 4 параметра действия</typeparam>
            <typeparam name="T5">Тип 5 параметра действия</typeparam>
            <typeparam name="T6">Тип 6 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`6.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`6"/></summary>
        </member>
        <member name="M:MathCore.ActionList`6.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`6"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`6.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2,`3,`4,`5}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`6"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`6.Invoke(`0,`1,`2,`3,`4,`5)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.ActionList`7">
            <summary>Список действий <see cref="T:System.Action`7"/></summary>
            <typeparam name="T1">Тип 1 параметра действия</typeparam>
            <typeparam name="T2">Тип 2 параметра действия</typeparam>
            <typeparam name="T3">Тип 3 параметра действия</typeparam>
            <typeparam name="T4">Тип 4 параметра действия</typeparam>
            <typeparam name="T5">Тип 5 параметра действия</typeparam>
            <typeparam name="T6">Тип 6 параметра действия</typeparam>
            <typeparam name="T7">Тип 7 параметра действия</typeparam>
        </member>
        <member name="M:MathCore.ActionList`7.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`7"/></summary>
        </member>
        <member name="M:MathCore.ActionList`7.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`7"/></summary>
            <param name="Capacity">Ёмкость списка</param>
        </member>
        <member name="M:MathCore.ActionList`7.#ctor(System.Collections.Generic.IEnumerable{System.Action{`0,`1,`2,`3,`4,`5,`6}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ActionList`7"/></summary>
            <param name="ActionsEnumeration">Перечисление действий списка</param>
        </member>
        <member name="M:MathCore.ActionList`7.Invoke(`0,`1,`2,`3,`4,`5,`6)">
            <summary>Выполнение последовательности действий списка</summary>
        </member>
        <member name="T:MathCore.AngleType">
            <summary>Тип значения угла</summary>
        </member>
        <member name="F:MathCore.AngleType.Rad">
            <summary>Радиан</summary>
        </member>
        <member name="F:MathCore.AngleType.Deg">
            <summary>Градус</summary>
        </member>
        <member name="T:MathCore.ArgumentsString">
            <summary>Аргументы командной строки</summary>
        </member>
        <member name="F:MathCore.ArgumentsString._Arguments">
            <summary>Строки значений аргументов</summary>
        </member>
        <member name="P:MathCore.ArgumentsString.Count">
            <summary>Число аргументов</summary>
        </member>
        <member name="P:MathCore.ArgumentsString.Item(System.Int32)">
            <summary>Получение аргумента по индексу</summary>
            <param name="index">Индекс аргумента</param>
            <returns>Значение аргумента по указанному индексу</returns>
        </member>
        <member name="M:MathCore.ArgumentsString.#ctor(System.String[])">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ArgumentsString"/></summary>
            <param name="Arguments">Массив значений аргументов</param>
        </member>
        <member name="M:MathCore.ArgumentsString.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ArgumentsString.op_Implicit(System.String[])~MathCore.ArgumentsString">
            <summary>Оператор неявного приведения типа массива строк к <see cref="T:MathCore.ArgumentsString"/></summary>
            <param name="Arguments">Массив строковых значений аргументов</param>
            <returns>Экземпляр <see cref="T:MathCore.ArgumentsString"/></returns>
        </member>
        <member name="M:MathCore.ArgumentsString.op_Implicit(MathCore.ArgumentsString)~System.String[]">
            <summary>Оператор неявного приведения <see cref="T:MathCore.ArgumentsString"/> к типу массива строк</summary>
            <param name="Arguments">Экземпляр <see cref="T:MathCore.ArgumentsString"/></param>
            <returns>Массив строковых значений аргументов</returns>
        </member>
        <member name="M:MathCore.ArgumentsString.op_Explicit(MathCore.ArgumentsString)~System.String">
            <summary>Оператор неявного приведения <see cref="T:MathCore.ArgumentsString"/> к строке</summary>
            <param name="Argument">Экземпляр <see cref="T:MathCore.ArgumentsString"/></param>
            <returns>Строковое представление <see cref="T:MathCore.ArgumentsString"/></returns>
        </member>
        <member name="T:MathCore.ArrayIndexer`1">
            <summary>Индексатор массива элементов</summary>
            <typeparam name="T">Тип элемента массива</typeparam>
        </member>
        <member name="F:MathCore.ArrayIndexer`1._Array">
            <summary>Индексируемый массив</summary>
        </member>
        <member name="F:MathCore.ArrayIndexer`1._Index">
            <summary>Индекс текущего элемента</summary>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Length">
            <summary>Длина массива</summary>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Index">
            <summary>Индекс текущего элемента</summary>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Value">
            <summary>Ссылка на текущий элемент массива</summary>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Item(System.Int32)">
            <summary>Элемент массива с указанным индексом</summary>
            <param name="index">Индекс элемента массива</param>
            <returns>Ссылка на элемент с указанным индексом</returns>
        </member>
        <member name="P:MathCore.ArrayIndexer`1.Array">
            <summary>Индексируемый массив</summary>
        </member>
        <member name="M:MathCore.ArrayIndexer`1.#ctor">
            <summary>Инициализация нового <see cref="T:MathCore.ArrayIndexer`1"/></summary>
        </member>
        <member name="M:MathCore.ArrayIndexer`1.#ctor(`0[],System.Int32)">
            <summary>Инициализация нового <see cref="T:MathCore.ArrayIndexer`1"/></summary>
            <param name="Array">Индексируемый массив</param>
            <param name="Index">Индекс текущего элемента</param>
        </member>
        <member name="M:MathCore.ArrayIndexer`1.op_Implicit(MathCore.ArrayIndexer{`0})~`0[]">
            <summary>Оператор неявного приведения типа <see cref="T:MathCore.ArrayIndexer`1"/> к <see cref="T:System.Array`1"/></summary>
            <param name="Indexer">Индексатор массива <see cref="T:MathCore.ArrayIndexer`1"/></param>
            <returns>Индексируемый массив элементов</returns>
        </member>
        <member name="T:MathCore.Attributes.ElementNameAttribute">
            <summary>Имя элемента</summary>
        </member>
        <member name="P:MathCore.Attributes.ElementNameAttribute.Name">
            <summary>Имя элемента</summary>
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Attributes.ElementNameAttribute"/></summary>
            <param name="Name">Имя элемента</param>
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Attributes.ElementNameAttribute.op_Implicit(MathCore.Attributes.ElementNameAttribute)~System.String">
            <summary>Оператор неявного приведения типа <see cref="T:MathCore.Attributes.ElementNameAttribute"/> к <see cref="T:System.String"/></summary>
            <param name="A">Атрибут имени</param>
        </member>
        <member name="T:MathCore.BigInt">
            <summary> Целочисленная арифметика с большими числами  </summary>
        </member>
        <member name="F:MathCore.BigInt.MaxLength">
            <summary>Максимальная длина числа в байтах х8</summary>
        </member>
        <member name="F:MathCore.BigInt.PrimesBelow2000">
            <summary>Простые числа до 2000</summary>
        </member>
        <member name="F:MathCore.BigInt._Data">
            <summary>Байты числа</summary>
        </member>
        <member name="F:MathCore.BigInt._DataLength">
            <summary>Число символов числа</summary>
        </member>
        <member name="P:MathCore.BigInt.DataLength">
            <summary>Число символов числа</summary>
        </member>
        <member name="M:MathCore.BigInt.#ctor">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInt"/> = 0</summary>
        </member>
        <member name="M:MathCore.BigInt.#ctor(System.Int64)">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInt"/> = 0</summary>
            <param name="Value">Исходное значение числа</param>
        </member>
        <member name="M:MathCore.BigInt.#ctor(System.UInt64)">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInt"/> = 0</summary>
            <param name="Value">Исходное значение числа</param>
        </member>
        <member name="M:MathCore.BigInt.#ctor(MathCore.BigInt)">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInt"/> = 0</summary>
            <param name="Value">Исходное значение числа</param>
        </member>
        <member name="M:MathCore.BigInt.#ctor(System.String,System.Int32)">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInt"/> = 0</summary>
            <param name="StringValue">Строковая форма записи <see cref="T:MathCore.BigInt"/></param>
            <param name="Base">Основание системы счисления</param>
            <exception cref="T:System.ArithmeticException">Если очередной символ в строке больше, либо равен <paramref name="Base"/></exception>
            <exception cref="T:System.OverflowException">При переполнении разрядной сетки</exception>
        </member>
        <member name="M:MathCore.BigInt.#ctor(System.Byte[])">
            <summary>Инициализация нового пустого <see cref="T:MathCore.BigInt"/> = 0</summary>
            <param name="Data">Байты данных <see cref="T:MathCore.BigInt"/></param>
            <exception cref="T:System.OverflowException">При переполнении разрядной сетки</exception>
        </member>
        <member name="M:MathCore.BigInt.op_Multiply(MathCore.BigInt,MathCore.BigInt)">
            <summary>Overloading of multiplication operator</summary>
            <exception cref="T:System.ArithmeticException">Multiplication overflow</exception>
        </member>
        <member name="M:MathCore.BigInt.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.BigInt.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.BigInt.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.BigInt.ToHexString">
            <summary>Представление <see cref="T:MathCore.BigInt"/> в шестнадцатеричной системе счисления</summary>
            <returns>Строка шестнадцатеричного представления числа <see cref="T:MathCore.BigInt"/></returns>
        </member>
        <member name="M:MathCore.BigInt.BarrettReduction(MathCore.BigInt,MathCore.BigInt,MathCore.BigInt)">
            <summary>Быстрое вычисление сокращения числа по модулю с использованием редукции Барретта</summary>
            <returns></returns>
            <remarks>
            Требуется <paramref name="x"/> &lt; b^(2k), где b база.
            В этом случае база соответствует 2^32 (uint).
            </remarks>
        </member>
        <member name="M:MathCore.BigInt.Gcd(MathCore.BigInt)">
            <summary>Наибольший общий делитель</summary>
        </member>
        <member name="M:MathCore.BigInt.GenRandomBits(System.Int32,System.Random)">
            <summary>Случайный набор бит указанной длины <paramref name="bits"/></summary>
            <param name="bits">Требуемое число бит</param>
            <param name="rand">Генератор случайных чисел</param>
            <exception cref="T:System.ArithmeticException">Число бит &gt; <see cref="F:MathCore.BigInt.MaxLength"/> = (70)x(8x8) = 4'480 </exception>
        </member>
        <member name="P:MathCore.BigInt.BitCount">
            <summary>Число бит (номер последнего значащего бита)</summary>
        </member>
        <member name="M:MathCore.BigInt.IntValue">
            <summary>Последние 4 байта значения числа <see cref="T:MathCore.BigInt"/></summary>
        </member>
        <member name="M:MathCore.BigInt.LongValue">
            <summary>Последние 8 байт значения числа <see cref="T:MathCore.BigInt"/></summary>
        </member>
        <member name="T:MathCore.Collections.FList">
            <summary>Функциональный односвязный список</summary>
        </member>
        <member name="M:MathCore.Collections.FList.Empty``1">
            <summary>Пустой список</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Возвращает единственный экземпляр пустого списка</returns>
        </member>
        <member name="M:MathCore.Collections.FList.New``1(``0)">
            <summary>Создать новый список, содержащий указанный элемент</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <param name="item">Элемент, добавляемый в создаваемый список</param>
            <returns>Возвращает новый экземпляр списка, содержащий указанный элемент</returns>
        </member>
        <member name="M:MathCore.Collections.FList.New``1(``0[])">
            <summary>Создать новый список, содержащий указанные элементы</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <param name="items">Элементы, добавляемые в список</param>
            <returns>Возвращает новый список, содержащий указанные элементы</returns>
        </member>
        <member name="M:MathCore.Collections.FList.New``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Создать новый список, содержащий указанное перечисление элементов</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <param name="items">Перечисление элементов, на основе которых необходимо создать новый список</param>
            <returns>Возвращает новый список, содержащий элементы из указанного перечисления</returns>
        </member>
        <member name="T:MathCore.Collections.FList`1">
            <summary>Функциональный список</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
        </member>
        <member name="P:MathCore.Collections.FList`1.Empty">
            <summary>Пустой список</summary>
            <remarks>Свойство содержит единственный для всего приложения экземпляр пустого списка</remarks>
        </member>
        <member name="P:MathCore.Collections.FList`1.IsEmpty">
            <summary>Признак того, что текущий список является пустым</summary>
        </member>
        <member name="P:MathCore.Collections.FList`1.Head">
            <summary>Головной элемент списка</summary>
        </member>
        <member name="P:MathCore.Collections.FList`1.Tail">
            <summary>Хвост списка</summary>
        </member>
        <member name="M:MathCore.Collections.FList`1.#ctor">
            <summary>Инициализация нового экземпляра функционального списка</summary>
            <remarks>
            Данный конструктор порождает пустой список.
            В процессе работы приложения данный конструктор может быть вызван единожды для
            инициализации значения свойства <see cref="P:MathCore.Collections.FList`1.Empty"/>. В противном случае конструктор
            генерирует исключение <see cref="T:System.InvalidOperationException"/>
            </remarks>
            <exception cref="T:System.InvalidOperationException">
            Возникает в случае если конструктор вызывается в месте, отличном от инициализатора свойства <see cref="P:MathCore.Collections.FList`1.Empty"/>
            </exception>
        </member>
        <member name="M:MathCore.Collections.FList`1.#ctor(`0,MathCore.Collections.FList{`0})">
            <summary>Инициализация нового списка с указанием его текущего головного элемента и хвоста</summary>
            <param name="Head"></param>
            <param name="Tail"></param>
        </member>
        <member name="M:MathCore.Collections.FList`1.New(`0,MathCore.Collections.FList{`0})">
            <summary>Создание нового списка на основе его головного элемента и хвоста</summary>
            <param name="Head">Головной элемент списка</param>
            <param name="Tail">Хвост списка. Если не указан, то используется пустой список <see cref="P:MathCore.Collections.FList`1.Empty"/></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Collections.FList`1.New(System.Collections.Generic.IEnumerable{`0})">
            <summary>Создание нового списка на основе указанного перечисления элементов</summary>
            <param name="Items">Перечисление элементов создаваемого списка</param>
            <returns>Новый список, содержащий указанные элементы</returns>
        </member>
        <member name="M:MathCore.Collections.FList`1.AddFirst(`0)">
            <summary>Добавить элемент в голову списка</summary>
            <param name="Item">Добавляемый элемент</param>
            <returns>Новый список, головным элементом которого является указанный, а хвостом - текущий список</returns>
        </member>
        <member name="M:MathCore.Collections.FList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Collections.FList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Collections.FTree`1">
            <summary>Функциональное дерево</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MathCore.Collections.FTree`1.Empty">
            <summary>Пустое дерево</summary>
        </member>
        <member name="P:MathCore.Collections.FTree`1.IsEmpty">
            <summary>Дерево пусто</summary>
        </member>
        <member name="P:MathCore.Collections.FTree`1.IsLeaf">
            <summary>Поддерево является листом (отсутствуют дочерние элементы)</summary>
        </member>
        <member name="P:MathCore.Collections.FTree`1.Root">
            <summary>Корень дерева</summary>
        </member>
        <member name="P:MathCore.Collections.FTree`1.Left">
            <summary>Левое поддерево</summary>
        </member>
        <member name="P:MathCore.Collections.FTree`1.Right">
            <summary>Правое поддерево</summary>
        </member>
        <member name="M:MathCore.Collections.FTree`1.#ctor">
            <summary>Инициализация нового пустого дерева</summary>
            <exception cref="T:System.InvalidOperationException">При попытке создать ещё одно новое пустое поддерево - вызвать данный конструктор повторно</exception>
        </member>
        <member name="M:MathCore.Collections.FTree`1.#ctor(`0,MathCore.Collections.FTree{`0},MathCore.Collections.FTree{`0})">
            <summary>Инициализация нового поддерева</summary>
            <param name="Root">Корень поддерева</param>
            <param name="Left">Левое поддерево</param>
            <param name="Right">Правое поддерево</param>
        </member>
        <member name="M:MathCore.Collections.FTree`1.New(`0,MathCore.Collections.FTree{`0},MathCore.Collections.FTree{`0})">
            <summary>Создание нового узла дерева</summary>
            <param name="root">Корень</param>
            <param name="left">Левое поддерево</param>
            <param name="right">Правое поддерево</param>
            <returns>Созданный узел поддерева</returns>
        </member>
        <member name="T:MathCore.Collections.Interfaces.IPage`1">
            <summary>Страница элементов</summary>
            <typeparam name="T">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.Collections.Interfaces.IPage`1.Index">
            <summary>Индекс страницы</summary>
        </member>
        <member name="P:MathCore.Collections.Interfaces.IPage`1.Items">
            <summary>Перечисление элементов страницы</summary>
        </member>
        <member name="P:MathCore.Collections.Interfaces.IPage`1.Count">
            <summary>Количество элементов на странице</summary>
        </member>
        <member name="P:MathCore.Collections.Interfaces.IPage`1.TotalCount">
            <summary>Полное количество элементов в выборке</summary>
        </member>
        <member name="P:MathCore.Collections.Interfaces.IPage`1.Size">
            <summary>Размер страницы</summary>
        </member>
        <member name="P:MathCore.Collections.Interfaces.IPage`1.PagesCount">
            <summary>Число страниц в выборке</summary>
        </member>
        <member name="T:MathCore.Collections.Interfaces.IRepository`1">
            <summary>Репозиторий</summary>
            <typeparam name="T">Тип элемента репозитория</typeparam>
        </member>
        <member name="P:MathCore.Collections.Interfaces.IRepository`1.Items">
            <summary>Запрос к репозиторию</summary>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepository`1.Count">
            <summary>Число элементов в репозитории</summary>
            <returns>Количество элементов в репозитории</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepository`1.GetAll">
            <summary>Получить всё содержимое репозитория</summary>
            <returns>Перечисление всех элементов репозитория</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepository`1.Get(System.Int32,System.Int32)">
            <summary>Получить элементы в заданном диапазоне</summary>
            <param name="Skip">Число пропускаемых элементов</param>
            <param name="Take">Число извлекаемых элементов</param>
            <returns>Перечисление элементов репозитория в заданном диапазоне</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepository`1.GetPage(System.Int32,System.Int32)">
            <summary>Получить страницу элементов из репозитория</summary>
            <param name="Index">Индекс страницы начиная с 0</param>
            <param name="Size">Число элементов на страницу</param>
            <returns>Страница с элементами</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepository`1.Add(`0)">
            <summary>Добавить элемент в репозиторий</summary>
            <param name="item">Добавляемый элемент</param>
            <returns>Добавленный элемент, если он отсутствовал, либо <c>null</c></returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepository`1.Update(`0)">
            <summary>Обновить состояние элемента в репозитории</summary>
            <param name="item">Обновляемый элемент</param>
            <returns>Обновлённый элемент, либо <c>null</c> если обновление невозможно</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepository`1.Delete(`0)">
            <summary>Удаление элемента из репозитория</summary>
            <param name="item">Удаляемый элемент</param>
            <returns>Удалённый элемент, если он присутствовал в репозитории, и <c>null</c>, если элемента в репозитории не было</returns>
        </member>
        <member name="T:MathCore.Collections.Interfaces.IRepositoryAsync`1">
            <summary>Репозиторий с асинхронными операциями доступа к данным</summary>
            <typeparam name="T">Тип элемента репозитория</typeparam>
        </member>
        <member name="P:MathCore.Collections.Interfaces.IRepositoryAsync`1.Items">
            <summary>Запрос к репозиторию</summary>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepositoryAsync`1.CountAsync(System.Threading.CancellationToken)">
            <summary>Число элементов в репозитории</summary>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Количество элементов в репозитории</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepositoryAsync`1.GetAllAsync(System.Threading.CancellationToken)">
            <summary>Получить всё содержимое репозитория</summary>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Перечисление всех элементов репозитория</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepositoryAsync`1.GetAsync(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>Получить элементы в заданном диапазоне</summary>
            <param name="Skip">Число пропускаемых элементов</param>
            <param name="Take">Число извлекаемых элементов</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Перечисление элементов репозитория в заданном диапазоне</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepositoryAsync`1.GetPageAsync(System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>Получить страницу элементов из репозитория</summary>
            <param name="Index">Индекс страницы начиная с 0</param>
            <param name="Size">Число элементов на страницу</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Страница с элементами</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepositoryAsync`1.AddAsync(`0,System.Threading.CancellationToken)">
            <summary>Добавить элемент в репозиторий</summary>
            <param name="item">Добавляемый элемент</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Добавленный элемент, если он отсутствовал, либо <c>null</c></returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepositoryAsync`1.UpdateAsync(`0,System.Threading.CancellationToken)">
            <summary>Обновить состояние элемента в репозитории</summary>
            <param name="item">Обновляемый элемент</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Обновлённый элемент, либо <c>null</c> если обновление невозможно</returns>
        </member>
        <member name="M:MathCore.Collections.Interfaces.IRepositoryAsync`1.DeleteAsync(`0,System.Threading.CancellationToken)">
            <summary>Удаление элемента из репозитория</summary>
            <param name="item">Удаляемый элемент</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Удалённый элемент, если он присутствовал в репозитории, и <c>null</c>, если элемента в репозитории не было</returns>
        </member>
        <member name="T:MathCore.Collections.Page`1">
            <summary>Страница элементов</summary>
            <typeparam name="T">Тип элементов</typeparam>
        </member>
        <member name="M:MathCore.Collections.Page`1.Empty(System.Int32,System.Int32,System.Int32)">
            <summary>Пустая страница</summary>
            <param name="TotalCount">Полное число элементов в выборке</param>
            <param name="Index">Индекс страницы</param>
            <param name="Size">Размер страницы</param>
            <returns>Страница с пустым перечислением элементов</returns>
        </member>
        <member name="M:MathCore.Collections.Page`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Новая страница элементов</summary>
            <param name="Items">Перечисление элементов страницы</param>
            <param name="Count">Количество элементов на странице</param>
            <param name="TotalCount">Полное количество элементов в выборке</param>
            <param name="Index">Индекс страницы</param>
            <param name="Size">Размер страницы</param>
        </member>
        <member name="P:MathCore.Collections.Page`1.Index">
            <summary>Индекс страницы</summary>
        </member>
        <member name="P:MathCore.Collections.Page`1.Items">
            <summary>Перечисление элементов страницы</summary>
        </member>
        <member name="P:MathCore.Collections.Page`1.Count">
            <summary>Количество элементов на странице</summary>
        </member>
        <member name="P:MathCore.Collections.Page`1.TotalCount">
            <summary>Полное количество элементов в выборке</summary>
        </member>
        <member name="P:MathCore.Collections.Page`1.Size">
            <summary>Размер страницы</summary>
        </member>
        <member name="P:MathCore.Collections.Page`1.PagesCount">
            <summary>Число страниц в выборке</summary>
        </member>
        <member name="T:MathCore.Collections.Repository`1">
            <summary>Репозиторий на основе коллекции</summary>
            <typeparam name="T">Тип элемента репозитория</typeparam>
        </member>
        <member name="F:MathCore.Collections.Repository`1._Collection">
            <summary>Коллекция элементов репозитория</summary>
        </member>
        <member name="M:MathCore.Collections.Repository`1.#ctor">
            <summary>Новый репозиторий</summary>
        </member>
        <member name="M:MathCore.Collections.Repository`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>Новый репозиторий</summary>
            <param name="Collection">Коллекция элементов репозитория</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:MathCore.Collections.Repository`1.Items">
            <summary>Запрос к репозиторию</summary>
        </member>
        <member name="M:MathCore.Collections.Repository`1.Count">
            <summary>Число элементов в репозитории</summary>
            <returns>Количество элементов в репозитории</returns>
        </member>
        <member name="M:MathCore.Collections.Repository`1.GetAll">
            <summary>Получить всё содержимое репозитория</summary>
            <returns>Перечисление всех элементов репозитория</returns>
        </member>
        <member name="M:MathCore.Collections.Repository`1.Get(System.Int32,System.Int32)">
            <summary>Получить элементы в заданном диапазоне</summary>
            <param name="Skip">Число пропускаемых элементов</param>
            <param name="Take">Число извлекаемых элементов</param>
            <returns>Перечисление элементов репозитория в заданном диапазоне</returns>
        </member>
        <member name="M:MathCore.Collections.Repository`1.GetPage(System.Int32,System.Int32)">
            <summary>Получить страницу элементов из репозитория</summary>
            <param name="Index">Индекс страницы начиная с 0</param>
            <param name="Size">Число элементов на страницу</param>
            <returns>Страница с элементами</returns>
        </member>
        <member name="M:MathCore.Collections.Repository`1.Add(`0)">
            <summary>Добавить элемент в репозиторий</summary>
            <param name="item">Добавляемый элемент</param>
            <returns>Добавленный элемент, если он отсутствовал, либо <c>null</c></returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на элемент</exception>
        </member>
        <member name="M:MathCore.Collections.Repository`1.Update(`0)">
            <summary>Обновить состояние элемента в репозитории</summary>
            <param name="item">Обновляемый элемент</param>
            <returns>Обновлённый элемент, либо <c>null</c> если обновление невозможно</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на элемент</exception>
        </member>
        <member name="M:MathCore.Collections.Repository`1.Delete(`0)">
            <summary>Удаление элемента из репозитория</summary>
            <param name="item">Удаляемый элемент</param>
            <returns>Удалённый элемент, если он присутствовал в репозитории, и <c>null</c>, если элемента в репозитории не было</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на элемент</exception>
        </member>
        <member name="T:MathCore.CommandLineArgs">
            <summary>Парсер аргументов командной строки</summary>
        </member>
        <member name="F:MathCore.CommandLineArgs._ArgsSrc">
            <summary>Массив аргументов командной строки</summary>
        </member>
        <member name="F:MathCore.CommandLineArgs._StartArgs">
            <summary>Первые аргументы до ключей</summary>
        </member>
        <member name="F:MathCore.CommandLineArgs._EndArgs">
            <summary>Свободные аргументы в конце строки</summary>
        </member>
        <member name="F:MathCore.CommandLineArgs._Args">
            <summary>Список ключей со значениями</summary>
        </member>
        <member name="P:MathCore.CommandLineArgs.Item(System.String)">
            <summary>Получение значений указанного ключа</summary>
            <param name="key">Требуемый ключ</param>
            <returns>Перечисление значений для указанного ключа</returns>
        </member>
        <member name="P:MathCore.CommandLineArgs.StartArgs">
            <summary>Первые аргументы до ключей</summary>
        </member>
        <member name="P:MathCore.CommandLineArgs.EndArgs">
            <summary>Свободные аргументы в конце строки</summary>
        </member>
        <member name="P:MathCore.CommandLineArgs.FreeArgs">
            <summary>Свободные аргументы</summary>
        </member>
        <member name="M:MathCore.CommandLineArgs.EnumValues(System.ValueTuple{System.Int32,System.Int32})">
            <summary>Перечисление значений в указателе памяти в массиве элементов</summary>
            <param name="values">Указатель на элемент массива элементов</param>
            <returns>Перечисление значений по указателю в массиве элементов</returns>
        </member>
        <member name="P:MathCore.CommandLineArgs.KeyValues">
            <summary>Перечисление ключей со значениями</summary>
        </member>
        <member name="P:MathCore.CommandLineArgs.Args">
            <summary>Список элементов командой строки</summary>
        </member>
        <member name="M:MathCore.CommandLineArgs.CheckArgs(System.String[])">
            <summary>Объединение элементов массива в случае наличия кавычек</summary>
            <param name="args">Массив элементов командной строки</param>
            <returns>Массив элементов командной строки с объединением значений в кавычках</returns>
        </member>
        <member name="M:MathCore.CommandLineArgs.#ctor(System.String[])">
            <summary>Инициализация нового экземпляра парсера аргументов командной строки</summary>
            <param name="args">Массив элементов командной строки</param>
        </member>
        <member name="M:MathCore.CommandLineArgs.ContainsKey(System.String)">
            <summary>Проверка на наличие ключа в строке</summary>
            <param name="Key">Проверяемый ключ</param>
            <returns>Истина, если проверяемый ключ присутствует в строке</returns>
        </member>
        <member name="M:MathCore.CommandLineArgs.GetKeyValues(System.String)">
            <summary>Получение всех значений указанного ключа</summary>
            <param name="key">Проверяемый ключ</param>
            <returns>Перечисление значений каждого встреченного значения указанного ключа</returns>
        </member>
        <member name="M:MathCore.CommandLineArgs.KeysCount(System.String)">
            <summary>Число включений указанного ключа в строку</summary>
            <param name="key">Проверяемый ключ</param>
            <returns>Число раз, сколько ключ присутствует в строке</returns>
        </member>
        <member name="M:MathCore.CommandLineArgs.ExecForKey(System.String,System.Action{System.String})">
            <summary>Выполнить действие для каждого значения указанного ключа</summary>
            <param name="key">Проверяемый ключ</param>
            <param name="action">Выполняемое действие</param>
            <returns>Истина, если действие было выполнено хотя бы раз</returns>
        </member>
        <member name="T:MathCore.CommandProcessor.Argument">
            <summary>Аргумент команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Name">
            <summary>Имя аргумента</summary>
        </member>
        <member name="F:MathCore.CommandProcessor.Argument._Values">
            <summary>Значения аргумента</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Values">
            <summary>Значения аргумента</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Value">
            <summary>Значение аргумента</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Count">
            <summary>Количество значений аргумента</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.Argument.Item(System.Int32)">
            <summary>Доступ к значениям аргумента по номеру</summary>
            <param name="i">Номер значения</param>
            <returns>Значение аргумента с указанным номером</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.#ctor(System.String,System.Char)">
            <summary>Аргумент команды</summary>
            <param name="ArgStr">Строковое описание аргумента</param>
            <param name="ValueSplitter">Разделитель имени аргумента и значения</param>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.ValueAs``1">
            <summary>Представление значения в указанном типе</summary>
            <typeparam name="T">Требуемый тип значения аргумента</typeparam>
            <returns>Значение аргумента указанного типа</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.TryGetValueAs``1(``0@)">
            <summary>Попытаться получить значение аргумента команды в указанном типе <typeparamref name="T"/></summary>
            <param name="value">Приведённое к типу <typeparamref name="T"/> значение аргумента</param>
            <typeparam name="T">Требуемый тип значения аргумента</typeparam>
            <returns>Исключение, возникшее в процессе преобразования строки значения аргумента к типу <typeparamref name="T"/></returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.TryGetValueAs``1(``0@,System.Exception@)">
            <summary>Попытаться получить значение аргумента команды в указанном типе <typeparamref name="T"/></summary>
            <param name="value">Приведённое к типу <typeparamref name="T"/> значение аргумента</param>
            <param name="Error">Исключение, возникшее в процессе преобразования строки значения аргумента к типу <typeparamref name="T"/></param>
            <typeparam name="T">Требуемый тип значения аргумента</typeparam>
            <returns>Истина, если преобразование выполнено успешно</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление аргумента</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.Equals(MathCore.CommandProcessor.Argument)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.op_Equality(MathCore.CommandProcessor.Argument,MathCore.CommandProcessor.Argument)">
            <summary>Оператор, проверяющий равенство между двумя экземплярами <see cref="T:MathCore.CommandProcessor.Argument"/></summary>
            <returns>Истина, если все поля экземпляров равны между собой</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.Argument.op_Inequality(MathCore.CommandProcessor.Argument,MathCore.CommandProcessor.Argument)">
            <summary>Оператор, проверяющий неравенство между двумя экземплярами <see cref="T:MathCore.CommandProcessor.Argument"/></summary>
            <returns>Истина, если хотя бы одно поле у экземпляров отличается</returns>
        </member>
        <member name="T:MathCore.CommandProcessor.CommandArgHandlersList">
            <summary>Список обработчиков команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandArgHandlersList.op_Addition(MathCore.CommandProcessor.CommandArgHandlersList,System.Action{MathCore.CommandProcessor.ProcessorCommand,System.Int32,MathCore.CommandProcessor.ProcessorCommand[],MathCore.CommandProcessor.Argument})">
            <summary>Оператор добавления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Добавляемый обработчик команды</param>
            <returns>Список с добавленным обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandArgHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandArgHandlersList,System.Action{MathCore.CommandProcessor.ProcessorCommand,System.Int32,MathCore.CommandProcessor.ProcessorCommand[],MathCore.CommandProcessor.Argument})">
            <summary>Оператор удаления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandArgHandlersList.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.CommandProcessor.CommandEventArgs">
            <summary>Аргумент события обработки команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandEventArgs.Command">
            <summary>Обрабатываемая команда</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandEventArgs.Commands">
            <summary>Перечень команд сессии</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandEventArgs.Index">
            <summary>Индекс команды в перечне команд сессии</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandEventArgs.Handled">
            <summary>Признак того, что команда обработана</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandEventArgs.#ctor(MathCore.CommandProcessor.ProcessorCommand,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.ProcessorCommand})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.CommandProcessor.CommandEventArgs"/></summary>
            <param name="Command">Обрабатываемая команда</param>
            <param name="Index">Индекс команды в перечне команд сессии</param>
            <param name="Commands">Перечень команд сессии</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandEventArgs.ToString">
            <summary>Строковое представление</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandEventArgs.SetHandled">
            <summary>Установка признака того, что команда была обработана</summary>
        </member>
        <member name="T:MathCore.CommandProcessor.CommandHandlersList">
            <summary>Список обработчиков команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Addition(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.ProcessorCommand,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.ProcessorCommand}})">
            <summary>Оператор добавления команды к списку</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Добавляемый обработчик команды</param>
            <returns>Список с добавленным обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Addition(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.ProcessorCommand})">
            <summary>Оператор добавления обработчика команды в список обработчиков</summary>
            <param name="list">Список действий обработчиков команды</param>
            <param name="Handler">Добавляемый в список обработчик</param>
            <returns>Исходный список с добавленным в него новым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Addition(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.ProcessorCommand,System.Int32})">
            <summary>Оператор добавления позиционного обработчика команды в список обработчиков</summary>
            <param name="list">Список действий обработчиков команды</param>
            <param name="Handler">Добавляемый в список обработчик, поддерживающий параметр индекса</param>
            <returns>Исходный список с добавленным в него новым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Addition(MathCore.CommandProcessor.CommandHandlersList,System.Action)">
            <summary>Оператор добавления безпараметрического обработчика команды в список обработчиков</summary>
            <param name="list">Список действий обработчиков команды</param>
            <param name="Handler">Добавляемый в список обработчик без параметров</param>
            <returns>Исходный список с добавленным в него новым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.ProcessorCommand,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.ProcessorCommand}})">
            <summary>Оператор удаления команды из списка обработчиков</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.ProcessorCommand})">
            <summary>Оператор удаления обработчика команды из списка обработчиков</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandHandlersList,System.Action{MathCore.CommandProcessor.ProcessorCommand,System.Int32})">
            <summary>Оператор удаления обработчика команды с индексатором из списка обработчиков</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Удаляемый обработчик команды с индексатором</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.op_Subtraction(MathCore.CommandProcessor.CommandHandlersList,System.Action)">
            <summary>Оператор удаления обработчика команды из списка обработчиков</summary>
            <param name="list">Список обработчиков команды</param>
            <param name="Handler">Удаляемый обработчик команды</param>
            <returns>Список с удалённым обработчиком команды</returns>
        </member>
        <member name="F:MathCore.CommandProcessor.CommandHandlersList._CommandHandlers">
            <summary>Словарь обработчиков команд (ключ - имя команды, значение - список обработчиков)</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandHandlersList.Item(System.String)">
            <summary>Обращение к списку обработчиков команды по её имени (индексатор)</summary>
            <param name="CommandName">Имя команды</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.IsRegisteredCommand(System.String)">
            <summary>Зарегистрирована ли команда в процессоре?</summary>
            <param name="CommandName">Имя команды</param>
            <returns>Истина, если в процессоре существует обработчик команды с указанным именем</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandHandlersList.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.CommandProcessor.CommandLineProcessor">
            <summary>Командный процессор</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.ParseConsole(System.String,System.Action{MathCore.CommandProcessor.CommandLineProcessor},System.IO.TextWriter,System.IO.TextReader)">
            <summary>Разобрать команды консоли управления</summary>
            <param name="Prompt">Формат запроса</param>
            <param name="Initializer">Метод инициализации команд</param>
            <param name="ConsoleWriter">Вывод в консоль (если не указано, то используется <see cref="T:System.Console"/>.<see cref="P:System.Console.Out"/>)</param>
            <param name="ConsoleReader">Ввод с консоли (если не указано, то используется <see cref="T:System.Console"/>.<see cref="P:System.Console.In"/>)</param>
            <returns>Сформированное перечисление команд запроса</returns>
        </member>
        <member name="E:MathCore.CommandProcessor.CommandLineProcessor.CommandProcess">
            <summary>Событие обработки команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.OnCommandProcess(MathCore.CommandProcessor.CommandEventArgs)">
            <summary>Обработка команды</summary>
            <param name="Arg">Аргумент, содержащий сведения о команде</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.OnCommandProcess(MathCore.CommandProcessor.ProcessorCommand,System.Int32,MathCore.CommandProcessor.ProcessorCommand[])">
            <summary>Обработка команды</summary>
            <param name="command">Обрабатываемая команда</param>
            <param name="index">Индекс команды в массиве команд сессии</param>
            <param name="commands">Массив команд сессии</param>
        </member>
        <member name="E:MathCore.CommandProcessor.CommandLineProcessor.UnhandledCommand">
            <summary>Событие появления необработанной команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.OnUnhandledCommand(MathCore.CommandProcessor.CommandEventArgs)">
            <summary>Генерация события обнаружения необработанной команды</summary>
            <param name="Arg">Аргумент события, содержащий сведения о команде</param>
        </member>
        <member name="F:MathCore.CommandProcessor.CommandLineProcessor._CommandHandlers">
            <summary>Словарь списков обработчиков команд</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.Commands">
            <summary>Команды, обрабатываемые процессором</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.CommandSplitter">
            <summary>Разделитель команд в строке</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.CommandParameterSplitter">
            <summary>Разделитель имени команды и её параметра</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.ArgSplitter">
            <summary>Разделитель аргументов команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.ValueSplitter">
            <summary>Разделитель имени аргумента и его значения</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.CommandLineProcessor.Item(System.String)">
            <summary>Доступ к списку обработчиков команды по её имени</summary>
            <param name="CommandName">Имя команды</param>
            <returns>Список обработчиков команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.#ctor(System.Char,System.Char,System.Char,System.Char)">
            <summary>Командный процессор</summary>
            <param name="CommandSplitter">Разделитель команд в строке</param>
            <param name="CommandParameterSplitter">Разделитель имени команды и её параметра</param>
            <param name="ArgSplitter">Разделитель аргументов</param>
            <param name="ValueSplitter">Разделитель имени аргумента и его значения</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.Process(System.String[])">
            <summary>Обработать команду</summary>
            <param name="CommandLine">Командная строка</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.AddCommandHandler(System.String,System.Action{MathCore.CommandProcessor.ProcessorCommand,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.ProcessorCommand}})">
            <summary>Добавить обработчик команды</summary>
            <param name="CommandName">Имя команды</param>
            <param name="CommandHandler">Добавляемый обработчик команды</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.RemoveCommandHandler(System.String,System.Action{MathCore.CommandProcessor.ProcessorCommand,System.Int32,System.Collections.Generic.IReadOnlyList{MathCore.CommandProcessor.ProcessorCommand}})">
            <summary>Удалить обработчик команды</summary>
            <param name="CommandName">Имя команды</param>
            <param name="CommandHandler">Удаляемый обработчик команды</param>
            <returns>Истина, если удалось обработчик команды удалить</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.ClearCommandHandlers(System.String)">
            <summary>Очистить список обработчиков команды</summary>
            <param name="CommandName">Имя команды</param>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.ClearCommandHandlers">
            <summary>Очистить все обработчики команд</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.GetRegisteredCommands">
            <summary>Получить перечисление имён команд с зарегистрированными обработчиками</summary>
            <returns>Перечисление имён команд, имеющих свои обработчики</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.CommandLineProcessor.IsRegisteredCommand(System.String)">
            <summary>Проверка - имеет ли команда обработчики</summary>
            <param name="CommandName">Проверяемая команда</param>
            <returns>Истина, если указаны обработчики команды</returns>
        </member>
        <member name="T:MathCore.CommandProcessor.ProcessorCommand">
            <summary>Команда</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.ProcessorCommand.Name">
            <summary>Имя команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.ProcessorCommand.Parameter">
            <summary>Параметр команды</summary>
        </member>
        <member name="F:MathCore.CommandProcessor.ProcessorCommand._Argument">
            <summary>Массив аргументов команды</summary>
        </member>
        <member name="P:MathCore.CommandProcessor.ProcessorCommand.Argument">
            <summary>Массив аргументов команды</summary>
        </member>
        <member name="M:MathCore.CommandProcessor.ProcessorCommand.#ctor(System.String,System.Char,System.Char,System.Char)">
            <summary>Команда</summary>
            <param name="CommandStr">Строковое представление команды</param>
            <param name="ParameterSplitter">Разделитель имени и параметра команды</param>
            <param name="ArgSplitter">Разделитель аргументов команды</param>
            <param name="ValueSplitter">Разделитель имени аргумента и его значения</param>
        </member>
        <member name="M:MathCore.CommandProcessor.ProcessorCommand.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление команды</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.ProcessorCommand.Equals(MathCore.CommandProcessor.ProcessorCommand)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.ProcessorCommand.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.ProcessorCommand.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.CommandProcessor.ProcessorCommand.op_Equality(MathCore.CommandProcessor.ProcessorCommand,MathCore.CommandProcessor.ProcessorCommand)">
            <summary>Оператор, проверяющий равенство между двумя экземплярами <see cref="T:MathCore.CommandProcessor.ProcessorCommand"/></summary>
            <returns>Истина, если все поля экземпляров равны между собой</returns>
        </member>
        <member name="M:MathCore.CommandProcessor.ProcessorCommand.op_Inequality(MathCore.CommandProcessor.ProcessorCommand,MathCore.CommandProcessor.ProcessorCommand)">
            <summary>Оператор, проверяющий неравенство между двумя экземплярами <see cref="T:MathCore.CommandProcessor.ProcessorCommand"/></summary>
            <returns>Истина, если хотя бы одно поле у экземпляров отличается</returns>
        </member>
        <member name="T:MathCore.Complex">
            <summary>Комплексное число</summary>
        </member>
        <member name="M:MathCore.Complex.ClearStringPtr(MathCore.StringPtr)">
            <summary>Метод убирает все парные символы скобок в начале и конце строки</summary>
            <param name="str">Очищаемая строка</param>
        </member>
        <member name="M:MathCore.Complex.Parse(System.String)">
            <summary>Разобрать строку в комплексное число</summary>
            <param name="str">Разбираемая строка</param>
            <returns>Комплексное число, получаемое в результате разбора строки</returns>
            <exception cref="T:System.ArgumentNullException">В случае если передана пустая ссылка на строку</exception>
            <exception cref="T:System.FormatException">В случае ошибочной строки</exception>
        </member>
        <member name="M:MathCore.Complex.TryParse(System.String,MathCore.Complex@)">
            <summary>Попытаться разобрать строку и преобразовать её в комплексное число</summary>
            <param name="str">Разбираемая строка</param>
            <param name="z">Число, получаемое в результате разбора строки</param>
            <returns>Истина, если операция разбора строки выполнена успешно</returns>
        </member>
        <member name="F:MathCore.Complex.Epsilon">
            <summary>Точность вычисления тригонометрических функций 3e-16 </summary>
            <remarks>Определено приближённо</remarks>
        </member>
        <member name="M:MathCore.Complex.Ln(System.Double)">
            <summary>Логарифм комплексного аргумента</summary>
            <param name="Im">Комплексный аргумент</param>
            <returns>Значение логарифма</returns>
        </member>
        <member name="M:MathCore.Complex.Ln(MathCore.Complex)">
            <summary>Натуральный логогриф комплексного числа</summary>
            <param name="z">Комплексное число</param>
            <returns>Натуральный логарифм</returns>
        </member>
        <member name="M:MathCore.Complex.Log(System.Double,System.Double)">
            <summary>Логогриф мнимого числа по действительному основанию</summary>
            <param name="Im">Мнимое число</param>
            <param name="b">Действительное основание логарифма</param>
            <returns>Логарифм мнимого числа по действительному основанию</returns>
        </member>
        <member name="M:MathCore.Complex.Log(MathCore.Complex,System.Double)">
            <summary>Логарифм комплексного числа по действительному аргументу</summary>
            <param name="z">Комплексное число</param>
            <param name="b">Действительное основание логарифма</param>
            <returns>Логарифм комплексного числа по действительному основанию</returns>
        </member>
        <member name="M:MathCore.Complex.Exp(System.Double)">
            <summary>Экспоненциальная форма числа Z = e^j*Arg</summary>
            <param name="Arg">Аргумент</param>
            <returns>Комплексное число в экспоненциальной форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.Exp(System.Double,System.Double)">
            <summary>Экспоненциальная форма числа Z = Abs * e^j*Arg</summary>
            <param name="Abs">Модуль числа</param>
            <param name="Arg">Аргумент числа</param>
            <returns>Комплексное число в экспоненциальной форме</returns>
        </member>
        <member name="M:MathCore.Complex.Exp(MathCore.Complex)">
            <summary>Экспонента с комплексным показателем Z = e^(re + j*im) = e^re * [cos(im) + j*sin(im)]</summary>
            <param name="z">Комплексный показатель степени экспоненты</param>
            <returns>Результат вычисления комплексной экспоненты</returns>
        </member>
        <member name="M:MathCore.Complex.Mod(System.Double,System.Double)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.Mod(System.Double,MathCore.Complex)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.Mod(MathCore.Complex,MathCore.Complex)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.Mod(MathCore.Complex,System.Double)">
            <summary>Алгебраическая форма записи комплексного числа</summary>
            <param name="Re">Действительная часть числа</param>
            <param name="Im">Мнимая часть числа</param>
            <returns>Комплексное число в алгебраической форме записи</returns>
        </member>
        <member name="M:MathCore.Complex.ReValue(System.Double)">
            <summary>Действительное число</summary>
            <param name="re">Значение действительной части числа</param>
            <returns>Комплексное число Re + j0</returns>
        </member>
        <member name="M:MathCore.Complex.ImValue(System.Double)">
            <summary>Мнимое число</summary>
            <param name="im">Значение мнимой части числа</param>
            <returns>Комплексное число 0 + jIm</returns>
        </member>
        <member name="M:MathCore.Complex.Conjugate">
            <summary>Комплексно-сопряжённые значения</summary>
            <returns>Пара комплексно-сопряжённых чисел</returns>
        </member>
        <member name="M:MathCore.Complex.Conjugate(System.Double,System.Double)">
            <summary>Комплексно-сопряжённые значения</summary>
            <param name="Re">Действительная часть</param>
            <param name="Im">Мнимая часть</param>
            <returns>Пара комплексно-сопряжённых чисел</returns>
        </member>
        <member name="M:MathCore.Complex.Conjugate(System.Double)">
            <summary>Комплексно-сопряжённые значения</summary>
            <param name="ExpPower">Показатель степени комплексно-сопряжённой пары</param>
            <returns>Пара комплексно-сопряжённых чисел</returns>
        </member>
        <member name="M:MathCore.Complex.ConjugateExp(System.Double,System.Double)">
            <summary>Комплексно-сопряжённые значения</summary>
            <param name="Abs">Модуль комплексно-сопряжённой пары</param>
            <param name="ExpPower">Показатель степени комплексно-сопряжённой пары</param>
            <returns>Пара комплексно-сопряжённых чисел</returns>
        </member>
        <member name="M:MathCore.Complex.SinCos(System.Double)">
            <summary>Вычисление синуса и косинуса аргумента</summary>
            <param name="arg">Аргумент функции</param>
        </member>
        <member name="M:MathCore.Complex.SinCos(System.Double,System.Double)">
            <summary>Вычисление синуса и косинуса аргумента</summary>
            <param name="arg">Аргумент функции</param>
        </member>
        <member name="M:MathCore.Complex.SinCos(MathCore.Complex)">
            <summary>Вычисление синуса и косинуса аргумента</summary>
            <param name="arg">Аргумент функции</param>
        </member>
        <member name="F:MathCore.Complex.Real">
            <summary>Действительное "комплексное" число</summary>
        </member>
        <member name="F:MathCore.Complex.NaN">
            <summary>Не-число</summary>
        </member>
        <member name="F:MathCore.Complex.i">
            <summary>Мнимая единица</summary>
        </member>
        <member name="F:MathCore.Complex.Zero">
            <summary>Ноль</summary>
        </member>
        <member name="M:MathCore.Complex.CreateArray(System.Double[],System.Double[])">
            <summary>Создать массив комплексных чисел</summary>
            <param name="Re">Массив действительных чисел</param>
            <param name="Im">Массив мнимых чисел</param>
            <returns>Массив комплексных чисел</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="Re"/> or <paramref name="Im"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Длины массивов не совпадают</exception>
        </member>
        <member name="F:MathCore.Complex._Re">
            <summary>Действительная часть</summary>
        </member>
        <member name="F:MathCore.Complex._Im">
            <summary>Мнимая часть</summary>
        </member>
        <member name="P:MathCore.Complex.Expression">
            <summary>Преобразование комплексного числа в выражение</summary>
        </member>
        <member name="P:MathCore.Complex.Re">
            <summary>Действительная часть</summary>
        </member>
        <member name="P:MathCore.Complex.Im">
            <summary>Мнимая часть</summary>
        </member>
        <member name="P:MathCore.Complex.Power">
            <summary>X * X^* = Re(X)^2 + Im(X)^2</summary>
        </member>
        <member name="P:MathCore.Complex.Abs">
            <summary>Модуль</summary>
        </member>
        <member name="P:MathCore.Complex.Arg">
            <summary>Аргумент</summary>
        </member>
        <member name="P:MathCore.Complex.ComplexConjugate">
            <summary>Комплексно сопряжённое число</summary>
        </member>
        <member name="P:MathCore.Complex.Reciprocal">
            <summary>Обратное значение 1/Z</summary>
        </member>
        <member name="M:MathCore.Complex.#ctor(System.Double,System.Double)">
            <summary>Комплексное число</summary>
            <param name="Re">Действительная часть</param>
            <param name="Im">Мнимая часть</param>
        </member>
        <member name="M:MathCore.Complex.ToString_Exponent">
            <summary>Представление комплексного числа в текстовой экспоненциальной форме</summary>
            <returns>Текстовое экспоненциальное представление комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.ToString_Exponent_pi">
            <summary>Представление комплексного числа в текстовой экспоненциальной форме с нормировкой аргумента к значению pi</summary>
            <returns>Текстовое экспоненциальное представление комплексного числа с нормировкой аргумента к значению pi</returns>
        </member>
        <member name="M:MathCore.Complex.ToString_Exponent_Deg">
            <summary>Представление комплексного числа в текстовой экспоненциальной форме с нормировкой аргумента в градусах</summary>
            <returns>Текстовое экспоненциальное представление комплексного числа с нормировкой аргумента в градусах</returns>
        </member>
        <member name="M:MathCore.Complex.ToString">
            <summary>Строковый эквивалент</summary>
        </member>
        <member name="M:MathCore.Complex.ToString(System.String)">
            <summary>Преобразование в строковый формат</summary>
            <param name="Format">Формат преобразования</param>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.Complex.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Complex.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Complex.Clone">
            <summary>Получение клона</summary>
            <returns>Клон числа</returns>
        </member>
        <member name="M:MathCore.Complex.System#ICloneable#Clone">
            <summary>Получение клона</summary>
            <returns>Клон числа</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Complex.Equals(MathCore.Complex)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{MathCore#Complex}#Equals(MathCore.Complex)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.ValueTuple{System.Double,System.Double})">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{(System#DoubleRe,System#DoubleIm)}#Equals(System.ValueTuple{System.Double,System.Double})">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.ValueTuple{System.Int32,System.Double})">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{(System#Int32Re,System#DoubleIm)}#Equals(System.ValueTuple{System.Int32,System.Double})">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.ValueTuple{System.Double,System.Int32})">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{(System#DoubleRe,System#Int32Im)}#Equals(System.ValueTuple{System.Double,System.Int32})">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Double)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Double}#Equals(System.Double)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Int16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Int16}#Equals(System.Int16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.UInt16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#UInt16}#Equals(System.UInt16)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Byte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Byte}#Equals(System.Byte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.SByte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#SByte}#Equals(System.SByte)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Single)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Single}#Equals(System.Single)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Int32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Int32}#Equals(System.Int32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.UInt32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#UInt32}#Equals(System.UInt32)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.Int64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#Int64}#Equals(System.Int64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Equals(System.UInt64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое значение</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.System#IEquatable{System#UInt64}#Equals(System.UInt64)">
            <summary>Проверка на идентичность</summary>
            <param name="other">Проверяемое число</param>
            <returns>Истина, если числа идентичны</returns>
        </member>
        <member name="M:MathCore.Complex.Rotate(System.Double)">
            <summary>Поворот вектора комплексного числа на угол</summary>
            <param name="w">Угол поворота вектора в комплексной плоскости</param>
            <returns>Комплексное число, повёрнутое на угол</returns>
        </member>
        <member name="M:MathCore.Complex.Round(System.Int32)">
            <summary>Округление числа</summary>
            <param name="DigitsCount">Число разрядов</param>
            <returns>Округлённое число</returns>
        </member>
        <member name="M:MathCore.Complex.Sqrt">
            <summary>Вычисление квадратного корня числа</summary>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:MathCore.Complex.Sqrt(MathCore.Complex)">
            <summary>Вычисление корня комплексной степени</summary>
            <param name="z">Комплексная степень корня</param>
            <returns>Комплексный результат вычисления корня комплексной степени от комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.Sqrt(System.Double)">
            <summary>Вычисление корня действительной степени</summary>
            <param name="x">Действительная степень корня</param>
            <returns>Комплексный результат вычисления корня действительной степени от комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.Deconstruct(System.Double@,System.Double@)">
            <summary>Деконструктор комплексного числа</summary>
            <param name="re">Действительная часть</param>
            <param name="im">Мнимая часть</param>
        </member>
        <member name="M:MathCore.Complex.op_UnaryPlus(MathCore.Complex)">
            <summary>Унарный оператор суммы. Возвращает число Re+jIm</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает Re+jIm</returns>
        </member>
        <member name="M:MathCore.Complex.op_UnaryNegation(MathCore.Complex)">
            <summary>Унарный оператор разности. Возвращает число -Re-jIm</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает -Re-jIm</returns>
        </member>
        <member name="M:MathCore.Complex.op_LogicalNot(MathCore.Complex)">
            <summary>Оператор комплексного сопряжения</summary>
            <param name="z">Комплексное число</param>
            <returns>Возвращает Re-jIm</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex,MathCore.Complex)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.ValueTuple{System.Double,System.Double},MathCore.Complex)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.ValueTuple{System.Int32,System.Double},MathCore.Complex)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.ValueTuple{System.Double,System.Int32},MathCore.Complex)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.ValueTuple{System.Int32,System.Int32},MathCore.Complex)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex,MathCore.Complex)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.ValueTuple{System.Double,System.Double},MathCore.Complex)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.ValueTuple{System.Int32,System.Double},MathCore.Complex)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.ValueTuple{System.Double,System.Int32},MathCore.Complex)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.ValueTuple{System.Int32,System.Int32},MathCore.Complex)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Double,MathCore.Complex)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Int32,MathCore.Complex)">
            <summary>Оператор суммы целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>X+Re{Y}+jIm{Y}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Single,MathCore.Complex)">
            <summary>Оператор суммы вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности число</param>
            <param name="Y">Комплексное число</param>
            <returns>X+Re{Y}+jIm{Y}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Double,MathCore.Complex)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Int32,MathCore.Complex)">
            <summary>Оператор разности целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>X-Re{Y}-jIm{Y}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Single,MathCore.Complex)">
            <summary>Оператор разности вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности число</param>
            <param name="Y">Комплексное число</param>
            <returns>X-Re{Y}-jIm{Y}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex,System.Double)">
            <summary>Оператор сложения</summary>
            <param name="X">Первое слагаемое</param>
            <param name="Y">Второе слагаемое</param>
            <returns>Сумма комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex,System.Int32)">
            <summary>Оператор суммы комплексного числа и целого числа</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Re{X}+Y+jIm{X}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex,System.Single)">
            <summary>Оператор суммы комплексного числа и вещественного числа одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Re{X}+Y+jIm{X}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex,System.Double)">
            <summary>Оператор разности комплексных чисел</summary>
            <param name="X">Уменьшаемое комплексное число</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Разность комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex,System.Int32)">
            <summary>Оператор разности комплексного числа и целого числа</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Re{X}-Y+jIm{X}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex,System.Single)">
            <summary>Оператор разности комплексного числа и вещественного числа одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Re{X}-Y+jIm{X}</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex,System.Double)">
            <summary>Оператор умножения комплексного числа на вещественное</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex,System.Int32)">
            <summary>Оператор умножения комплексного числа на целое</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Целое число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex,System.Single)">
            <summary>Оператор умножения комплексного числа на вещественное одинарной точности</summary>
            <param name="X">Комплексное число</param>
            <param name="Y">Вещественное число одинарной точности</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex,System.Double)">
            <summary>Оператор деления комплексного числа на вещественное</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Вещественный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex,System.Int32)">
            <summary>Оператор деления комплексного числа на целое</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Целый делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex,System.Single)">
            <summary>Оператор деления комплексного числа на вещественное одинарной точности</summary>
            <param name="X">Комплексное делимое число</param>
            <param name="Y">Вещественный делитель одинарной точности</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Double,MathCore.Complex)">
            <summary>Оператор произведения вещественного и комплексного числа</summary>
            <param name="X">Вещественное число</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Int32,MathCore.Complex)">
            <summary>Оператор произведения целого и комплексного числа</summary>
            <param name="X">Целое число</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Single,MathCore.Complex)">
            <summary>Оператор произведения вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное число одинарной точности</param>
            <param name="Y">Комплексное число</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Double,MathCore.Complex)">
            <summary>Оператор деления вещественного и комплексного числа</summary>
            <param name="X">Вещественное делимое число</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Int32,MathCore.Complex)">
            <summary>Оператор деления целого и комплексного числа</summary>
            <param name="X">Целого делимое число</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Single,MathCore.Complex)">
            <summary>Оператор деления вещественного числа одинарной точности и комплексного числа</summary>
            <param name="X">Вещественное делимое число одинарной точности</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Комплексное частное</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex,MathCore.Complex)">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.ValueTuple{System.Double,System.Double},MathCore.Complex)">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.ValueTuple{System.Int32,System.Double},MathCore.Complex)">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.ValueTuple{System.Double,System.Int32},MathCore.Complex)">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.ValueTuple{System.Int32,System.Int32},MathCore.Complex)">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор произведения двух комплексных чисел</summary>
            <param name="X">Первый множитель</param>
            <param name="Y">Второй множитель</param>
            <returns>Комплексное произведение</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex,MathCore.Complex)">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.ValueTuple{System.Double,System.Double},MathCore.Complex)">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.ValueTuple{System.Int32,System.Double},MathCore.Complex)">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.ValueTuple{System.Double,System.Int32},MathCore.Complex)">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.ValueTuple{System.Int32,System.Int32},MathCore.Complex)">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор деления двух комплексных чисел</summary>
            <param name="X">Делимое комплексное число</param>
            <param name="Y">Делитель комплексного числа</param>
            <returns>Частное двух комплексных чисел</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex,System.Double)">
            <summary>Возведение комплексного числа в вещественную степень по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Вещественный показатель степени Z^X</param>
            <returns>Z^X</returns>       
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex,System.Single)">
            <summary>Возведение комплексного числа в вещественную степень одинарной точности по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Вещественный показатель степени одинарной точности Z^X</param>
            <returns>Z^X</returns> 
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex,System.Int32)">
            <summary>Возведение комплексного числа в целую степень по формуле Муавра</summary>
            <param name="Z">Возводимое в степень комплексное число Z^X</param>
            <param name="X">Целый показатель степени Z^X</param>
            <returns>Z^X</returns> 
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.Double,MathCore.Complex)">
            <summary>Оператор возведения вещественного числа в комплексную степень</summary>
            <param name="X">Вещественное число</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения вещественного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.Single,MathCore.Complex)">
            <summary>Оператор возведения вещественного числа одинарной точности в комплексную степень</summary>
            <param name="X">Вещественное число одинарной точности</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения вещественного числа одинарной точности в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.Int32,MathCore.Complex)">
            <summary>Оператор возведения целого числа в комплексную степень</summary>
            <param name="X">Целое число</param>
            <param name="Z">Комплексная степень</param>
            <returns>Комплексный результат возведения целого числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex,MathCore.Complex)">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.ValueTuple{System.Double,System.Double},MathCore.Complex)">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.ValueTuple{System.Int32,System.Double},MathCore.Complex)">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.ValueTuple{System.Double,System.Int32},MathCore.Complex)">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(MathCore.Complex,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_ExclusiveOr(System.ValueTuple{System.Int32,System.Int32},MathCore.Complex)">
            <summary>Оператор возведения комплексного числа в комплексную степень</summary>
            <param name="X">Комплексное основание экспоненты</param>
            <param name="Y">Комплексный показатель степени</param>
            <returns>Комплексный результат возведения комплексного числа в комплексную степень</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Int32[],MathCore.Complex)">
            <summary>Оператор, прибавляющий комплексное число к массиву целых чисел</summary>
            <param name="X">Массив целых чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы целых чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Single[],MathCore.Complex)">
            <summary>Оператор, прибавляющий комплексное число к массиву действительных чисел одинарной точности</summary>
            <param name="X">Массив действительных чисел одинарной точности</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы вещественных чисел одинарной точности исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.Double[],MathCore.Complex)">
            <summary>Оператор, прибавляющий комплексное число к массиву действительных чисел</summary>
            <param name="X">Массив действительных чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы вещественных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Int32[],MathCore.Complex)">
            <summary>Оператор, вычитающий комплексное число из массива целых чисел</summary>
            <param name="X">Массив целых чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности целых чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Single[],MathCore.Complex)">
            <summary>Оператор, вычитающий комплексное число из массива вещественных чисел одинарной точности</summary>
            <param name="X">Массив действительных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности вещественных чисел одинарной точности исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.Double[],MathCore.Complex)">
            <summary>Оператор, вычитающий комплексное число из массива вещественных чисел</summary>
            <param name="X">Массив действительных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности вещественных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Int32[],MathCore.Complex)">
            <summary>Оператор, умножающий комплексное число на массив целых чисел</summary>
            <param name="X">Массив целых чисел</param>
            <param name="Y">Комплексный множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения целых чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Single[],MathCore.Complex)">
            <summary>Оператор, умножающий комплексное число на массив вещественных чисел одинарной точности</summary>
            <param name="X">Массив вещественных чисел одинарной точности</param>
            <param name="Y">Комплексный множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения вещественных чисел одинарной точности исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.Double[],MathCore.Complex)">
            <summary>Оператор, умножающий комплексное число на массив вещественных чисел</summary>
            <param name="X">Массив вещественных чисел</param>
            <param name="Y">Комплексный множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения вещественных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Int32[],MathCore.Complex)">
            <summary>Оператор поэлементного деления массива целых чисел на комплексное число</summary>
            <param name="X">Массив целых чисел</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного деления целых чисел исходного массива на указанное комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Single[],MathCore.Complex)">
            <summary>Оператор поэлементного деления массива вещественных чисел одинарной точности на комплексное число</summary>
            <param name="X">Массив вещественных чисел одинарной точности</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного деления вещественных чисел одинарной точности исходного массива на указанное комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.Double[],MathCore.Complex)">
            <summary>Оператор поэлементного деления массива вещественных чисел на комплексное число</summary>
            <param name="X">Массив вещественных чисел</param>
            <param name="Y">Комплексный делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного деления вещественных чисел исходного массива на указанное комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(MathCore.Complex[],MathCore.Complex)">
            <summary>Оператор поэлементной суммы массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.ValueTuple{System.Double,System.Double}[],MathCore.Complex)">
            <summary>Оператор поэлементной суммы массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.ValueTuple{System.Int32,System.Double}[],MathCore.Complex)">
            <summary>Оператор поэлементной суммы массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.ValueTuple{System.Double,System.Int32}[],MathCore.Complex)">
            <summary>Оператор поэлементной суммы массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Addition(System.ValueTuple{System.Int32,System.Int32}[],MathCore.Complex)">
            <summary>Оператор поэлементной суммы массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Прибавляемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной суммы комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(MathCore.Complex[],MathCore.Complex)">
            <summary>Оператор поэлементной разности массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.ValueTuple{System.Double,System.Double}[],MathCore.Complex)">
            <summary>Оператор поэлементной разности массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.ValueTuple{System.Int32,System.Double}[],MathCore.Complex)">
            <summary>Оператор поэлементной разности массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.ValueTuple{System.Double,System.Int32}[],MathCore.Complex)">
            <summary>Оператор поэлементной разности массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Subtraction(System.ValueTuple{System.Int32,System.Int32}[],MathCore.Complex)">
            <summary>Оператор поэлементной разности массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Вычитаемое комплексное число</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементной разности комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(MathCore.Complex[],MathCore.Complex)">
            <summary>Оператор поэлементного произведения массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.ValueTuple{System.Double,System.Double}[],MathCore.Complex)">
            <summary>Оператор поэлементного произведения массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.ValueTuple{System.Int32,System.Double}[],MathCore.Complex)">
            <summary>Оператор поэлементного произведения массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.ValueTuple{System.Double,System.Int32}[],MathCore.Complex)">
            <summary>Оператор поэлементного произведения массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Multiply(System.ValueTuple{System.Int32,System.Int32}[],MathCore.Complex)">
            <summary>Оператор поэлементного произведения массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных множитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного произведения комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(MathCore.Complex[],MathCore.Complex)">
            <summary>Оператор поэлементного частного массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного частного комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.ValueTuple{System.Double,System.Double}[],MathCore.Complex)">
            <summary>Оператор поэлементного частного массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного частного комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.ValueTuple{System.Int32,System.Double}[],MathCore.Complex)">
            <summary>Оператор поэлементного частного массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного частного комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.ValueTuple{System.Double,System.Int32}[],MathCore.Complex)">
            <summary>Оператор поэлементного частного массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного частного комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Division(System.ValueTuple{System.Int32,System.Int32}[],MathCore.Complex)">
            <summary>Оператор поэлементного частного массива комплексных чисел и комплексного числа</summary>
            <param name="X">Массив комплексных чисел</param>
            <param name="Y">Комплексных делитель</param>
            <returns>Массив комплексных чисел, являющийся результатом поэлементного частного комплексных чисел исходного массива и указанного комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(System.ValueTuple{System.Double,System.Double},MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(System.ValueTuple{System.Int32,System.Double},MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(System.ValueTuple{System.Double,System.Int32},MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(System.ValueTuple{System.Int32,System.Int32},MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор сравнения двух комплексных чисел (равенства)</summary>
            <returns>Истина, если числа равны между собой</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(System.ValueTuple{System.Double,System.Double},MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(System.ValueTuple{System.Int32,System.Double},MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(System.ValueTuple{System.Double,System.Int32},MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(System.ValueTuple{System.Int32,System.Int32},MathCore.Complex)">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор сравнения двух комплексных чисел (неравенства)</summary>
            <returns>Истина, если числа не равны</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.Single)">
            <summary>Оператор равенства комплексного числа вещественному числу одинарной точности</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое вещественное число одинарной точности</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.Single)">
            <summary>Оператор неравенства комплексного числа вещественному числу одинарной точности</summary>
            <param name="X">Сравниваемое комплексное число одинарной точности</param>
            <param name="Y">Сравниваемое вещественное число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.Double)">
            <summary>Оператор равенства комплексного числа вещественному числу</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое вещественное число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.Double)">
            <summary>Оператор неравенства комплексного числа вещественному числу</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое вещественное число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.SByte)">
            <summary>Оператор равенства комплексного числа целому числу (1 байт со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (1 байт со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.SByte)">
            <summary>Оператор неравенства комплексного числа целому числу (1 байт со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (1 байт со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.Byte)">
            <summary>Оператор равенства комплексного числа целому числу (1 байт без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (1 байт без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.Byte)">
            <summary>Оператор неравенства комплексного числа целому числу (1 байт без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (1 байт без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.Int16)">
            <summary>Оператор равенства комплексного числа целому числу (2 байта со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (2 байта со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.Int16)">
            <summary>Оператор неравенства комплексного числа целому числу (2 байта со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (2 байта со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.UInt16)">
            <summary>Оператор равенства комплексного числа целому числу (2 байта без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (2 байта без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.UInt16)">
            <summary>Оператор неравенства комплексного числа целому числу (2 байта без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (2 байта без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.Int32)">
            <summary>Оператор равенства комплексного числа целому числу</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.Int32)">
            <summary>Оператор неравенства комплексного числа целому числу</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.UInt32)">
            <summary>Оператор равенства комплексного числа целому числу без знака</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число без знака</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.UInt32)">
            <summary>Оператор неравенства комплексного числа целому числу без знака</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число без знака</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.Int64)">
            <summary>Оператор неравенства комплексного числа целому числу (8 байт со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (8 байт со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.Int64)">
            <summary>Оператор равенства комплексного числа целому числу (8 байт со знаком)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (8 байт со знаком)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Equality(MathCore.Complex,System.UInt64)">
            <summary>Оператор неравенства комплексного числа целому числу (8 байт без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (8 байт без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> не равна <paramref name="Y"/>, либо мнимая часть не равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Inequality(MathCore.Complex,System.UInt64)">
            <summary>Оператор равенства комплексного числа целому числу (8 байт без знака)</summary>
            <param name="X">Сравниваемое комплексное число</param>
            <param name="Y">Сравниваемое целое число (8 байт без знака)</param>
            <returns>Истина, если реальная часть <paramref name="X"/> равна <paramref name="Y"/>, а мнимая часть равна 0</returns>
        </member>
        <member name="M:MathCore.Complex.op_Explicit(MathCore.Complex)~System.Double">
            <summary>Оператор неявного приведения к дробному типу чисел с двойной точностью</summary>
            <param name="Z">Приводимое комплексное число</param>
            <returns>Модуль комплексного числа</returns>
        </member>
        <member name="M:MathCore.Complex.op_Implicit(System.Double)~MathCore.Complex">
            <summary>Оператор неявного приведения дробного числа двойной точности к комплексному виду</summary>
            <param name="X">Вещественное число двойной точности</param>
            <returns>Комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Implicit(System.Int32)~MathCore.Complex">
            <summary>Оператор неявного приведения целого числа к комплексному виду</summary>
            <param name="X">Целое число</param>
            <returns>Комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Implicit(System.ValueTuple{System.Double,System.Double})~MathCore.Complex">
            <summary>Оператор неявного приведения кортежа, состоящего из двух вещественных чисел в комплексное число</summary>
            <param name="Z">Кортеж из двух вещественных чисел - действительной и мнимой части</param>
            <returns>Комплексное число</returns>
        </member>
        <member name="M:MathCore.Complex.op_Implicit(MathCore.Complex)~System.ValueTuple{System.Double,System.Double}">
            <summary>Оператор неявного приведения комплексного числа в кортеж, состоящий из двух вещественных чисел</summary>
            <param name="Z">Комплексное число</param>
            <returns>Кортеж из двух вещественных чисел - действительной и мнимой части</returns>
        </member>
        <member name="T:MathCore.Complex.Trigonometry">
            <summary>Тригонометрические функции комплексного переменного</summary>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Sin(MathCore.Complex)">
            <summary>Синус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Синус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Cos(MathCore.Complex)">
            <summary>Косинус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Косинус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Tg(MathCore.Complex)">
            <summary>Тангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Тангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Ctg(MathCore.Complex)">
            <summary>Котангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Котангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Asin(MathCore.Complex)">
            <summary>Арксинус комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арксинус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Acos(MathCore.Complex)">
            <summary>Арккосинус комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арккосинус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Atan(MathCore.Complex)">
            <summary>Арктангенс комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арктангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Arctg(MathCore.Complex)">
            <summary>Арккатангенс комплексного переменного</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Арккатангенс комплексного аргумента</returns>
        </member>
        <member name="T:MathCore.Complex.Trigonometry.Hyperbolic">
            <summary>Гиперболические функции</summary>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Hyperbolic.Sh(MathCore.Complex)">
            <summary>Гиперболический синус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический синус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Hyperbolic.Ch(MathCore.Complex)">
            <summary>Гиперболический косинус</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический косинус комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Hyperbolic.Tgh(MathCore.Complex)">
            <summary>Гиперболический тангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический тангенс комплексного аргумента</returns>
        </member>
        <member name="M:MathCore.Complex.Trigonometry.Hyperbolic.Ctgh(MathCore.Complex)">
            <summary>Гиперболический котангенс</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Гиперболический котангенс комплексного аргумента</returns>
        </member>
        <member name="T:MathCore.ComplexExtensions">
            <summary>Методы-расширения комплексных чисел</summary>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToRe(MathCore.Complex[])">
            <summary>Преобразование массива комплексных чисел в массив действительных</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив действительных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToIm(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив значений мнимых чисел</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив значений комплексных мнимых чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToAbs(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив модулей</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив модулей комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToArg(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив аргументов</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив аргументов комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToArgDeg(MathCore.Complex[])">
            <summary>Преобразование массива комплексных чисел в массив значений аргумента каждого из них в градусах</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив аргументов в градусах</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToReImArray(MathCore.Complex[])">
            <summary>
            Массив комплексных чисел в двумерный массив действительных и мнимых частей, где
            Re = V[i,0] Im = V[i,1]
            </summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Двумерный массив вещественных и мнимых частей</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToReImTuple(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив кортежей действительных и мнимых частей</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив кортежей вещественных и мнимых частей</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToAbsArgArray(MathCore.Complex[])">
            <summary>
            Массив комплексных чисел в двумерный массив модулей и аргументов частей, где
            Abs = V[i,0] Arg = V[i,1]
            </summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Двумерный массив модулей и аргументов</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToAbsArgTuple(MathCore.Complex[])">
            <summary>Массив комплексных чисел в массив кортежей модулей и аргументов</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив кортежей модулей и аргументов</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToComplex(System.Double[])">
            <summary>Преобразовать массив действительных в массив комплексных чисел</summary>
            <param name="Re">Массив действительных чисел</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.ToComplex(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив действительных в массив комплексных чисел</summary>
            <param name="Values">Двумерный массив действительных чисел, где Re = V[i,0], Im = V[i,1]</param>
            <returns>Массив комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexExtensions.GetAbs(MathCore.Complex[])">
            <summary>Преобразование в массив модулей</summary>
            <param name="ZZ">Массив комплексных чисел</param>
            <returns>Массив модулей комплексных чисел</returns>
        </member>
        <member name="T:MathCore.ComplexConverter">
            <summary>Конвертер комплексных чисел</summary>
        </member>
        <member name="M:MathCore.ComplexConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ComplexConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ComplexConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ComplexConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.ConsoleProgressBar">
            <summary>
            Индикатор прогресса для консоли
                <code>
                Console.Write("Performing some task... ");
                const int max = 2000;
                using (var progress = new ProgressBar(50) { PercentSymbol = null, PercentFormat = "p1" })
                    for (var i = 0; i &lt;= max; i++)
                    {
                        progress.Report((double) i / max);
                        Thread.Sleep(20);
                        Console.Title = i.ToString();
                    }
                Console.WriteLine("Done.");
                </code>
            </summary>
        </member>
        <member name="T:MathCore.Consts">
            <summary>Константы</summary>
        </member>
        <member name="F:MathCore.Consts.Percent">
            <summary>% = 0.01</summary>
        </member>
        <member name="F:MathCore.Consts.e">
            <summary>e = 2.7182818284590452353602874713527</summary>
        </member>
        <member name="F:MathCore.Consts.pi00625">
            <summary>π/16 (90°/8 = 11.25°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi0125">
            <summary>π/8 (90/4° = 22.5°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi025">
            <summary>π/4 (90°/2 = 45°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi05">
            <summary>π/2 (90°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi05neg">
            <summary>-π/2 (-90°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi">
            <summary>π = 3.1415926535897932384626433832795028841971693993751</summary>
        </member>
        <member name="F:MathCore.Consts.pi_neg">
            <summary>-π = -3.1415926535897932384626433832795028841971693993751</summary>
        </member>
        <member name="F:MathCore.Consts.pi2">
            <summary>2·π (360°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi2neg">
            <summary>-2·π (-360°)</summary>
        </member>
        <member name="F:MathCore.Consts.pi3_2">
            <summary>3·π/2</summary>
        </member>
        <member name="F:MathCore.Consts.LnPi">
            <summary>Ln_e(pi)</summary>
        </member>
        <member name="F:MathCore.Consts.Ln2Pi">
            <summary>Ln_e(2pi)</summary>
        </member>
        <member name="F:MathCore.Consts.Ln2Sqrt_e_div_pi">
            <summary>ln(2√(e/π))</summary>
        </member>
        <member name="F:MathCore.Consts.Log2_10">
            <summary>log2(10) - логарифм 10 по основанию 2</summary>
        </member>
        <member name="F:MathCore.Consts.Log10_2">
            <summary>log10(2) - логарифм 2 по основанию 10</summary>
        </member>
        <member name="F:MathCore.Consts.ToRad">
            <summary>π/180</summary>
        </member>
        <member name="F:MathCore.Consts.ToDeg">
            <summary>180/π</summary>
        </member>
        <member name="F:MathCore.Consts.pi_name">
            <summary>'π'</summary>
        </member>
        <member name="F:MathCore.Consts.deg_name">
            <summary>'°'</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_e">
            <summary>√e</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_pi">
            <summary>√π</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_pi2">
            <summary>√(2·π)</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_pi05">
            <summary>√(π/2)</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_2">
            <summary>√2 = 1.4142135623730950488016887242096980785696718753769</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_2_inv">
            <summary>1 / √2 = 0.707...</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_3">
            <summary>√3 = 1.7320508075688772935274463415058723669428052538104</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_5">
            <summary>√5 = 2.236067...</summary>
        </member>
        <member name="F:MathCore.Consts.sqrt_5_inv">
            <summary>1 / √5 = 0.4472135954999579...</summary>
        </member>
        <member name="F:MathCore.Consts.GoldenRatio">
            <summary>Золотое сечение = (√5 + 1)/2</summary>
        </member>
        <member name="F:MathCore.Consts.GoldenRatio_Inv">
            <summary>Величина, обратная золотому сечению = (√5 - 1)/2</summary>
        </member>
        <member name="T:MathCore.Consts.Geometry">
            <summary>Геометрические константы</summary>
        </member>
        <member name="F:MathCore.Consts.Geometry.ToDeg">
            <summary>Константа преобразования радиан в градусы = 180/π</summary>
        </member>
        <member name="F:MathCore.Consts.Geometry.ToRad">
            <summary>Константа преобразования градусов в радианы = π/180</summary>
        </member>
        <member name="F:MathCore.Consts.Geometry.Pi">
            <summary>Системная константа π = 3.1415926535897932384626433832</summary>
        </member>
        <member name="M:MathCore.Consts.Geometry.ConvertToDeg(System.Double)">
            <summary>Преобразовать значение из радиан в градусы</summary>
            <param name="RadValue">Значение в радианах</param>
            <returns>Значение в градусах</returns>
        </member>
        <member name="M:MathCore.Consts.Geometry.ConvertToRad(System.Double)">
            <summary>Преобразовать значение из градусов в радианы</summary>
            <param name="DegValue">Значение в градусах</param>
            <returns>Значение в радианах</returns>
        </member>
        <member name="F:MathCore.Consts.SpeedOfLight">
            <summary>Скорость света 300`000`000 м/с = 3e8 м/с</summary>
        </member>
        <member name="F:MathCore.Consts.SpeedOfLightInVacuum">
            <summary>Скорость света в вакууме 299`792`458 м/с</summary>
        </member>
        <member name="F:MathCore.Consts.GravitationConstant">
            <summary>Гравитационная постоянная 6.67384(80)×10^−11 m^3·кг^−1·с^−2</summary>
        </member>
        <member name="F:MathCore.Consts.PlanckConstant">
            <summary>Постоянная Планка 6.626 069 57(29) ×10^−34 Жд·с</summary>
        </member>
        <member name="F:MathCore.Consts.PlanckConstant_Reduced">
            <summary>Приведённая постоянная Планка 1.054 571 628(53) ×10^−34 Жд·с</summary>
        </member>
        <member name="F:MathCore.Consts.Planck_Temperature">
            <summary>Температура Планка √(h_bar * c^5/G)/k K</summary>
        </member>
        <member name="F:MathCore.Consts.Planck_Length">
            <summary>Длина Планка h_bar/(m_p*c) м</summary>
        </member>
        <member name="F:MathCore.Consts.Planck_Time">
            <summary>Время Планка lp/c с</summary>
        </member>
        <member name="T:MathCore.Consts.Electrodynamic">
            <summary>Электродинамические константы</summary>
        </member>
        <member name="F:MathCore.Consts.Electrodynamic.Epsilon0">
            <summary>Электрическая постоянная 1/(Mu0 · c^2) = 8,854187817620… ×10^−12 Ф·м^−1</summary>
        </member>
        <member name="F:MathCore.Consts.Electrodynamic.Mu0">
            <summary>Магнитная постоянная 4·π ×10^-7 = 1.2566370614E-6 Гн/м</summary>
        </member>
        <member name="F:MathCore.Consts.Electrodynamic.Impedance">
            <summary>Упрощённое сопротивление среды (вакуума) = √(Mu0/Epsilon0) = 377 Ом</summary>
        </member>
        <member name="F:MathCore.Consts.Electrodynamic.Impedance0">
            <summary>Сопротивление среды (вакуума) = √(Mu0/Epsilon0) = 376.730313461771 Ом</summary>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToWaveLength(System.Double)">
            <summary>Преобразовать значение частоты в длину волны</summary>
            <param name="Frequency">Значение частоты в Гц</param>
            <returns>Длина волны в метрах</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToWaveLength(System.Double,System.Double)">
            <summary>Преобразовать значение частоты в длину волны с учётом диэлектрической проницаемости среды</summary>
            <param name="Frequency">Значение частоты в Гц</param>
            <param name="Epsilon">Значение относительной диэлектрической проницаемости среды</param>
            <returns>Значение длины волны в среде в метрах</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToWaveLength(System.Double,System.Double,System.Double)">
            <summary>Преобразовать значение частоты в длину волны с учётом диэлектрической и магнитной проницаемости среды</summary>
            <param name="Frequency">Значение частоты в Гц</param>
            <param name="Epsilon">Значение относительной диэлектрической проницаемости среды</param>
            <param name="Mu">Значение магнитной проницаемости среды</param>
            <returns>Значение длины волны в среде в метрах</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToFrequency(System.Double)">
            <summary>Преобразование длины волны в метрах в частоту в Гц</summary>
            <param name="WaveLength">Значение длины волны в метрах</param>
            <returns>Значение частоты в Гц</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToFrequency(System.Double,System.Double)">
            <summary>Преобразование длины волны в среде в метрах в частоту в Гц</summary>
            <param name="WaveLength">Значение длины волны в среде в метрах</param>
            <param name="Epsilon">Значение относительной диэлектрической проницаемости среды</param>
            <returns>Значение частоты в Гц</returns>
        </member>
        <member name="M:MathCore.Consts.Electrodynamic.ToFrequency(System.Double,System.Double,System.Double)">
            <summary>Преобразование длины волны в среде в метрах в частоту в Гц</summary>
            <param name="WaveLength">Значение длины волны в среде в метрах</param>
            <param name="Epsilon">Значение относительной диэлектрической проницаемости среды</param>
            <param name="Mu">Значение магнитной проницаемости среды</param>
            <returns>Значение частоты в Гц</returns>
        </member>
        <member name="F:MathCore.Consts.BigPrime_int">
            <summary>0x3ffeffff = 1073676287</summary>
        </member>
        <member name="F:MathCore.Consts.BigPrime_long">
            <summary>0x3fffffefffffff = 18014398241046527</summary>
        </member>
        <member name="T:MathCore.Consts.DataLength">
            <summary>Размеры данных</summary>
        </member>
        <member name="T:MathCore.Consts.DataLength.Bytes">
            <summary>Размеры данных в байтах</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.B">
            <summary>1 Байт</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.kB">
            <summary>1 килобайт в байтах</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.MB">
            <summary>1 мегабайт в байтах</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.GB">
            <summary>1 гигабайт в байтах</summary>
        </member>
        <member name="F:MathCore.Consts.DataLength.Bytes.TB">
            <summary>1 терабайт в байтах</summary>
        </member>
        <member name="M:MathCore.Consts.DataLength.Bytes.GetDataNames">
            <summary>Получить имена значений количества байт с приставками "B", "kB", "MB", "GB", "TB"</summary>
            <returns>"B", "kB", "MB", "GB", "TB"</returns>
        </member>
        <member name="M:MathCore.Consts.DataLength.Bytes.GetDataNamesRu">
            <summary>Получить русскоязычные имена значений количества байт с приставками "Б", "кБ", "МБ", "ГБ", "ТБ"</summary>
            <returns>"Б", "кБ", "МБ", "ГБ", "ТБ"</returns>
        </member>
        <member name="F:MathCore.Consts.ElementaryCharge">
            <summary>Элементарный заряд e = 1,602 176 565(35)·10^−19 Кл</summary>
        </member>
        <member name="F:MathCore.Consts.BoltzmannConstant">
            <summary>Постоянная Больцмана k = 1,380 6488(13)·10^−23 Дж/К</summary>
        </member>
        <member name="F:MathCore.Consts.AvogadroConstant">
            <summary>Число Авогадро Na = 6,022 141 29(27)·10^23 1/моль</summary>
        </member>
        <member name="F:MathCore.Consts.FaradayConstant">
            <summary>Постоянная Фарадея F = e * Na = 96485,33(83) Кл/моль</summary>
        </member>
        <member name="T:MathCore.CSV.CSVParser">
            <summary>Парсер строк с разделителем</summary>
        </member>
        <member name="M:MathCore.CSV.CSVParser.ParseLine(System.String,System.Char,System.Boolean)">
            <summary>Разбор строки на элементы с учётом возможности экранирования разделителей кавычками</summary>
            <param name="Line">Разделяемая строка</param>
            <param name="Separator">Символ-разделитель</param>
            <param name="Trim">Обрезать служебные символы в начале и конце строки</param>
            <returns>Перечисление элементов строки</returns>
        </member>
        <member name="M:MathCore.CSV.CSVParser.CreateLine(System.Collections.Generic.IEnumerable{System.String},System.Char)">
            <summary>Объединение строк в одну с добавлением разделителя между элементами с возможностью экранирования разделителей в строках-компонентах</summary>
            <param name="Values">Строки, объединяемые в единую строку</param>
            <param name="Separator">Символ-разделитель</param>
            <returns>Строка, Составленная из указанного набора элементов</returns>
        </member>
        <member name="T:MathCore.CSV.CSVQuery">
            <summary>Объект, осуществляющий извлечение данных из файла в формате CSV</summary>
        </member>
        <member name="F:MathCore.CSV.CSVQuery._ReaderFactory">
            <summary>Метод-фабрика объектов чтения данных</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQuery.SkipRowsCount">
            <summary>Число строк, пропускаемых в начале файла</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQuery.SkipRowsAfterHeaderCount">
            <summary>Число строк, пропускаемых в начале файла после строки заголовка (даже при её отсутствии)</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQuery.TakeRowsCount">
            <summary>Число строк, извлекаемых из области данных</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQuery.ContainsHeader">
            <summary>В процессе чтения данных будет учитываться наличие строки заголовка</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQuery.Separator">
            <summary>Символ-разделитель значений строки</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQuery.EoL">
            <summary>Формат конца строки для расчёта положения в потоке</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQuery.Headers">
            <summary>Информация о заголовке файла - имена колонок : номера колонок</summary>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.#ctor(System.Func{System.IO.TextReader},System.Char)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.CSV.CSVQuery"/></summary>
            <param name="ReaderFactory">Метод-фабрика объектов чтения данных</param>
            <param name="Separator">Символ-разделитель значений</param>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.#ctor(System.Func{System.IO.TextReader},System.Int32,System.Boolean,System.Int32,System.Char,System.Int32,System.Collections.Generic.IDictionary{System.String,System.Int32},System.String,System.Globalization.CultureInfo)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.CSV.CSVQuery"/></summary>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.SkipRowsBeforeHeader(System.Int32)">
            <summary>Установить число пропускаемых строк в начале файла</summary>
            <param name="RowsCount">Количество пропускаемых строк в начале файла</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.SkipRowsAfterHeader(System.Int32)">
            <summary>Установить число строк, пропускаемых после заголовка</summary>
            <param name="RowsCount">Новое значение числа строк, пропускаемых после заголовка</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.WithHeader(System.Boolean)">
            <summary>Данные содержат заголовок?</summary>
            <param name="IsExist">Истина - заголовок будет учитываться при чтении</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.ValuesSeparator(System.Char)">
            <summary>Установить символ-разделитель значений в строке</summary>
            <param name="NewSeparator">Новый символ-разделитель значений строки</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.TakeRows(System.Int32)">
            <summary>Установить число читаемых строк</summary>
            <param name="RowsCount">Число читаемых строк области данных (если -1, то читать всё)</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.Header(System.Collections.Generic.IDictionary{System.String,System.Int32})">
            <summary>Установить заголовок</summary>
            <param name="Header">Новый заголовок данных - словарь соответствия имени колонки и её индекса</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.Merge(System.Collections.Generic.IDictionary{System.String,System.Int32},System.Collections.Generic.IDictionary{System.String,System.Int32})">
            <summary>Объединить словари заголовков</summary>
            <param name="Source">Исходный словарь значений</param>
            <param name="Values">Добавляемые данные</param>
            <returns>Новый словарь значений, содержащий в себе исходные значения и добавленные к ним новые</returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.MergeHeader(System.Collections.Generic.IDictionary{System.String,System.Int32})">
            <summary>Добавить в заголовок набор колонок</summary>
            <param name="Header">Добавляемые в заголовок колонки</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.AddColumn(System.String,System.Int32)">
            <summary>Добавить колонку в считываемый заголовок</summary>
            <param name="AliasName">Новый псевдоним колонки</param>
            <param name="Index">Индекс колонки</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.AddColumns(System.ValueTuple{System.String,System.Int32}[])">
            <summary>Добавить колонки в считываемый заголовок</summary>
            <param name="Columns">Новые псевдонимы колонок</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.RemoveColumn(System.String)">
            <summary>Удалить колонку по указанному имени</summary>
            <param name="ColumnName">Имя удаляемой колонки</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.RemoveColumn(System.Int32)">
            <summary>Удалить колонку по указанному индексу</summary>
            <param name="ColumnIndex">Индекс удаляемой колонки</param>
            <returns>Модифицированных новый экземпляр <see cref="T:MathCore.CSV.CSVQuery"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.WithEoL(System.String)">
            <summary>Установка символа конца строки для файла для корректного подсчёта положения в нём</summary>
            <param name="eol">Символ конца строки (по умолчанию \r\n)</param>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.WithCulture(System.Globalization.CultureInfo)">
            <summary>Установка культуры преобразования строк в базовые типы данных</summary>
            <param name="culture">Устанавливаемая культура</param>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.GetHeader(System.Boolean)">
            <summary>Считать заголовок данных</summary>
            <param name="MergeWithDefault"></param>
            <returns>Заголовок</returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.GetEnumerator">
            <summary>Получить объект-перечислитель строк данных</summary>
            <returns>Перечисление строк данных <see cref="T:MathCore.CSV.CSVQueryRow"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVQuery.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.CSV.CSVQueryRow">
            <summary>Строка данных</summary>
        </member>
        <member name="F:MathCore.CSV.CSVQueryRow._Items">
            <summary>Массив элементов данных строки</summary>
        </member>
        <member name="F:MathCore.CSV.CSVQueryRow._Header">
            <summary>Словарь столбцов</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQueryRow.ItemsCount">
            <summary>Число элементов данных строки</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQueryRow.Index">
            <summary>Индекс (номер) строки (отсчёт от 0)</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQueryRow.StartPos">
            <summary>Начальное положение в источнике</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQueryRow.EndPos">
            <summary>Конечное положение в источнике</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQueryRow.Headers">
            <summary>Заголовки строки</summary>
        </member>
        <member name="P:MathCore.CSV.CSVQueryRow.Item(System.Int32)">
            <summary>Строковое значение по указанному индексу колонки в строке данных</summary>
            <param name="ValueIndex">Индекс колонки</param>
            <returns>Строковое значение</returns>
        </member>
        <member name="P:MathCore.CSV.CSVQueryRow.Item(System.String)">
            <summary>Строковое значение по имени колонки</summary>
            <param name="ValueName">Имя колонки в массиве данных</param>
            <returns>Строковое значение</returns>
        </member>
        <member name="M:MathCore.CSV.CSVQueryRow.#ctor(System.String,System.Int32,System.String[],System.Collections.Generic.IDictionary{System.String,System.Int32},System.Int64,System.Int64,System.Globalization.CultureInfo)">
            <summary>Инициализация нового экземпляра строки данных <see cref="T:MathCore.CSV.CSVQueryRow"/></summary>
            <param name="SourceLine">Исходная строка</param>
            <param name="Index">Индекс строки</param>
            <param name="Items">Массив строковых значений</param>
            <param name="Header">Словарь заголовков</param>
            <param name="StartPos">Начальное положение в источнике</param>
            <param name="EndPos">Конечное положение в источнике</param>
            <param name="Culture">Сведения о культуре для выполнения преобразования данных</param>
        </member>
        <member name="M:MathCore.CSV.CSVQueryRow.ValueAs``1(System.Int32)">
            <summary>Представление значения в указанном типе</summary>
            <typeparam name="T">Требуемый тип значения</typeparam>
            <param name="ValueIndex">Индекс колонки</param>
            <returns>Представление значения в указанном типе</returns>
        </member>
        <member name="M:MathCore.CSV.CSVQueryRow.ValueAs``1(System.String)">
            <summary>Представление значения в указанном типе</summary>
            <typeparam name="T">Требуемый тип значения</typeparam>
            <param name="ValueName">Имя столбца</param>
            <returns>Представление значения в указанном типе</returns>
        </member>
        <member name="M:MathCore.CSV.CSVQueryRow.FirstValue">
            <summary>Первое строковое значение</summary>
        </member>
        <member name="M:MathCore.CSV.CSVQueryRow.LastValue">
            <summary>Последнее строковое значение</summary>
        </member>
        <member name="M:MathCore.CSV.CSVQueryRow.FirstValue``1">
            <summary>Первое значение</summary>
        </member>
        <member name="M:MathCore.CSV.CSVQueryRow.LastValue``1">
            <summary>Последнее значение</summary>
        </member>
        <member name="T:MathCore.CSV.CSVWriter`1">
            <summary>Объект для записи данных в формате CSV</summary>
            <typeparam name="T">ТИп записываемых элементов данных</typeparam>
        </member>
        <member name="F:MathCore.CSV.CSVWriter`1._Items">
            <summary>Перечисление записываемых элементов данных</summary>
        </member>
        <member name="F:MathCore.CSV.CSVWriter`1._Separator">
            <summary>Символ-разделитель значений в строке</summary>
        </member>
        <member name="F:MathCore.CSV.CSVWriter`1._Selectors">
            <summary>Словарь соответствия имени колонки методу извлечения значения и индексу колонки</summary>
        </member>
        <member name="F:MathCore.CSV.CSVWriter`1._WriteHeaders">
            <summary>Требуется ли записывать заголовок?</summary>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.GetOrdered(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.ValueTuple{System.Func{`0,System.Object},System.Int32}}})">
            <summary>Получить упорядоченное перечисление колонок</summary>
            <param name="Columns">Колонки</param>
            <returns>Упорядоченное по индексу, затем по имени перечисление колонок</returns>
        </member>
        <member name="P:MathCore.CSV.CSVWriter`1.Headers">
            <summary>Колонки данных</summary>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Char)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.CSV.CSVWriter`1"/></summary>
            <param name="items">Перечисление элементов, значения которых надо записать в формате CSV</param>
            <param name="Separator">Символ-разделитель значений в строках</param>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Char,System.Boolean,System.Collections.Generic.IDictionary{System.String,System.ValueTuple{System.Func{`0,System.Object},System.Int32}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.CSV.CSVWriter`1"/></summary>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.CreateHeaders">
            <summary>Создать заголовок</summary>
            <returns>Словарь колонок данных файла</returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.Separator(System.Char)">
            <summary>Изменить символ-разделитель значений в строках</summary>
            <param name="separator">Новый символ-разделитель</param>
            <returns>Модифицированный <see cref="T:MathCore.CSV.CSVWriter`1"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteHeader(System.Boolean)">
            <summary>Записывать ли заголовок в начало файла?</summary>
            <param name="write">Истина, если заголовок требуется записать</param>
            <returns>Модифицированный <see cref="T:MathCore.CSV.CSVWriter`1"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.AddDefaultHeaders">
            <summary>Добавить колонки по умолчанию - на основе имён свойств <typeparamref name="T"/></summary>
            <returns>Модифицированный <see cref="T:MathCore.CSV.CSVWriter`1"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.MergeSelectors(System.Collections.Generic.IDictionary{System.String,System.ValueTuple{System.Func{`0,System.Object},System.Int32}},System.Collections.Generic.IDictionary{System.String,System.ValueTuple{System.Func{`0,System.Object},System.Int32}})">
            <summary>Объединить колонки</summary>
            <param name="SourceColumns">Исходное описание столбцов</param>
            <param name="NewColumns">Добавляемое описание столбцов</param>
            <returns>Новый словарь колонок</returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.MergeSelectors(System.Collections.Generic.IDictionary{System.String,System.ValueTuple{System.Func{`0,System.Object},System.Int32}},System.String,System.Func{`0,System.Object})">
            <summary>Добавить новую колонку</summary>
            <param name="SourceColumns">Исходный набор колонок</param>
            <param name="NewColumnName">Имя добавляемой колонки</param>
            <param name="NewColumnValueSelector">Метод извлечения значения для новой колонки</param>
            <returns>Новый словарь колонок</returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.AddColumn(System.String,System.Func{`0,System.Object})">
            <summary>Добавить новую колонку</summary>
            <param name="NewColumnName">Имя добавляемой колонки</param>
            <param name="NewColumnValueSelector">Метод извлечения значения для новой колонки</param>
            <returns>Модифицированный <see cref="T:MathCore.CSV.CSVWriter`1"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.RemoveColumn(System.String)">
            <summary>Удалить колонку</summary>
            <param name="Name">Имя удаляемой колонки</param>
            <returns>Модифицированный <see cref="T:MathCore.CSV.CSVWriter`1"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.RemoveColumn(System.Int32)">
            <summary>Удалить колонку</summary>
            <param name="index">Индекс удаляемой колонки</param>
            <returns>Модифицированный <see cref="T:MathCore.CSV.CSVWriter`1"/></returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteTo(System.String,System.Text.Encoding)">
            <summary>Записать данные в файл по указанному пути</summary>
            <param name="FileName">Путь к файлу данных</param>
            <param name="encoding">Кодировка (если не указана, то используется <see cref="P:System.Text.Encoding.UTF8"/>)</param>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteToAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>Выполнить асинхронную запись в файл по указанному пути</summary>
            <param name="FileName">Путь к файлу данных</param>
            <param name="encoding">Кодировка (если не указана, то используется <see cref="P:System.Text.Encoding.UTF8"/>)</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Задача асинхронной записи данных</returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteTo(System.IO.FileInfo)">
            <summary>Записать данные в указанный файл</summary>
            <param name="File">Файл, в который требуется выполнить запись данных</param>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteToAsync(System.IO.FileInfo,System.Threading.CancellationToken)">
            <summary>Выполнить асинхронную запись в указанный файл</summary>
            <param name="File">Файл, в который требуется выполнить запись данных</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Задача асинхронной записи данных</returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteTo(System.IO.Stream,System.Text.Encoding)">
            <summary>Записать данные в поток</summary>
            <param name="stream">Поток данных, в который осуществляется запись</param>
            <param name="encoding">Кодировка (если не указана, то используется <see cref="P:System.Text.Encoding.UTF8"/>)</param>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteToAsync(System.IO.Stream,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>Выполнить асинхронную запись данных в поток</summary>
            <param name="stream">Поток данных, в который осуществляется запись</param>
            <param name="encoding">Кодировка (если не указана, то используется <see cref="P:System.Text.Encoding.UTF8"/>)</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Задача асинхронной записи данных</returns>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteTo(System.IO.TextWriter)">
            <summary>Записать данные в объект записи текстовых данных</summary>
            <param name="writer">Объект записи текстовых данных</param>
        </member>
        <member name="M:MathCore.CSV.CSVWriter`1.WriteToAsync(System.IO.TextWriter,System.Threading.CancellationToken)">
            <summary>Асинхронно записать данные в объект записи текстовых данных</summary>
            <param name="writer">Объект записи текстовых данных</param>
            <param name="Cancel">Признак отмены асинхронной операции</param>
            <returns>Задача асинхронной записи данных</returns>
        </member>
        <member name="M:MathCore.CSV.Extensions.OpenCSV(System.IO.FileInfo,System.Char)">
            <summary>Открыть файл для чтения данных в формате CSV</summary>
            <param name="file">Информация о файле данных</param>
            <param name="Separator">Символ-разделитель значений</param>
            <returns>Объект, осуществляющий извлечение данных из файла</returns>
        </member>
        <member name="M:MathCore.CSV.Extensions.AsCSV``1(System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>Представить перечисление в виде объекта записи данных в формате CSV</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="items">Элементы, упаковываемые в формат CSV</param>
            <param name="Separator">Символ-разделитель значений</param>
            <returns>Объект, осуществляющий запись данных в формате CSV</returns>
        </member>
        <member name="T:MathCore.Data.DataLength">
            <summary>Структура для отображения размера данных в Байтах, кБ, МБ, ГБ, ТБ ...</summary>
        </member>
        <member name="F:MathCore.Data.DataLength.__Threshold">
            <summary>Порог перехода между множителями Log(1024 * 0.7, __Base = 1024) - 70%</summary>
        </member>
        <member name="F:MathCore.Data.DataLength.__Units">
            <summary>Множители единиц измерения</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.Units">
            <summary>Множители единиц измерения</summary>
        </member>
        <member name="M:MathCore.Data.DataLength.Value(System.UInt64,System.Double,System.String@,System.Int32@)">
            <summary>Преобразовать значение в представление размера с множителем</summary>
            <param name="value">Преобразуемое значение</param>
            <param name="Base">Основание</param>
            <param name="unit">Имя множителя единицы измерения</param>
            <param name="index">Индекс множителя</param>
            <returns>Значение X в представлении value = Base^index</returns>
        </member>
        <member name="M:MathCore.Data.DataLength.Value(System.Double,System.Double,System.String@,System.Int32@)">
            <summary>Преобразовать значение в представление размера с множителем</summary>
            <param name="value">Преобразуемое значение</param>
            <param name="Base">Основание</param>
            <param name="unit">Имя множителя единицы измерения</param>
            <param name="index">Индекс множителя</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Если значение <paramref name="value"/> меньше 0</exception>
            <returns>Значение X в представлении value = Base^index</returns>
        </member>
        <member name="F:MathCore.Data.DataLength._Length">
            <summary>Исходное значение размера</summary>
        </member>
        <member name="F:MathCore.Data.DataLength._Base">
            <summary>Основание системы счисления для выделения множителя (1024 б, либо 1000 для физических значений)</summary>
        </member>
        <member name="F:MathCore.Data.DataLength._FormattedLength">
            <summary>Количественный размер данных с множителем</summary>
        </member>
        <member name="F:MathCore.Data.DataLength._Unit">
            <summary>Множитель размера данных</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.Length">
            <summary>Исходное значение размера</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.Base">
            <summary>Основание системы счисления для выделения множителя (1024 б, либо 1000 для физических значений)</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.FormattedLength">
            <summary>Количественный размер данных с множителем</summary>
        </member>
        <member name="P:MathCore.Data.DataLength.Unit">
            <summary>Множитель размера данных</summary>
        </member>
        <member name="M:MathCore.Data.DataLength.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Data.DataLength"/></summary>
            <param name="Length">Количественный размер данных</param>
            <param name="Base">Основание системы счисления (на пример 1024 = 1кб, либо 1000 для физических значений)</param>
        </member>
        <member name="M:MathCore.Data.DataLength.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.ToString(System.String)">
            <summary>Представление значения в строковом виде с форматированием числовых данных</summary>
            <param name="format">Строка формата числовых значений</param>
            <returns>Строковое представление с форматированием</returns>
        </member>
        <member name="M:MathCore.Data.DataLength.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.Equals(MathCore.Data.DataLength)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Data.DataLength.op_Equality(MathCore.Data.DataLength,MathCore.Data.DataLength)">
            <summary>Оператор определения равенства между двумя экземплярами <see cref="T:MathCore.Data.DataLength"/></summary>
            <returns>Истина, если все поля экземпляров совпадают</returns>
        </member>
        <member name="M:MathCore.Data.DataLength.op_Inequality(MathCore.Data.DataLength,MathCore.Data.DataLength)">
            <summary>Оператор определения неравенства между двумя экземплярами <see cref="T:MathCore.Data.DataLength"/></summary>
            <returns>Истина, если хотя бы одно поле экземпляров отличается</returns>
        </member>
        <member name="T:MathCore.Data.PropertyLink`2">
            <summary>Связь между свойствами</summary>
            <typeparam name="TSource">Тип объекта-источника данных</typeparam>
            <typeparam name="TDestination">Тип объекта-приёмника данных</typeparam>
        </member>
        <member name="F:MathCore.Data.PropertyLink`2._Source">
            <summary>Источник данных</summary>
        </member>
        <member name="F:MathCore.Data.PropertyLink`2._Destination">
            <summary>Приёмник данных</summary>
        </member>
        <member name="F:MathCore.Data.PropertyLink`2._SourcePropertyDescriptor">
            <summary>Дескриптор свойства источника данных</summary>
        </member>
        <member name="F:MathCore.Data.PropertyLink`2._DestinationPropertyDescriptor">
            <summary>Дескриптор свойства приёмника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.Source">
            <summary>Источник данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.Destination">
            <summary>Приёмник данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.SourceProperty">
            <summary>Дескриптор свойства источника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.DestinationProperty">
            <summary>Дескриптор свойства приёмника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.SourceType">
            <summary>Источник данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.DestinationType">
            <summary>Приёмник данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.SourcePropertyType">
            <summary>Тип свойства источника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.DestinationPropertyType">
            <summary>Тип свойства приёмника данных</summary>
        </member>
        <member name="P:MathCore.Data.PropertyLink`2.Enable">
            <summary>Активатор связи</summary>
        </member>
        <member name="M:MathCore.Data.PropertyLink`2.#ctor(`0,System.String,`1,System.String,System.Boolean)">
            <summary>Новая связь между свойством источника и приёмника данных</summary>
            <param name="Source">Источник данных</param>
            <param name="SourcePropertyName">Имя свойства источника данных</param>
            <param name="Destination">Приёмник данных</param>
            <param name="DestinationPropertyName">Имя свойства приёмника данных</param>
            <param name="Enable">Признак активности связи (по умолчанию = true)</param>
        </member>
        <member name="M:MathCore.Data.PropertyLink`2.SourcePropertyChanged(System.Object,System.EventArgs)">
            <summary>Обработчик события изменения свойства источника данных</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:MathCore.DataGenericSources.DataHost.Dispose">
            <inheritdoc />
        </member>
        <member name="T:MathCore.DictionaryKeySafe`2">
            <summary>Безопасный для доступа к ключам словарь</summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
        </member>
        <member name="F:MathCore.DictionaryKeySafe`2._Dictionary">
            <summary>Исходный словарь</summary>
        </member>
        <member name="P:MathCore.DictionaryKeySafe`2.Count">
            <summary>Число элементов словаря</summary>
        </member>
        <member name="P:MathCore.DictionaryKeySafe`2.Keys">
            <summary>Ключи словаря</summary>
        </member>
        <member name="P:MathCore.DictionaryKeySafe`2.Values">
            <summary>Значения словаря</summary>
        </member>
        <member name="P:MathCore.DictionaryKeySafe`2.Item(`0)">
            <summary>Элемент словаря, либо default, если ключ отсутствует</summary>
            <param name="key">Ключ требуемого значения</param>
            <returns>Значение словаря по указанному ключу, либо default</returns>
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.#ctor">
            <summary>инициализация нового пустого безопасного словаря</summary>
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.#ctor(System.Int32)">
            <summary>инициализация нового пустого безопасного словаря</summary>
            <param name="Capacity">Базовая ёмкость</param>
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>инициализация нового пустого безопасного словаря</summary>
            <param name="Comparer">Объект сравнения ключей</param>
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>инициализация нового пустого безопасного словаря</summary>
            <param name="Dictionary">Исходный словарь</param>
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.DictionaryKeySafe`2.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.DiffEqs">
            <summary>Система дифференциальных уравнений</summary>
            <param name="t">Аргумент</param>
            <param name="X">Значения функции</param>
            <returns>Значения производных</returns>
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.DiffEqsComplex">
            <summary>Система комплексных дифференциальных уравнений</summary>
            <param name="t">Аргумент</param>
            <param name="Z">Комплексные значения функции</param>
            <returns>Комплексные значения производных</returns>
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.DiffEqsVector2D">
            <summary>Система двухмерных векторных дифференциальных уравнений</summary>
            <param name="t">Аргумент</param>
            <param name="V2">Двухмерные векторные значения функции</param>
            <returns>Двухмерные векторные значения производных</returns>
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.DiffEqsVector3D">
            <summary>Система Трёхмерных векторных дифференциальных уравнений</summary>
            <param name="t">Аргумент</param>
            <param name="V3">Трёхмерные векторные значения функции</param>
            <returns>Трёхмерные векторные значения производных</returns>
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.RungeKutta">
            <summary>Метод Рунге-Кутты</summary>
        </member>
        <member name="M:MathCore.DifferentialEquations.Numerical.RungeKutta.Step45(System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод Дорманда – Принса Метод Дорманда – Принса - https://ru.abcdef.wiki/wiki/Dormand%E2%80%93Prince_method</summary>
        </member>
        <member name="T:MathCore.DifferentialEquations.Numerical.RungeKuttaComplex">
            <summary>Метод Рунге-Кутты</summary>
        </member>
        <member name="T:MathCore.DisposableGroup`1">
            <summary>Группа объектов, поддерживающих интерфейс <see cref="T:System.IDisposable">освобождения ресурсов</see></summary>
            <typeparam name="T">Тип объектов, поддерживающих интерфейс <see cref="T:System.IDisposable"/></typeparam>
        </member>
        <member name="F:MathCore.DisposableGroup`1._Items">
            <summary>Массив содержащихся объектов интерфейса <see cref="T:System.IDisposable"/></summary>
        </member>
        <member name="P:MathCore.DisposableGroup`1.Count">
            <summary>Число элементов группы</summary>
        </member>
        <member name="P:MathCore.DisposableGroup`1.Items">
            <summary>Массив элементов группы</summary>
        </member>
        <member name="P:MathCore.DisposableGroup`1.MathCore#IIndexableRead{System#Int32,T}#Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.DisposableGroup`1.Item(System.Int32)">
            <summary>Элемент группы</summary>
            <param name="i">Номер элемента группы</param>
            <returns>Элемент группы с номером <paramref name="i"/></returns>
        </member>
        <member name="M:MathCore.DisposableGroup`1.#ctor(`0[])">
            <summary>Группа <typeparamref name="T"/> интерфейса <see cref="T:System.IDisposable"/></summary>
            <param name="item"><typeparamref name="T"/> интерфейса <see cref="T:System.IDisposable"/></param>
        </member>
        <member name="M:MathCore.DisposableGroup`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Группа <typeparamref name="T"/> интерфейса <see cref="T:System.IDisposable"/></summary>
            <param name="items">Перечисление <typeparamref name="T"/> интерфейса <see cref="T:System.IDisposable"/></param>
        </member>
        <member name="M:MathCore.DisposableGroup`1.Dispose">
            <inheritdoc />
        </member>
        <member name="F:MathCore.DisposableGroup`1._Disposed">
            <summary>Объект уничтожен</summary>
        </member>
        <member name="M:MathCore.DisposableGroup`1.Dispose(System.Boolean)">
            <summary>Освободить ресурсы группы</summary>
            <param name="disposing">Признак того, что требуется освобождение управляемых ресурсов</param>
        </member>
        <member name="M:MathCore.DisposableGroup`1.GetEnumerator">
            <summary>Получить перечислитель элементов группы</summary>
            <returns>Перечислитель элементов группы</returns>
        </member>
        <member name="M:MathCore.DisposableGroup`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathCore.Evaluations.AdditionEvaluation`1">
            <summary>Вычисление суммы двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.AdditionEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления суммы двух вычислений</summary>
        </member>
        <member name="M:MathCore.Evaluations.AdditionEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления суммы двух вычислений</summary>
            <param name="a">Вычисление первого слагаемого</param>
            <param name="b">Вычисление второго слагаемого</param>
        </member>
        <member name="T:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1">
            <summary>Вычисление бинарной операции между двумя вычислениями</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.A">
            <summary>Первый операнд вычисления</summary>
        </member>
        <member name="P:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.B">
            <summary>Второй операнд вычисления</summary>
        </member>
        <member name="P:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.Operation">
            <summary>Метод вычисления значения вычисления</summary>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.#ctor">
            <summary>Инициализация нового бинарного вычисления</summary>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.#ctor(System.Func{`0,`0,`0})">
            <summary>Инициализация нового бинарного вычисления</summary>
            <param name="Operation">Метод вычисления результата вычисления на основе результатов вычисления значений операндов</param>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.#ctor(System.Func{`0,`0,`0},MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового бинарного вычисления</summary>
            <param name="Operation">Метод вычисления результата вычисления на основе результатов вычисления значений операндов</param>
            <param name="A">Первый операнд вычисления</param>
            <param name="B">Второй операнд вычисления</param>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperationEvaluation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1">
            <summary>Вычисление функционального бинарного оператора между двумя вычислениями</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1.GetOperatorFunction(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression})">
            <summary>Метод получения функции, рассчитывающей значение оператора для двух известных значений вычислений</summary>
            <param name="OP">Функция, преобразующая два выражения в бинарный оператор, позволяющий рассчитать значение операции между двумя значениями операндов</param>
            <returns>Метод вычисления значения оператора на основе значений двух его операндов</returns>
        </member>
        <member name="F:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1._Operator">
            <summary>Функция объединения двух выражений в бинарный оператор расчёта значения</summary>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression})">
            <summary>Инициализация нового функционального бинарного оператора вычисления</summary>
            <param name="Operator">Функция, определяющая как объединить два выражения операндов в бинарный оператор</param>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression},MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового функционального бинарного оператора на основе функции генерации бинарного оператора и двух вычислений операндов</summary>
            <param name="Operator">Функция, определяющая как объединить два выражения операндов в бинарный оператор</param>
            <param name="a">Вычисление первого операнда</param>
            <param name="b">Вычисление второго операнда</param>
        </member>
        <member name="M:MathCore.Evaluations.BinaryFunctionOperatorEvaluation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.ConvertEvaluation`2">
            <summary>Вычисление преобразования типов</summary>
            <typeparam name="TInput">Тип входного значения</typeparam>
            <typeparam name="TOutput">Тип выходного значения</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.ConvertEvaluation`2.InputEvaluation">
            <summary>Вычисление входного значения</summary>
        </member>
        <member name="P:MathCore.Evaluations.ConvertEvaluation`2.Converter">
            <summary>Функция-преобразователь типов входного в выходное значение</summary>
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.#ctor">
            <summary>Инициализация нового вычисления преобразования типов</summary>
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.#ctor(System.Func{`0,`1})">
            <summary>Инициализация нового вычисления преобразования типов</summary>
            <param name="Converter">Метод преобразования входного значения в выходное</param>
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.#ctor(MathCore.Evaluations.Evaluation{`0},System.Func{`0,`1})">
            <summary>Инициализация нового вычисления преобразования типов</summary>
            <param name="InputEvaluation">Вычисление входного значения</param>
            <param name="Converter">Метод преобразования входного значения в выходное</param>
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.ConvertEvaluation`2.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.DivideEvaluation`1">
            <summary>Вычисление деления двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.DivideEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления деления</summary>
        </member>
        <member name="M:MathCore.Evaluations.DivideEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления деления</summary>
            <param name="a">Вычисление делимого</param>
            <param name="b">Вычисление делителя</param>
        </member>
        <member name="T:MathCore.Evaluations.Evaluation">
            <summary>Вычисление</summary>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation.GetExpression">
            <summary>Получить выражение вычисления</summary>
            <returns>Возвращает выражение, соответствующее данному вычислению</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation.op_Implicit(MathCore.Evaluations.Evaluation)~System.Linq.Expressions.Expression">
            <summary>Оператор неявного преобразования вычисления в выражение</summary>
            <param name="Evaluation">Преобразуемое вычисление</param>
        </member>
        <member name="T:MathCore.Evaluations.Evaluation`1">
            <summary>Вычисление с результатом типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип результата вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.GetValue">
            <summary>Получить значение</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.GetExpression">
            <summary>Получить выражение вычисления</summary>
            <returns>Выражение, определяющие вычисление</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Implicit(MathCore.Evaluations.Evaluation{`0})~`0">
            <summary>Оператор неявного преобразования вычисления в выражение</summary>
            <param name="Evaluation">Преобразуемое вычисление</param>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Addition(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Оператор сложения двух вычислений</summary>
            <param name="x">Первое слагаемое</param>
            <param name="y">Второе слагаемое</param>
            <returns>Вычисление суммы двух вычислений</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Subtraction(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Вычисление разности двух вычислений</summary>
            <param name="x">Уменьшаемое</param>
            <param name="y">Вычитаемое</param>
            <returns>Вычисление разности двух вычислений</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_UnaryNegation(MathCore.Evaluations.Evaluation{`0})">
            <summary>Оператор получения отрицательного значения на основе вычисления</summary>
            <param name="x">Вычисление значения оператора</param>
            <returns>Оператор получения отрицательного значения</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Multiply(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Вычисление произведения двух вычислений</summary>
            <param name="x">Первый сомножитель</param>
            <param name="y">Второй сомножитель</param>
            <returns>Вычисление произведения двух вычислений</returns>
        </member>
        <member name="M:MathCore.Evaluations.Evaluation`1.op_Division(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Вычисление частного двух вычислений</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Вычисление частного двух вычислений</returns>
        </member>
        <member name="T:MathCore.Evaluations.FieldValueEvaluation`2">
            <summary>Вычисление значения поля объекта</summary>
            <typeparam name="TObject">Тип объекта, поле которого надо получить</typeparam>
            <typeparam name="TValue">Тип значения поля</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.FieldValueEvaluation`2.#ctor(System.String)">
            <summary>Инициализация нового вычисления значения поля объекта</summary>
            <param name="PropertyName">Имя поля</param>
        </member>
        <member name="M:MathCore.Evaluations.FieldValueEvaluation`2.#ctor(MathCore.Evaluations.Evaluation{`0},System.String)">
            <summary>Инициализация нового вычисления поля объекта</summary>
            <param name="obj">Вычисление объекта, поле которого надо получить</param>
            <param name="FieldName">Имя поля объекта</param>
        </member>
        <member name="T:MathCore.Evaluations.FunctionEvaluation`1">
            <summary>Вычисление функции без переменных</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MathCore.Evaluations.FunctionEvaluation`1.Function">
            <summary>Вычисляемая функция</summary>
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления функции</summary>
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.#ctor(System.Func{`0})">
            <summary>Инициализация нового вычисления функции</summary>
            <param name="Function">Вычисляемая функция</param>
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.FunctionEvaluation`1.op_Implicit(System.Func{`0})~MathCore.Evaluations.FunctionEvaluation{`0}">
            <summary>Оператор неявного преобразования типа функции к типу вычисления функции</summary>
            <param name="Function">Оборачиваемая функция</param>
        </member>
        <member name="T:MathCore.Evaluations.MultiplyEvaluation`1">
            <summary>Вычисление произведения двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.MultiplyEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления произведения</summary>
        </member>
        <member name="M:MathCore.Evaluations.MultiplyEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления произведения</summary>
            <param name="a">Вычисление первого сомножителя</param>
            <param name="b">Вычисление второго сомножителя</param>
        </member>
        <member name="T:MathCore.Evaluations.NamedFunctionEvaluation`1">
            <summary>Именованное вычисление функции</summary>
            <typeparam name="T">Тип значения функции</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.NamedFunctionEvaluation`1.Name">
            <summary>Имя функции</summary>
        </member>
        <member name="M:MathCore.Evaluations.NamedFunctionEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления значения функции</summary>
        </member>
        <member name="M:MathCore.Evaluations.NamedFunctionEvaluation`1.#ctor(System.Func{`0})">
            <summary>Инициализация нового вычисления значения функции</summary>
            <param name="Function">Вычисляемая функция</param>
        </member>
        <member name="M:MathCore.Evaluations.NamedFunctionEvaluation`1.#ctor(System.Func{`0},System.String)">
            <summary>Инициализация нового вычисления значения функции</summary>
            <param name="Function">Вычисляемая функция</param>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.Evaluations.NamedFunctionEvaluation`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.NamedValueEvaluation`1">
            <summary>Именованное вычисление конкретного значения</summary>
            <typeparam name="T">Тип возвращаемого значения</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.NamedValueEvaluation`1.Name">
            <summary>Имя вычисления</summary>
        </member>
        <member name="P:MathCore.Evaluations.NamedValueEvaluation`1.IsParameter">
            <summary>Признак того, что данное вычисление является именованным параметром</summary>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.#ctor">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.#ctor(`0)">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.#ctor(`0,System.String)">
            <summary>Инициализация нового именованного вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
            <param name="name">Имя вычисления</param>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.GetExpression">
            <summary>Если вычисление является параметром, то возвращается выражение параметра, иначе возвращается вычисление значения</summary>
            <returns>Выражение, соответствующее данному вычислению</returns>
        </member>
        <member name="M:MathCore.Evaluations.NamedValueEvaluation`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.NegateOperatorEvaluation`1">
            <summary>Вычисление отрицания значения</summary>
            <typeparam name="T">Тип значения параметра</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.NegateOperatorEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления отрицания</summary>
        </member>
        <member name="M:MathCore.Evaluations.NegateOperatorEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления отрицания</summary>
            <param name="value">Вычисление значения операнда</param>
        </member>
        <member name="T:MathCore.Evaluations.PropertyValueEvaluation`2">
            <summary>Вычисление значения свойства объекта</summary>
            <typeparam name="TObject">Тип объекта, свойство которого надо получить</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.PropertyValueEvaluation`2.#ctor(System.String)">
            <summary>Инициализация нового вычисления значения свойства объекта</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="M:MathCore.Evaluations.PropertyValueEvaluation`2.#ctor(MathCore.Evaluations.Evaluation{`0},System.String)">
            <summary>Инициализация нового вычисления свойства объекта</summary>
            <param name="obj">Вычисление объекта, свойство которого надо получить</param>
            <param name="PropertyName">Имя свойства объекта</param>
        </member>
        <member name="T:MathCore.Evaluations.SubtractEvaluation`1">
            <summary>Вычисление разности двух вычислений</summary>
            <typeparam name="T">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.SubtractEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления разности</summary>
        </member>
        <member name="M:MathCore.Evaluations.SubtractEvaluation`1.#ctor(MathCore.Evaluations.Evaluation{`0},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового вычисления разности</summary>
            <param name="a">Вычисление первого сомножителя</param>
            <param name="b">Вычисление второго сомножителя</param>
        </member>
        <member name="T:MathCore.Evaluations.UnaryOperatorEvaluation`2">
            <summary>Вычисление операции с одним операндом</summary>
            <typeparam name="TObject">Тип значения операнда</typeparam>
            <typeparam name="TValue">Тип значения вычисления</typeparam>
        </member>
        <member name="M:MathCore.Evaluations.UnaryOperatorEvaluation`2.GetOperation(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>Метод, генерирующий функция преобразования значения операнда в значение вычисления</summary>
            <param name="OP">Функция преобразования выражения, вычисляющего значение операнда, в выражение, определяющее значение вычисления</param>
            <returns></returns>
        </member>
        <member name="F:MathCore.Evaluations.UnaryOperatorEvaluation`2._Operator">
            <summary>Функция преобразования выражения операнда в выражение вычисления над этим операндом</summary>
        </member>
        <member name="M:MathCore.Evaluations.UnaryOperatorEvaluation`2.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression})">
            <summary>Инициализация нового унарного вычисления</summary>
            <param name="Operator">Оператор преобразования выражения операнда в выражение вычисления</param>
        </member>
        <member name="M:MathCore.Evaluations.UnaryOperatorEvaluation`2.#ctor(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression},MathCore.Evaluations.Evaluation{`0})">
            <summary>Инициализация нового унарного вычисления</summary>
            <param name="Operator">Оператор преобразования выражения операнда в выражение вычисления</param>
            <param name="value">Вычисление операнда</param>
        </member>
        <member name="M:MathCore.Evaluations.UnaryOperatorEvaluation`2.GetExpression">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Evaluations.ValueEvaluation`1">
            <summary>Вычисление конкретного значения</summary>
            <typeparam name="T">Тип возвращаемого значения</typeparam>
        </member>
        <member name="P:MathCore.Evaluations.ValueEvaluation`1.Value">
            <summary>Возвращаемое значение</summary>
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.#ctor">
            <summary>Инициализация нового вычисления конкретного значения</summary>
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.#ctor(`0)">
            <summary>Инициализация нового вычисления конкретного значения</summary>
            <param name="value">Возвращаемое значение</param>
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.GetValue">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.GetExpression">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Evaluations.ValueEvaluation`1.op_Implicit(`0)~MathCore.Evaluations.ValueEvaluation{`0}">
            <summary>Оператор неявного преобразования типа значения в тип вычисления этого значения</summary>
            <param name="Value">Оборачиваемое значение</param>
        </member>
        <member name="T:MathCore.ExpandableList`1">
            <summary>Расширяемый список</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
        </member>
        <member name="P:MathCore.ExpandableList`1.BaseList">
            <summary>Базовый список, обеспечивающий хранение данных</summary>
        </member>
        <member name="M:MathCore.ExpandableList`1.#ctor">
            <summary>Инициализация нового расширяемого списка</summary>
        </member>
        <member name="M:MathCore.ExpandableList`1.#ctor(System.Int32)">
            <summary>Инициализация нового расширяемого списка</summary>
            <param name="Capacity">Ёмкость</param>
        </member>
        <member name="M:MathCore.ExpandableList`1.#ctor(System.Collections.Generic.List{`0})">
            <summary>Инициализация нового расширяемого списка</summary>
            <param name="BaseList">Базовый список</param>
        </member>
        <member name="M:MathCore.ExpandableList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Инициализация нового расширяемого списка</summary>
            <param name="items">Исходный набор элементов</param>
        </member>
        <member name="M:MathCore.ExpandableList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.TrimExcess">
            <summary>Удаляет <c>default(T)</c> элементы в конце списка и уменьшает <see cref="P:MathCore.ExpandableList`1.BaseList"/>.<see cref="P:System.Collections.Generic.List`1.Capacity"/> до числа используемых элементов</summary>
            <returns>Истина, если удаление пустого пространства в хвосте списка выполнено успешно</returns>
        </member>
        <member name="M:MathCore.ExpandableList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.ExpandableList`1.Count">
            <summary>Число элементов списка</summary>
        </member>
        <member name="P:MathCore.ExpandableList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ExpandableList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Expressions.Visitors.ExpressionToXml.VisitPrefixBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Оператор деления \fract требует иного порядка аргументов:
            \frac{arg1}{arg2} 
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Extensions.Expressions.ExpressionExtensions.Substitute(System.Linq.Expressions.LambdaExpression,System.Linq.Expressions.LambdaExpression)">
            <exception cref="T:System.FormatException">Количество аргументов подстановки не равно 1, или во входном выражении отсутствие подставляемый параметр</exception>
        </member>
        <member name="T:MathCore.Extensions.ProcessExtensions">
            <summary>Методы-расширения для процессов</summary>
        </member>
        <member name="M:MathCore.Extensions.ProcessExtensions.WaitAsync(System.Diagnostics.Process)">
            <summary>Ожидание завершения процесса</summary>
            <param name="process">Процесс, завершение которого требуется дождаться</param>
            <returns>Задача, результат которой является кодом завершения процесса</returns>
        </member>
        <member name="M:MathCore.Extensions.ProcessExtensions.GetMotherProcess(System.Diagnostics.Process)">
            <summary>Получить родительский процесс</summary>
            <param name="process">Дочерний процесс</param>
            <returns>Родительский процесс</returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.IsSogl(System.Char)">
            <summary>Проверяет, является ли символ согласным</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.IsGlas(System.Char)">
            <summary>Проверяет, является ли символ гласным</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.IsSpecSign(System.Char)">
            <summary>Проверяет, является ли символ специальным (в данном контексте - разделителем)</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.GetSymbType(System.Char)">
            <summary>Возвращает тип символа: согласный, гласный, разделитель, не определён</summary>
            <param name="c"></param><returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.IsSlogMore(MathCore.Extensions.String.WordWrap.SymbType[],System.Int32)">
            <summary>Определяет, можно ли сделать перенос в массиве "с" в промежутке от start до len</summary>
            <param name="c"></param><param name="Start"></param><returns></returns>
            <remarks>
            Как я понимаю используется вместе с предыдущей функцией, т.е. сперва с помощью GetSymbType получить 
            из слова массив SymbType и дальше с помощью данной функции проверить, можно ли в нем сделать перенос
            </remarks>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.SetHyph(System.String,System.Int32)">
            <summary>Фактически, она и проделывает всю работу</summary>
            <param name="pc">Входной массив символов</param>
            <param name="MaxSize">Максимальный размер</param>
            <returns>Строка с расставленными знаками переноса</returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.Red_GlasMore(System.String,System.Int32)">
            <summary>
            На вход функции подается указатель на строку и позиция символа, с которого начинается чтение. 
            Дальше функция проверяет, есть ли в данной строке гласная буква
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.Red_SlogMore(System.String,System.Int32)">
            <summary>
            Аналогично предыдущей функции, но для согласных
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.MayBeHyph(System.String,System.Int32)">
            <summary>
            На вход подается указатель на строку и позиция, с которого начинается чтение. 
            Функция проверяет, можно ли сделать в данной строке перенос
            </summary>
            <param name="p"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Extensions.String.WordWrap.SetHyphString(System.String)">
            <summary>На вход ей подается просто некая строка, дальше она ее обрабатывает и возвращает строку с переносами</summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:MathCore.ComplexArrayExtensions">
            <summary>Класс методов-расширений для массивов комплексных чисел</summary>
        </member>
        <member name="M:MathCore.ComplexArrayExtensions.Deconstruct(System.Collections.Generic.IReadOnlyList{MathCore.Complex},System.Double[]@,System.Double[]@)">
            <summary>Метод деконструкции значения массива, позволяющий получить массив действительных и мнимых частей</summary>
            <param name="ComplexArray">Массив комплексных чисел</param>
            <param name="Re">Массив действительных частей</param>
            <param name="Im">Массив мнимых частей</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:MathCore.ComplexArrayExtensions.ToReIm(System.Collections.Generic.IReadOnlyList{MathCore.Complex},System.Double[]@,System.Double[]@)">
            <summary>Метод расчёта массивов действительных и мнимых частей массива комплексных чисел</summary>
            <param name="ComplexArray">Массив комплексных чисел</param>
            <param name="Re">Массив действительных частей комплексных чисел исходного массива</param>
            <param name="Im">Массив мнимых частей комплексных чисел исходного массива</param>
            <exception cref="T:System.ArgumentNullException">Если ссылка на исходный массив комплексных чисел пуста</exception>
        </member>
        <member name="M:MathCore.ComplexArrayExtensions.ToReIm(System.Collections.Generic.IReadOnlyList{MathCore.Complex})">
            <summary>Метод расчёта массивов действительных и мнимых частей массива комплексных чисел</summary>
            <param name="ComplexArray">Массив комплексных чисел</param>
            <exception cref="T:System.ArgumentNullException">Если ссылка на исходный массив комплексных чисел пуста</exception>
        </member>
        <member name="M:MathCore.ComplexArrayExtensions.ToAbsArg(System.Collections.Generic.IReadOnlyList{MathCore.Complex},System.Double[]@,System.Double[]@)">
            <summary>Метод расчёта массивов модулей и аргументов массива комплексных чисел</summary>
            <param name="ComplexArray">Массив комплексных чисел</param>
            <param name="Abs">Массив модулей комплексных чисел исходного массива</param>
            <param name="Arg">Массив аргументов комплексных чисел исходного массива</param>
            <exception cref="T:System.ArgumentNullException">Если ссылка на исходный массив комплексных чисел пуста</exception>
        </member>
        <member name="M:MathCore.ComplexArrayExtensions.ToAbsArg(System.Collections.Generic.IReadOnlyList{MathCore.Complex})">
            <summary>Метод расчёта массивов модулей и аргументов массива комплексных чисел</summary>
            <param name="ComplexArray">Массив комплексных чисел</param>
            <exception cref="T:System.ArgumentNullException">Если ссылка на исходный массив комплексных чисел пуста</exception>
        </member>
        <member name="M:MathCore.ComplexArrayExtensions.ToAbsArgDeg(System.Collections.Generic.IReadOnlyList{MathCore.Complex},System.Double[]@,System.Double[]@)">
            <summary>Метод расчёта массивов модулей и аргументов (в градусах) массива комплексных чисел</summary>
            <param name="ComplexArray">Массив комплексных чисел</param>
            <param name="Abs">Массив модулей комплексных чисел исходного массива</param>
            <param name="Arg">Массив аргументов комплексных чисел исходного массива в градусах</param>
            <exception cref="T:System.ArgumentNullException">Если ссылка на исходный массив комплексных чисел пуста</exception>
        </member>
        <member name="M:MathCore.ComplexArrayExtensions.ToAbsArgDeg(System.Collections.Generic.IReadOnlyList{MathCore.Complex})">
            <summary>Метод расчёта массивов модулей и аргументов (в градусах) массива комплексных чисел</summary>
            <param name="ComplexArray">Массив комплексных чисел</param>
            <exception cref="T:System.ArgumentNullException">Если ссылка на исходный массив комплексных чисел пуста</exception>
        </member>
        <member name="T:MathCore.ComplexEnumerableExtensions">
            <summary>Класс методов-расширений для перечисления комплексных чисел</summary>
        </member>
        <member name="M:MathCore.ComplexEnumerableExtensions.ToRe(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Получить перечисление действительных частей комплексных чисел</summary>
            <param name="items">Перечисление комплексных чисел</param>
            <returns>Перечисление действительных частей комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexEnumerableExtensions.ToIm(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Получить перечисление мнимых частей комплексных чисел</summary>
            <param name="items">Перечисление комплексных чисел</param>
            <returns>Перечисление мнимых частей комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexEnumerableExtensions.ToAbs(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Получить перечисление модулей комплексных чисел</summary>
            <param name="items">Перечисление комплексных чисел</param>
            <returns>Перечисление модулей комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexEnumerableExtensions.ToArg(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Получить перечисление аргументов комплексных чисел</summary>
            <param name="items">Перечисление комплексных чисел</param>
            <returns>Перечисление аргументов комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexEnumerableExtensions.ToArgDeg(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Получить перечисление аргументов (в градусах) комплексных чисел</summary>
            <param name="items">Перечисление комплексных чисел</param>
            <returns>Перечисление аргументов (в градусах) комплексных чисел</returns>
        </member>
        <member name="M:MathCore.ComplexEnumerableExtensions.Sum(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Сумма комплексных чисел последовательности</summary>
            <param name="items">Перечисление комплексных чисел для сложения</param>
            <returns>Сумма всех комплексных чисел в последовательности</returns>
        </member>
        <member name="M:MathCore.ComplexEnumerableExtensions.Mul(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Произведение комплексных чисел последовательности</summary>
            <param name="items">Перечисление комплексных чисел для перемножения</param>
            <returns>Произведение всех комплексных чисел в последовательности</returns>
        </member>
        <member name="T:MathCore.IFactory`1">
            <summary>Фабрика объектов</summary>
            <typeparam name="T">Тип объектов, порождаемых фабрикой</typeparam>
        </member>
        <member name="M:MathCore.IFactory`1.Create">
            <summary>Создать новый объект</summary>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="T:MathCore.IFactory`2">
            <summary>Фабрика объектов</summary>
            <typeparam name="T">Тип объектов, порождаемых фабрикой</typeparam>
            <typeparam name="TParameter">Тип параметра процесса создания нового объекта</typeparam>
        </member>
        <member name="M:MathCore.IFactory`2.Create(`1)">
            <summary>Создать новый объект</summary>
            <param name="Parameter">Параметр процесса создания объекта</param>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="T:MathCore.Factory`1">
            <summary>Генератор объектов типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип генерируемых объектов</typeparam>
        </member>
        <member name="E:MathCore.Factory`1.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>Событие возникает при генерации новой строки</summary>
        </member>
        <member name="M:MathCore.Factory`1.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Генерация события уведомления об изменении значения свойства</summary>
            <param name="e">Аргумент события, указывающий имя изменившегося свойства</param>
        </member>
        <member name="F:MathCore.Factory`1._FactoryMethod">
            <summary>Метод генерации объектов</summary>
        </member>
        <member name="F:MathCore.Factory`1._RaiseLastChangedEvents">
            <summary>Генерировать события изменения свойств</summary>
        </member>
        <member name="P:MathCore.Factory`1.Last">
            <summary>Последний сгенерированный объект</summary>
        </member>
        <member name="P:MathCore.Factory`1.FactoryMethod">
            <summary>Метод генерации объектов типа <typeparamref name="T"/></summary>
        </member>
        <member name="M:MathCore.Factory`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Factory`1"/></summary>
        </member>
        <member name="M:MathCore.Factory`1.#ctor(System.Func{`0})">
            <summary>Новый генератор объектов типа <typeparamref name="T"/></summary>
            <param name="CreateMethod">Метод генерации объектов типа <typeparamref name="T"/></param>
        </member>
        <member name="M:MathCore.Factory`1.Create">
            <summary>Создать новый объект</summary>
            <returns>Новый объект типа <typeparamref name="T"/></returns>
        </member>
        <member name="M:MathCore.Factory`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Fraction">
            <summary>Дробь</summary>
        </member>
        <member name="M:MathCore.Fraction.GCD(System.Int32,System.Int32)">
            <summary>Наибольшее общее кратное двух чисел</summary>
        </member>
        <member name="M:MathCore.Fraction.GCD(System.Int64,System.Int64)">
            <summary>Наибольшее общее кратное двух чисел</summary>
        </member>
        <member name="M:MathCore.Fraction.GCD(System.UInt64,System.UInt64)">
            <summary>Наибольшее общее кратное двух чисел</summary>
        </member>
        <member name="M:MathCore.Fraction.GCD(MathCore.BigInt,MathCore.BigInt)">
            <summary>Наибольшее общее кратное двух чисел</summary>
        </member>
        <member name="M:MathCore.Fraction.GCD(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>Наибольшее общее кратное двух чисел</summary>
        </member>
        <member name="M:MathCore.Fraction.Simplify(System.Int32@,System.Int32@)">
            <summary>Упрощение дроби</summary>
            <param name="Numerator">Числитель</param>
            <param name="Denominator">Знаменатель</param>
            <returns>Истина, если дробь можно упростить</returns>
        </member>
        <member name="M:MathCore.Fraction.Simplify(System.Int64@,System.Int64@)">
            <summary>Упрощение дроби</summary>
            <param name="Numerator">Числитель</param>
            <param name="Denominator">Знаменатель</param>
            <returns>Истина, если дробь можно упростить</returns>
        </member>
        <member name="M:MathCore.Fraction.Simplify(System.UInt64@,System.UInt64@)">
            <summary>Упрощение дроби</summary>
            <param name="Numerator">Числитель</param>
            <param name="Denominator">Знаменатель</param>
            <returns>Истина, если дробь можно упростить</returns>
        </member>
        <member name="M:MathCore.Fraction.Simplify(MathCore.BigInt@,MathCore.BigInt@)">
            <summary>Упрощение дроби</summary>
            <param name="Numerator">Числитель</param>
            <param name="Denominator">Знаменатель</param>
            <returns>Истина, если дробь можно упростить</returns>
        </member>
        <member name="M:MathCore.Fraction.Simplify(System.Numerics.BigInteger@,System.Numerics.BigInteger@)">
            <summary>Упрощение дроби</summary>
            <param name="Numerator">Числитель</param>
            <param name="Denominator">Знаменатель</param>
            <returns>Истина, если дробь можно упростить</returns>
        </member>
        <member name="F:MathCore.Fraction._Numerator">
            <summary>Числитель</summary>
        </member>
        <member name="F:MathCore.Fraction._Denominator">
            <summary>Знаменатель</summary>
        </member>
        <member name="P:MathCore.Fraction.Numerator">
            <summary>Числитель</summary>
        </member>
        <member name="P:MathCore.Fraction.Denominator">
            <summary>Знаменатель</summary>
        </member>
        <member name="P:MathCore.Fraction.DecimalValue">
            <summary>Десятичное значение дроби</summary>
        </member>
        <member name="M:MathCore.Fraction.#ctor(System.Int64,System.UInt64)">
            <summary>Новая дробь</summary>
            <param name="Numerator">Числитель</param>
            <param name="Denominator">Знаменатель</param>
        </member>
        <member name="M:MathCore.Fraction.GetSimplified">
            <summary>Получить упрощённую дробь</summary>
            <returns>Упрощённая дробь</returns>
        </member>
        <member name="M:MathCore.Fraction.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Fraction.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Fraction.Equals(MathCore.Fraction)">
            <summary>Проверка на эквивалентность дроби</summary>
            <param name="other">Проверяемая дробь</param>
            <returns>Истина, если дроби идентичные</returns>
        </member>
        <member name="M:MathCore.Fraction.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Functions.FunctionsExtensions">
            <summary>Класс методов-расширений для функций</summary>
        </member>
        <member name="T:MathCore.Functions.FunctionsExtensions.FuncValue">
            <summary>Структура значения функции {Аргумент - значение}</summary>
        </member>
        <member name="F:MathCore.Functions.FunctionsExtensions.FuncValue.Argument">
            <summary>Аргумент функции</summary>
        </member>
        <member name="F:MathCore.Functions.FunctionsExtensions.FuncValue.Value">
            <summary>Значение функции</summary>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.FuncValue.#ctor(System.Double,System.Double)">
            <summary>Инициализация новой пары аргумент-значение функции</summary>
            <param name="arg">Аргумент функции</param>
            <param name="value">Значение функции</param>
        </member>
        <member name="T:MathCore.Functions.FunctionsExtensions.FuncMinMaxValue">
            <summary>Структура, содержащая максимальное и минимальное значение функции</summary>
        </member>
        <member name="F:MathCore.Functions.FunctionsExtensions.FuncMinMaxValue.Min">
            <summary>Минимальное значение функции</summary>
        </member>
        <member name="F:MathCore.Functions.FunctionsExtensions.FuncMinMaxValue.Max">
            <summary>Максимальное значение функции</summary>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.FuncMinMaxValue.#ctor(MathCore.Functions.FunctionsExtensions.FuncValue,MathCore.Functions.FunctionsExtensions.FuncValue)">
            <summary>Инициализация нового максимального и минимального значения функции</summary>
            <param name="min">Минимум функции</param>
            <param name="max">Максимум функции</param>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.GetValues(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Получить массив значений функции в указанном интервале с указанным шагом</summary>
            <param name="f">Функция, массив значений которой требуется получить</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг сетки дискретизации</param>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.GetMinMax(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить минимум и максимум на интервале</summary>
            <param name="f">Функция, минимум и максимум которой требуется определить</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг сетки разбиения</param>
            <returns>Структура, содержащая минимум и максимум функции</returns>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.GetMinValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить минимум функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг</param>
            <returns>Минимум функции</returns>
        </member>
        <member name="M:MathCore.Functions.FunctionsExtensions.GetMaxValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Определить максимум функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <param name="dx">Шаг</param>
            <returns>Максимум функции</returns>
        </member>
        <member name="M:MathCore.Functions.PSO.Swarm1D.Minimize(System.Func{System.Double,System.Double},MathCore.Interval,System.Int32,System.Double@,System.Double@)">
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="T:MathCore.Functions.PSO.Swarm2D">
            <summary>Рой двумерных частиц</summary>
        </member>
        <member name="F:MathCore.Functions.PSO.Swarm2D.w">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathCore.Functions.PSO.Swarm2D.c1">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="F:MathCore.Functions.PSO.Swarm2D.c2">
            <summary>Коэффициент глобального веса</summary>
        </member>
        <member name="T:MathCore.Functions.PSO.Swarm2D.Particle2D">
            <summary>Частица</summary>
        </member>
        <member name="F:MathCore.Functions.PSO.Swarm2D._ParticleCount">
            <summary>Размер роя</summary>
        </member>
        <member name="T:MathCore.GCWatcher">
            <summary>Наблюдатель за сборщиком мусора</summary>
        </member>
        <member name="E:MathCore.GCWatcher.ApproachesHandlers">
            <summary>Событие запуска процесса сборки мусора</summary>
        </member>
        <member name="E:MathCore.GCWatcher.Approaches">
            <summary>Событие запуска процесса сборки мусора</summary>
        </member>
        <member name="E:MathCore.GCWatcher.CompleteHandlers">
            <summary>Событие завершения процесса сборки мусора</summary>
        </member>
        <member name="E:MathCore.GCWatcher.Complete">
            <summary>Событие завершения процесса сборки мусора</summary>
        </member>
        <member name="M:MathCore.GCWatcher.OnApproaches">
            <summary>Генерация события начала сборки мусора</summary>
        </member>
        <member name="M:MathCore.GCWatcher.OnComplete">
            <summary>Генерация события окончания сборки мусора</summary>
        </member>
        <member name="F:MathCore.GCWatcher.__GcWatcher">
            <summary>Объект-наблюдатель за сборщиком мусора</summary>
        </member>
        <member name="F:MathCore.GCWatcher.__SyncRoot">
            <summary>Объект синхронизации потоков управления наблюдателем</summary>
        </member>
        <member name="F:MathCore.GCWatcher.__WatcherThread">
            <summary>Поток наблюдения с сборщиком мусора</summary>
        </member>
        <member name="F:MathCore.GCWatcher.__Enabled">
            <summary>Признак активности наблюдателя</summary>
        </member>
        <member name="M:MathCore.GCWatcher.#ctor">
            <summary>Скрытая инициализация объекта-наблюдателя</summary>
        </member>
        <member name="M:MathCore.GCWatcher.Start">
            <summary>Запуск процесса наблюдения</summary>
        </member>
        <member name="M:MathCore.GCWatcher.Stop">
            <summary>Остановка процесса наблюдения</summary>
        </member>
        <member name="M:MathCore.GCWatcher.Watch">
            <summary>Процесс наблюдения</summary>
        </member>
        <member name="T:MathCore.GeoLocation">
            <summary>Географическое положение</summary>
        </member>
        <member name="F:MathCore.GeoLocation.EarthRadius">
            <summary>Радиус Земли в метрах</summary>
        </member>
        <member name="P:MathCore.GeoLocation.Latitude">
            <summary>Широта в градусах</summary>
        </member>
        <member name="P:MathCore.GeoLocation.Longitude">
            <summary>Долгота в градусах</summary>
        </member>
        <member name="P:MathCore.GeoLocation.LatAngle">
            <summary>Градусы широты</summary>
        </member>
        <member name="P:MathCore.GeoLocation.LatMinutes">
            <summary>Минуты широты</summary>
        </member>
        <member name="P:MathCore.GeoLocation.LatSeconds">
            <summary>Секунды широты</summary>
        </member>
        <member name="P:MathCore.GeoLocation.LonAngle">
            <summary>Градусы долготы</summary>
        </member>
        <member name="P:MathCore.GeoLocation.LonMinutes">
            <summary>Минуты долготы</summary>
        </member>
        <member name="P:MathCore.GeoLocation.LonSeconds">
            <summary>Секунды долготы</summary>
        </member>
        <member name="M:MathCore.GeoLocation.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового географического положения</summary>
            <param name="Latitude">Широта в градусах</param>
            <param name="Longitude">Долгота в градусах</param>
        </member>
        <member name="M:MathCore.GeoLocation.#ctor(System.ValueTuple{System.Double,System.Double})">
            <summary>Инициализация нового географического положения из кортежа положения</summary>
            <param name="Point">Кортеж со значениями широты и долготы</param>
        </member>
        <member name="M:MathCore.GeoLocation.#ctor(MathCore.Vectors.Vector2D)">
            <summary>Инициализация нового географического положения из двумерного вектора</summary>
            <param name="Point">Вектор положения</param>
        </member>
        <member name="M:MathCore.GeoLocation.#ctor(System.Drawing.Point)">
            <summary>Инициализация нового географического положения из точки</summary>
            <param name="Point">Точка положения</param>
        </member>
        <member name="M:MathCore.GeoLocation.#ctor(System.Drawing.PointF)">
            <summary>Инициализация нового географического положения из точки</summary>
            <param name="Point">Точка положения</param>
        </member>
        <member name="M:MathCore.GeoLocation.Deconstruct(System.Double@,System.Double@)">
            <summary>Деконструктор географического положения на широту и долготу</summary>
            <param name="latitude">Широта</param>
            <param name="longitude">Долгота</param>
        </member>
        <member name="M:MathCore.GeoLocation.DistanceTo(MathCore.GeoLocation@)">
            <summary>Вычисление дистанции до другого географического положения в метрах</summary>
            <param name="Location">Вторая точка географического положения</param>
            <returns>Расстояние до указанной точки в метрах</returns>
        </member>
        <member name="M:MathCore.GeoLocation.HeadingTo(MathCore.GeoLocation)">
            <summary>Определение курса в направлении на указанную географическую точку (в градусах)</summary>
            <param name="Location">Точка назначения</param>
            <returns>Угол курса в градусах</returns>
        </member>
        <member name="M:MathCore.GeoLocation.Destination(System.Double,System.Double)">
            <summary>Определение точки места назначения по курсу в градусах и дистанции в метрах</summary>
            <param name="Heading">Угол курса в градусах</param>
            <param name="Distance">Дистанция в метрах</param>
            <returns>Новая точка места назначения на заданном удалении и с заданным курсом</returns>
        </member>
        <member name="M:MathCore.GeoLocation.op_Implicit(System.ValueTuple{System.Double,System.Double})~MathCore.GeoLocation">
            <summary>Оператор неявного приведения кортежа географических координат в структуру географического положения</summary>
            <param name="Point">Кортеж, содержащий широту и долготу</param>
        </member>
        <member name="M:MathCore.GeoLocation.op_Implicit(MathCore.GeoLocation)~System.ValueTuple{System.Double,System.Double}">
            <summary>Оператор неявного преобразования географического положения в кортеж, содержащий широту и долготу</summary>
            <param name="Location">Структура географического положения</param>
        </member>
        <member name="M:MathCore.GeoLocation.op_Implicit(MathCore.GeoLocation)~MathCore.Vectors.Vector2D">
            <summary>Оператор неявного преобразования из географического положения в двумерный вектор</summary>
            <param name="Location">Географическое положение</param>
        </member>
        <member name="M:MathCore.GeoLocation.op_Implicit(MathCore.Vectors.Vector2D)~MathCore.GeoLocation">
            <summary>Оператор неявного преобразования из двумерного вектора в географическое положение</summary>
            <param name="Point">Точка географического положения</param>
        </member>
        <member name="M:MathCore.GeoLocation.op_Implicit(MathCore.GeoLocation)~System.Drawing.Point">
            <summary>Оператор неявного преобразования из географического положения в точку</summary>
            <param name="Location">Географическое положение</param>
        </member>
        <member name="M:MathCore.GeoLocation.op_Implicit(System.Drawing.Point)~MathCore.GeoLocation">
            <summary>Оператор неявного преобразования из точки в географическое положение</summary>
            <param name="Point">Точка географического положения</param>
        </member>
        <member name="M:MathCore.GeoLocation.op_Implicit(MathCore.GeoLocation)~System.Drawing.PointF">
            <summary>Оператор неявного преобразования из географического положения в точку</summary>
            <param name="Location">Географическое положение</param>
        </member>
        <member name="M:MathCore.GeoLocation.op_Implicit(System.Drawing.PointF)~MathCore.GeoLocation">
            <summary>Оператор неявного преобразования из точки в географическое положение</summary>
            <param name="Point">Точка географического положения</param>
        </member>
        <member name="T:MathCore.Geolocation.GPS">
            <summary>Класс сервисных функций работы с координатами</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.ToRad">
            <summary>PI / 180</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.ToDeg">
            <summary>180 / PI</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.PI05">
            <summary>PI / 2</summary>
        </member>
        <member name="T:MathCore.Geolocation.GPS.Consts">
            <summary>Константы размеров</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.MeridianLength">
            <summary>Длина окружности меридиана (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.Meridian1DegreeLength">
            <summary>Длина дуги меридиана в 1 градус (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.Meridian1MinuteLength">
            <summary>Длина дуги меридиана в 1 минуту (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.Meridian1SecondLength">
            <summary>Длина дуги меридиана в 1 секунду (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.Meridian1RadianLength">
            <summary>Длина дуги меридиана в 1 радиан (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.ParallelEquatorLength">
            <summary>Длина окружности параллели на экваторе (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.ParallelEquator1DegreeLength">
            <summary>Длина дуги параллели на экваторе в 1 градус (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.ParallelEquator1MinuteLength">
            <summary>Длина дуги параллели на экваторе в 1 минуту (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.ParallelEquator1SecondLength">
            <summary>Длина дуги параллели на экваторе в 1 секунду (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.ParallelEquator1RadianLength">
            <summary>Длина дуги параллели на экваторе в 1 радиан (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.EarthRadius">
            <summary>Радиус Земли (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.LatitudeDegreeLength">
            <summary>Градус широты в метрах на экваторе (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.LatitudeMinuteLength">
            <summary>Минута широты в метрах на экваторе (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.LatitudeSecondLength">
            <summary>Секунда широты в метрах на экваторе (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.LongitudeDegreeLength">
            <summary>Градус долготы в метрах на экваторе (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.LongitudeMinuteLength">
            <summary>Минута долготы в метрах на экваторе (в метрах)</summary>
        </member>
        <member name="F:MathCore.Geolocation.GPS.Consts.LongitudeSecondLength">
            <summary>Секунда долготы в метрах на экваторе (в метрах)</summary>
        </member>
        <member name="M:MathCore.Geolocation.GPS.LengthBetween(System.Double,System.Double,System.Double,System.Double)">
            <summary>Вычисление расстояния между двумя точками на поверхности земли, заданными своими координатами</summary>
            <param name="latitude1">Широта первой точки в градусах</param>
            <param name="longitude1">Долгота первой точки в градусах</param>
            <param name="latitude2">Широта второй точки в градусах</param>
            <param name="longitude2">Долгота второй точки в градусах</param>
            <returns>Длина дуги на поверхности Земли, начинающейся в первой точке и заканчивающейся во второй точке</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.LengthBetween(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Вычисление расстояния между двумя точками на поверхности земли, заданными своими координатами</summary>
            <param name="begin">Начало</param>
            <param name="end">Конец</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.LengthBetween(MathCore.GeoLocation@,MathCore.GeoLocation@)">
            <summary>Вычисление расстояния между двумя точками на поверхности земли, заданными своими координатами</summary>
            <param name="begin">Начало</param>
            <param name="end">Конец</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.EquirectangularApproximation_LengthBetween(System.Double,System.Double,System.Double,System.Double)">
            <summary>Вычисление расстояния между двумя точками на поверхности земли (в равнопромежуточной проекции), заданными своими координатами</summary>
            <param name="latitude1">Широта первой точки в градусах</param>
            <param name="longitude1">Долгота первой точки в градусах</param>
            <param name="latitude2">Широта второй точки в градусах</param>
            <param name="longitude2">Долгота второй точки в градусах</param>
            <returns>Расстояние между двумя точками</returns>
            <remarks>Алгоритм требуем меньше вычислительных ресурсов, но даёт большую погрешность</remarks>
        </member>
        <member name="M:MathCore.Geolocation.GPS.Heading(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение курса по координатам начальной и конечной точки</summary>
            <param name="latitude1">Широта первой исходной точки</param>
            <param name="longitude1">Долгота первой исходной точки</param>
            <param name="latitude2">Широта второй исходной точки</param>
            <param name="longitude2">Долгота второй исходной точки</param>
            <returns>Курс в градусах</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.Heading(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Определение курса по координатам начальной и конечной точки</summary>
            <param name="begin">Исходная точка</param>
            <param name="end">Конечная точка</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.Heading(MathCore.GeoLocation@,MathCore.GeoLocation@)">
            <summary>Определение курса по координатам начальной и конечной точки</summary>
            <param name="begin">Исходная точка</param>
            <param name="end">Конечная точка</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.HalfWayPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки на середине отрезка, заданного двумя точками</summary>
            <param name="latitude1">Широта первой исходной точки</param>
            <param name="longitude1">Долгота первой исходной точки</param>
            <param name="latitude2">Широта второй исходной точки</param>
            <param name="longitude2">Долгота второй исходной точки</param>
            <returns>Точка в середине отрезка</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.HalfWayPoint(MathCore.Vectors.Vector2D@,MathCore.Vectors.Vector2D@)">
            <summary>Определение курса по координатам начальной и конечной точки</summary>
            <param name="begin">Исходная точка</param>
            <param name="end">Конечная точка</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.HalfWayPoint(MathCore.GeoLocation@,MathCore.GeoLocation@)">
            <summary>Определение курса по координатам начальной и конечной точки</summary>
            <param name="begin">Исходная точка</param>
            <param name="end">Конечная точка</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.DestinationPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="latitude">Широта исходной точки</param>
            <param name="longitude">Долгота исходной точки</param>
            <param name="heading">Курс на точку назначения</param>
            <param name="distance">Пройденная дистанция в метрах</param>
            <returns>Точка назначения</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.DestinationPoint(MathCore.Vectors.Vector2D@,System.Double,System.Double)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="point">Исходная точка</param>
            <param name="heading">Курс в градусах</param>
            <param name="distance">Расстояние в метрах</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.DestinationPoint(MathCore.GeoLocation@,System.Double,System.Double)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="point">Исходная точка</param>
            <param name="heading">Курс в градусах</param>
            <param name="distance">Расстояние в метрах</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.DestinationPoint(System.Double,System.Double,System.Double,System.Double,System.Double@)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="latitude">Широта исходной точки</param>
            <param name="longitude">Долгота исходной точки</param>
            <param name="heading">Курс на точку назначения</param>
            <param name="distance">Пройденная дистанция в метрах</param>
            <param name="final_heading">Курс из точки назначения на исходную точку</param>
            <returns>Точка назначения</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.DestinationPoint(MathCore.Vectors.Vector2D@,System.Double,System.Double,System.Double@)">
            <summary>Определение точки места назначения по исходной точке, курсу и расстоянию</summary>
            <param name="point">Исходная точка</param>
            <param name="heading">Курс в градусах</param>
            <param name="distance">Расстояние</param>
            <param name="final_heading">Курс в конечной точке</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.Intersection(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Определение точки пресечения двух курсов, каждый из которых задан исходной точкой</summary>
            <param name="latitude1">Широта первой исходной точки</param>
            <param name="longitude1">Долгота первой исходной точки</param>
            <param name="heading1">Курс из первой исходной точки</param>
            <param name="latitude2">Широта второй исходной точки</param>
            <param name="longitude2">Долгота второй исходной точки</param>
            <param name="heading2">Курс второй исходной точки</param>
            <returns>Точка пересечения двух курсов</returns>
        </member>
        <member name="M:MathCore.Geolocation.GPS.Intersection(MathCore.Vectors.Vector2D@,System.Double,MathCore.Vectors.Vector2D@,System.Double)">
            <summary>Определение точки пресечения двух курсов, каждый из которых задан исходной точкой</summary>
            <param name="point1">Первая точка</param>
            <param name="heading1">Курс в первой точке</param>
            <param name="point2">Вторая точка</param>
            <param name="heading2">Курс во второй точке</param>
        </member>
        <member name="M:MathCore.Geolocation.GPS.Intersection(MathCore.GeoLocation@,System.Double,MathCore.GeoLocation@,System.Double)">
            <summary>Определение точки пресечения двух курсов, каждый из которых задан исходной точкой</summary>
            <param name="point1">Первая точка</param>
            <param name="heading1">Курс в первой точке</param>
            <param name="point2">Вторая точка</param>
            <param name="heading2">Курс во второй точке</param>
        </member>
        <member name="T:MathCore.Graphs.GraphEx">
            <summary>Методы-расширения, позволяющие рассматривать любой объект как граф</summary>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.AsGraphNode``2(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,``0,``1},System.Boolean)">
            <summary>Преобразование к типу вершины графа</summary>
            <typeparam name="TValue">Тап значения вершины</typeparam>
            <typeparam name="TWeight">Тип веса связи</typeparam>
            <param name="value">Значение вершины</param>
            <param name="GetChilds">Метод выделения дочерних узлов</param>
            <param name="GetWeight">Метод определения веса связи между узлами</param>
            <param name="Buffered">Буферизация узлов и связей</param>
            <returns>Узел графа</returns>
            <example>
            <code>
            var M = new[,]
                   { /* 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14*/
            /*  0 */   {0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  1 */   {1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  2 */   {1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  3 */   {0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0},
            /*  4 */   {0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0},
            /*  5 */   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0},
            /*  6 */   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1},
            /*  7 */   {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  8 */   {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /*  9 */   {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 10 */   {0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 11 */   {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 12 */   {0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 13 */   {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
            /* 14 */   {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                   };
            var node = new { M, i = 0 };
            var root = node.AsGraphNode(r => Enumerable.Range(0, r.M.GetLength(1)).Select(i => new { M, i }),
                         (from, to) => from.M[to.i, from.i]);
            var tree = root.AsGraphNode(root => root.Links.Where(link => link.Weight == 1)
                                                          .Select(link => link.Node),
                                        (from, to) => to.Value.i - from.Value.i);
            var rout = tree.GetWaveRoute();
            
            </code>
            </example>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.AsGraphNode``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Boolean)">
            <summary>Преобразование к виду графа</summary>
            <typeparam name="TValue">Тип преобразуемого объекта</typeparam>
            <param name="value">Преобразуемый объект</param>
            <param name="GetChilds">Метод извлечения дочерних узлов из каждого узла графа</param>
            <param name="Buffered">Флаг необходимости проведения буферизации</param>
            <returns>Узел графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInDepth``2(MathCore.Graphs.IGraphNode{``0,``1})">
            <summary>Метод перебора вершин графа путём обхода "в глубину". Обход на основе стека дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <typeparam name="TWeight">Тип связи узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInDepth``1(MathCore.Graphs.IGraphNode{``0})">
            <summary>Метод перебора вершин графа путём обхода "в глубину". Обход на основе стека дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInWidth``2(MathCore.Graphs.IGraphNode{``0,``1})">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <typeparam name="TWeight">Тип связи узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInWidth``1(MathCore.Graphs.IGraphNode{``0},System.Boolean)">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <param name="TakeRoot">Перечислять корень дерева?</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.BypassInWidth``1(MathCore.Graphs.IGraphNode{``0},System.Func{MathCore.Graphs.IGraphNode{``0},System.Int32},System.Boolean)">
            <summary>Метод перебора вершин графа путём обхода "в ширину". Обход на основе очереди дочерних узлов с указанием функции хеширования.</summary>
            <typeparam name="TValue">Тип узлов графа</typeparam>
            <param name="Node">Начальный узел графа</param>
            <param name="hash">Функция хеширования элементов</param>
            <param name="TakeRoot">Перечислять корень дерева?</param>
            <returns>Последовательность узлов графа</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.FindRouteInDepth``2(MathCore.Graphs.IGraphNode{``0,``1},System.Predicate{``0})">
            <summary>Метод поиска пути в графе путём обхода вершин "в глубину"</summary>
            <typeparam name="TValue">Тип вершины графа</typeparam>
            <typeparam name="TWeight">Тип связи вершин графа</typeparam>
            <param name="RootNode">Начальный элемент поиска пути</param>
            <param name="FindPredicate">Метод определения окончания поиска, как успешного</param>
            <returns>Маршрут в графе</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphEx.GetWaveRoute``2(MathCore.Graphs.IGraphNode{``0,``1})">
            <summary>Метод поиска всех путей из указанной вершины до всех доступных вершин графа методом фронта волны</summary>
            <typeparam name="TValue">Тип вершины графа</typeparam>
            <typeparam name="TWeight">Тип связи вершин графа</typeparam>
            <param name="Root">Начальный элемент поиска пути</param>
            <returns>Массив найденных путей</returns>
        </member>
        <member name="M:MathCore.Graphs.GraphRoute`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.GraphRoute`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.GraphRoute`2.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Graphs.IGraphLink`2">
            <summary>Связь узла</summary>
            <typeparam name="TValue">Тип значения узла</typeparam>
            <typeparam name="TWeight">Тип нагрузки на связь</typeparam>
        </member>
        <member name="P:MathCore.Graphs.IGraphLink`2.Node">
            <summary>Связанный узел</summary>
        </member>
        <member name="P:MathCore.Graphs.IGraphLink`2.Weight">
            <summary>Нагрузка на связь</summary>
        </member>
        <member name="T:MathCore.Graphs.IGraphNode`2">
            <summary>Узел графа</summary>
            <typeparam name="TValue">Тип значения узла</typeparam>
            <typeparam name="TWeight">Тип нагрузки на связь</typeparam>
        </member>
        <member name="P:MathCore.Graphs.IGraphNode`2.Links">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathCore.Graphs.IGraphNode`2.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.Graphs.IGraphNode`1.Childs">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathCore.Graphs.IGraphNode`1.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.Graphs.LambdaGraphNode`2.Links">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Graphs.LambdaGraphNode`1.Childs">
            <summary>Связи узла</summary>
        </member>
        <member name="P:MathCore.Graphs.LambdaGraphNode`1.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.Equals(MathCore.Graphs.LambdaGraphNode{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.LambdaGraphNode`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.IndexOf(MathCore.Graphs.TreeListNode{`0})">
            <summary>
            Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            <returns>
            Индекс <paramref name="item"/> если он найден в списке; в противном случае его значение равно -1.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.IndexOf(`0)">
            <summary>Определяет индекс заданного элемента коллекции <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <returns>Индекс <paramref name="item"/> если он найден в списке; в противном случае его значение равно -1.</returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Insert(System.Int32,MathCore.Graphs.TreeListNode{`0})">
            <summary>Вставляет элемент в список <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля), по которому следует вставить параметр <paramref name="item"/>.</param><param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Insert(System.Int32,`0)">
            <summary>Вставляет элемент в список <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля), по которому следует вставить параметр <paramref name="item"/>.</param><param name="item">Объект, вставляемый в <see cref="T:System.Collections.Generic.IList`1"/>.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.RemoveAt(System.Int32)">
            <summary>Удаляет элемент <see cref="T:System.Collections.Generic.IList`1"/> по указанному индексу.</summary>
            <param name="index">Индекс (с нуля) удаляемого элемента.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#IList{TValue}#Item(System.Int32)">
            <summary>Получает или задает элемент по указанному индексу.</summary>
            <returns>Элемент с указанным индексом.</returns>
            <param name="index">Индекс (с нуля) элемента, который необходимо получить или задать.</param><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> не является допустимым индексом в <see cref="T:System.Collections.Generic.IList`1"/>.</exception><exception cref="T:System.NotSupportedException">Свойство задано, и объект <see cref="T:System.Collections.Generic.IList`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{TValue}#Add(`0)">
            <summary>Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Clear">
            <summary>Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Contains(`0)">
            <summary>Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.</summary>
            <returns>Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.</returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.CopyTo(`0[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="index">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="index"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="index"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="TValue"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Remove(`0)">
            <summary>Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{TValue}#Count">
            <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Contains(MathCore.Graphs.TreeListNode{`0})">
            <summary>Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.CopyTo(MathCore.Graphs.TreeListNode{`0}[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="index">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="index"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="index"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="index"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="T"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.Remove(MathCore.Graphs.TreeListNode{`0})">
            <summary>Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#ICollection{MathCore#Graphs#TreeListNode{TValue}}#Count">
            <summary>Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <returns>Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.</returns>
        </member>
        <member name="P:MathCore.Graphs.TreeListNode`1.IsReadOnly">
            <summary>Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.</summary>
            <returns>Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.</returns>
        </member>
        <member name="M:MathCore.Graphs.TreeListNode`1.System#Collections#Generic#IEnumerable{TValue}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.</returns>
        </member>
        <member name="T:MathCore.Hash.MD5">
            <summary>RFC for MD5</summary>
            <remarks>
            https://tools.ietf.org/html/rfc1321<br/>
            https://ru.wikipedia.org/wiki/MD5
            </remarks>
        </member>
        <member name="T:MathCore.HashBuilder">
            <summary>Построитель хеш-суммы</summary>
        </member>
        <member name="F:MathCore.HashBuilder._Hash">
            <summary>Текущая хеш-сумма</summary>
        </member>
        <member name="F:MathCore.HashBuilder._HashBase">
            <summary>Базовый множитель суммы</summary>
        </member>
        <member name="P:MathCore.HashBuilder.Hash">
            <summary>Текущая хеш-сумма</summary>
        </member>
        <member name="M:MathCore.HashBuilder.#ctor(System.Int32,System.Int32)">
            <summary>Инициализация нового построителя хеш-суммы</summary>
            <param name="Hash">Базовое значение хеш-суммы</param>
            <param name="HashBase">Множитель хеш-суммы</param>
        </member>
        <member name="M:MathCore.HashBuilder.HashBase(System.Int32)">
            <summary>Изменение множителя</summary>
            <param name="Base">Новое значение множителя хеш-суммы</param>
            <returns>Новый построитель хеш=суммы с изменённым значением множителя</returns>
        </member>
        <member name="M:MathCore.HashBuilder.Append(System.Int32)">
            <summary>Добавление компонента хеш-суммы</summary>
            <param name="hash">Добавляемое значение хеш-суммы</param>
            <returns>Новый построитель хеш-суммы с изменённым значением и тем же самым множителем</returns>
        </member>
        <member name="M:MathCore.HashBuilder.Append(System.Int32,System.Int32)">
            <summary>Добавление компонента хеш-суммы</summary>
            <param name="hash">Добавляемое значение хеш-суммы</param>
            <param name="Base">Новый множитель</param>
            <returns>Новый построитель хеш-суммы с изменённым значением и тем же самым множителем</returns>
        </member>
        <member name="M:MathCore.HashBuilder.Append(System.Object)">
            <summary>Добавление хеш-суммы объекта к сумме</summary>
            <param name="Obj">Добавляемый объект</param>
            <returns>Новый построитель хеш-суммы с изменённым значением и тем же самым множителем</returns>
        </member>
        <member name="M:MathCore.HashBuilder.Append``1(``0)">
            <summary>Добавление хеш-суммы объекта к сумме</summary>
            <param name="Obj">Добавляемый объект</param>
            <returns>Новый построитель хеш-суммы с изменённым значением и тем же самым множителем</returns>
        </member>
        <member name="T:MathCore.ICloneable`1">
            <summary>Объект поддерживает клонирование</summary>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:MathCore.ICloneable`1.Clone">
            <summary>Клонирование объекта</summary>
            <returns>Клонированный экземпляр объекта</returns>
        </member>
        <member name="T:MathCore.ICountable">
            <summary>Объект позволяет определять количество вложенных объектов</summary>
        </member>
        <member name="P:MathCore.ICountable.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="T:MathCore.IIndexableRead`2">
            <summary>Объект индексируемый только для чтения значений</summary>
            <typeparam name="TIndex">Тип индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexableRead`2.Item(`0)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="T:MathCore.IIndexableRead`3">
            <summary>Объект индексируемый только для чтения значений с двумя индексами</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="P:MathCore.IIndexableRead`3.Item(`0,`1)">
            <summary>Индексатор объекта только для чтения</summary>
            <param name="index1">Первый индекс</param>
            <param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathCore.IIndexableWrite`2">
            <summary>Объект индексируемый только для записи значений</summary>
            <typeparam name="TIndex">Тип индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexableWrite`2.Item(`0)">
            <summary>Индексатор объекта только для записи</summary><param name="index">Индекс</param>
        </member>
        <member name="T:MathCore.IIndexableWrite`3">
            <summary>Объект индексируемый только для записи значений с двумя индексами</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип значений</typeparam>
        </member>
        <member name="P:MathCore.IIndexableWrite`3.Item(`0,`1)">
            <summary>Индексатор объекта только для записи</summary>
            <param name="index1">Первый индекс</param><param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathCore.IIndexable`2">
            <summary>Объект индексируемый</summary>
            <typeparam name="TIndex">Тип индекса</typeparam><typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexable`2.Item(`0)">
            <summary>Индексатор объекта</summary><param name="index">Индекс</param>
        </member>
        <member name="T:MathCore.IIndexable`3">
            <summary>Объект индексируемый с двумя параметрами индекса</summary>
            <typeparam name="TIndex1">Тип первого индекса</typeparam>
            <typeparam name="TIndex2">Тип второго индекса</typeparam>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexable`3.Item(`0,`1)">
            <summary>Индексатор объекта</summary>
            <param name="index1">Первый индекс</param><param name="index2">Второй индекс</param>
        </member>
        <member name="T:MathCore.IIndexable`1">
            <summary>Объект индексируемый с целочисленным индексом</summary>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="T:MathCore.IIndexableRef`1">
            <summary>Объект, индексируемый целочисленным индексом по ссылке</summary>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexableRef`1.Item(System.Int32)">
            <summary>Ссылка на значение, доступное внутри объекта по индексу</summary>
            <param name="index">Индекс значения</param>
        </member>
        <member name="T:MathCore.IIndexableReadonlyRef`1">
            <summary>Объект, индексируемый целочисленным индексом по ссылке только для чтения</summary>
            <typeparam name="TValue">Тип элементов</typeparam>
        </member>
        <member name="P:MathCore.IIndexableReadonlyRef`1.Item(System.Int32)">
            <summary>Ссылка только для чтения на значение, доступное внутри объекта по индексу</summary>
            <param name="index">Индекс значения</param>
        </member>
        <member name="T:MathCore.INamedRead">
            <summary>Объект, обладающий именем</summary>
        </member>
        <member name="P:MathCore.INamedRead.Name">
            <summary>Имя объекта</summary>
        </member>
        <member name="T:MathCore.INamed">
            <summary>Объект с возможностью задавать имя</summary>
        </member>
        <member name="P:MathCore.INamed.Name">
            <summary>Имя объекта</summary>
        </member>
        <member name="T:MathCore.NamedInterfaceExtensions">
            <summary>Методы-расширения интерфейса именованных объектов</summary>
        </member>
        <member name="M:MathCore.NamedInterfaceExtensions.Rename(MathCore.INamed,System.String)">
            <summary>Изменить имя объекта</summary>
            <param name="obj">Объект, имя которого требуется изменить</param>
            <param name="NewName">Новое имя объекта</param>
        </member>
        <member name="T:MathCore.Interpolation.BezierCurve">
            <summary><see url="http://ru.wikipedia.org/wiki/Кривая_Безье">Кривая Безье</see></summary>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.BinomCoefficient(System.Int32,System.Int32)">
            <summary>
            Биномиальный коэффициент (1+x)^n из <paramref name="n"/> по <paramref name="k"/>
            <see url="http://ru.wikipedia.org/wiki/Биномиальный_коэффициент">Википедия:Биномиальный коэффициент</see>
            </summary>
            <param name="n">Степень <see url="http://ru.wikipedia.org/wiki/Бином_Ньютона">бинома Ньютона</see></param>
            <param name="k">Номер коэффициента</param>
            <returns>Коэффициент разложения Бинома Ньютона (1+x)^n</returns>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.GetBernshteynPolynom(System.Int32,System.Int32)">
            <summary>Получить <seealso url="http://ru.wikipedia.org/wiki/Многочлен_Бернштейна">Полином Бернштейна</seealso>></summary>
            <param name="k">Номер многочлена</param>
            <param name="n">Степень</param>
            <returns></returns>
        </member>
        <member name="F:MathCore.Interpolation.BezierCurve._Points">
            <summary>Набор точек аппроксимации</summary>
        </member>
        <member name="F:MathCore.Interpolation.BezierCurve._BernshteynPolynoms">
            <summary><see url="http://ru.wikipedia.org/wiki/Многочлен_Бернштейна">Полином Бернштейна</see>></summary>        
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Новая <see url="http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="X">Список координат точек x</param>
            <param name="Y">Список координат точек y</param>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Новая <see url="http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="Points">Набор точек в виде <see cref="T:MathCore.Complex">комплексных чисел</see></param>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.#ctor(System.Collections.Generic.IEnumerable{MathCore.Vectors.Vector2D})">
            <summary>Новая <see url="http://ru.wikipedia.org/wiki/Кривая_Безье">кривая Безье</see></summary>
            <param name="Points">Набор точек</param>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve.Initialize(System.Collections.Generic.IEnumerable{MathCore.Vectors.Vector2D})">
            <summary>Инициализировать кривую Безье</summary>
            <param name="Points">Набор точек</param>
        </member>
        <member name="M:MathCore.Interpolation.BezierCurve2.Bernstein(System.Int32,System.Int32,System.Double)">
            <summary>Calculate Bernstein basis</summary>
        </member>
        <member name="T:MathCore.Interpolation.CubicSpline">
            <summary>Интерполирование функций естественными кубическими сплайнами</summary>
            <remarks>Разработчик: Назар Андриенко Email: nuzikprogrammer@gmail.com</remarks>
        </member>
        <member name="T:MathCore.Interpolation.CubicSpline.SplineState">
            <summary>Структура, описывающая сплайн на каждом сегменте сетки</summary>
        </member>
        <member name="M:MathCore.Interpolation.CubicSpline.SplineState.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Структура, описывающая сплайн на каждом сегменте сетки</summary>
        </member>
        <member name="F:MathCore.Interpolation.CubicSpline._SplineStates">
            <summary>Сплайн</summary>
        </member>
        <member name="M:MathCore.Interpolation.CubicSpline.Initialize(System.Double[],System.Double[])">
            <summary>Инициализация сплайна</summary>
            <param name="X">Массив аргументов</param><param name="Y">Массив значений</param>
            <exception cref="T:System.ArgumentException">Возникает в случае, если размерности массивов не равны</exception>
        </member>
        <member name="T:MathCore.Interpolation.IInterpolator">
            <summary>Интерфейс интерполяции</summary>
        </member>
        <member name="M:MathCore.Interpolation.IInterpolator.Value(System.Double)">
            <summary>Получить значение</summary>
            <param name="x">Переменная</param>
            <returns>Значение</returns>
        </member>
        <member name="T:MathCore.Interpolation.Lagrange">
            <summary>Полином Лагранжа</summary>
        </member>
        <member name="M:MathCore.Interpolation.Lagrange.GetPolynomCoefficients(System.Double[],System.Double[])">
            <summary>Рассчитать коэффициенты полинома Лагранжа для заданного набора точек</summary>
            <param name="X">Массив значений на оси X</param>
            <param name="Y">Массив значений на оси Y</param>
            <returns>Массив коэффициентов полинома Лагранжа</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="X"/>, или <paramref name="Y"/></exception>
            <exception cref="T:System.InvalidOperationException">Если длина <paramref name="X"/> не равна <paramref name="Y"/></exception>
        </member>
        <member name="M:MathCore.Interpolation.Lagrange.GetPolynomCoefficients(System.Double,System.Double,System.Double[])">
            <summary>Рассчитать коэффициенты полинома Лагранжа для заданного набора точек</summary>
            <param name="x0">Начальное смещение аргумента</param>
            <param name="dx">Шаг сетки аргумента</param>
            <param name="Y">Массив значений на оси Y</param>
            <returns>Массив коэффициентов полинома</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="Y"/></exception>
        </member>
        <member name="M:MathCore.Interpolation.Lagrange.GetPolynomCoefficients(System.Double[],System.Double[],System.Double[])">
            <summary>Рассчитать коэффициенты полинома Лагранжа для заданного набора точек</summary>
            <param name="X">Массив значений на оси X</param>
            <param name="Y">Массив значений на оси Y</param>
            <param name="P">Массив, в который будут вычислены коэффициенты полинома</param>
            <returns>Массив коэффициентов полинома</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="X"/>, или <paramref name="Y"/></exception>
            <exception cref="T:System.InvalidOperationException">Если длина <paramref name="X"/> не равна <paramref name="Y"/></exception>
            <exception cref="T:System.ArgumentException">Если размер массива <paramref name="P"/> меньше размера массива <paramref name="X"/></exception>
        </member>
        <member name="M:MathCore.Interpolation.Lagrange.GetPolynomCoefficients(System.Double,System.Double,System.Double[],System.Double[])">
            <summary>Рассчитать коэффициенты полинома Лагранжа для заданного набора точек</summary>
            <param name="x0">Начальное смещение аргумента</param>
            <param name="dx">Шаг сетки аргумента</param>
            <param name="Y">Массив значений на оси Y</param>
            <param name="P">Массив, в который будут вычислены коэффициенты полинома</param>
            <returns>Массив коэффициентов полинома</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="Y"/></exception>
        </member>
        <member name="T:MathCore.Interpolation.Mapping">
            <summary>Линейный интерполятор вещественного значения</summary>
        </member>
        <member name="M:MathCore.Interpolation.Mapping.GetValue(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Линейная интерполяция</summary>
            <param name="x">Аргумент интерполируемого значения</param>
            <param name="x1">Аргумент первого значения</param>
            <param name="y1">Первое значение</param>
            <param name="x2">Аргумент второго значения</param>
            <param name="y2">Второе значение</param>
            <returns></returns>
        </member>
        <member name="T:MathCore.Interpolation.Newton">
            <summary>Полином Ньютона</summary>
        </member>
        <member name="M:MathCore.Interpolation.Newton.GetPolynomCoefficients(System.Double[],System.Double[])">
            <summary>Рассчитать коэффициенты полинома Ньютона для заданного набора точек</summary>
            <param name="X">Массив значений на оси X</param>
            <param name="Y">Массив значений на оси Y</param>
            <returns>Массив коэффициентов полинома</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="X"/>, или <paramref name="Y"/></exception>
            <exception cref="T:System.InvalidOperationException">Если длина <paramref name="X"/> не равна <paramref name="Y"/></exception>
        </member>
        <member name="M:MathCore.Interpolation.Newton.GetPolynomCoefficients(System.Double,System.Double,System.Double[])">
            <summary>Рассчитать коэффициенты полинома Ньютона для заданного набора точек</summary>
            <param name="x0">Начальное смещение аргумента</param>
            <param name="dx">Шаг сетки аргумента</param>
            <param name="Y">Массив значений на оси Y</param>
            <returns>Массив коэффициентов полинома</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="Y"/></exception>
        </member>
        <member name="M:MathCore.Interpolation.Newton.GetPolynomCoefficients(System.Double[],System.Double[],System.Double[])">
            <summary>Рассчитать коэффициенты полинома Ньютона для заданного набора точек</summary>
            <param name="X">Массив значений на оси X</param>
            <param name="Y">Массив значений на оси Y</param>
            <param name="P">Массив, в который будут вычислены коэффициенты полинома</param>
            <returns>Массив коэффициентов полинома</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="X"/>, или <paramref name="Y"/></exception>
            <exception cref="T:System.InvalidOperationException">Если длина <paramref name="X"/> не равна <paramref name="Y"/></exception>
            <exception cref="T:System.ArgumentException">Если размер массива <paramref name="P"/> меньше размера массива <paramref name="X"/></exception>
        </member>
        <member name="M:MathCore.Interpolation.Newton.GetPolynomCoefficients(System.Double,System.Double,System.Double[],System.Double[])">
            <summary>Рассчитать коэффициенты полинома Ньютона для заданного набора точек</summary>
            <param name="x0">Начальное смещение аргумента</param>
            <param name="dx">Шаг сетки аргумента</param>
            <param name="Y">Массив значений на оси Y</param>
            <param name="P">Массив, в который будут вычислены коэффициенты полинома</param>
            <returns>Массив коэффициентов полинома</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="Y"/></exception>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="P"/></exception>
        </member>
        <member name="M:MathCore.Interpolation.Newton.GetPolynom(System.Double[],System.Double[])">
            <summary>Сформировать полином Ньютона по массиву точек</summary>
            <param name="X">Массив значений на оси X</param>
            <param name="Y">Массив значений на оси Y</param>
            <returns>Полином Ньютона</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на массив <paramref name="X"/>, или <paramref name="Y"/></exception>
            <exception cref="T:System.InvalidOperationException">Если длина <paramref name="X"/> не равна <paramref name="Y"/></exception>
        </member>
        <member name="T:MathCore.MNK">
            <summary>Метод наименьших квадратов</summary>
        </member>
        <member name="F:MathCore.MNK._A">
            <summary>Коэффициенты аппроксимирующего полинома</summary>
        </member>
        <member name="F:MathCore.MNK._M">
            <summary>Максимальный показатель степени многочлена аппроксимации</summary>
        </member>
        <member name="F:MathCore.MNK._XData">
            <summary>Значение абсцисс точек данных</summary>
        </member>
        <member name="F:MathCore.MNK._YData">
            <summary>Значение ординат точек данных</summary>
        </member>
        <member name="M:MathCore.MNK.#ctor(System.Double[],System.Double[],System.Int32)">
            <summary>Аппроксиматор методом наименьших квадратов</summary>
            <param name="X">Массив аргументов</param>
            <param name="Y">Массив значений</param>
            <param name="m">Степень полинома интерполяции</param>
        </member>
        <member name="T:MathCore.Interval`1">
            <summary>Интервал сравнимых величин</summary>
            <typeparam name="T">Тип сравнимых величин</typeparam>
        </member>
        <member name="M:MathCore.Interval`1.Value(`0,`0,System.Boolean)">
            <summary>Определение нового интервала</summary>
            <param name="Min">Минимальное значение</param>
            <param name="Max">Максимальное значение</param>
            <param name="IncludeLimits">Границы интервала входят?</param>
            <returns>Новый интервал в указанных границах</returns>
        </member>
        <member name="F:MathCore.Interval`1._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.Interval`1._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.Interval`1._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.Interval`1._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval`1.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.Interval`1.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.Interval`1.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval`1.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="M:MathCore.Interval`1.#ctor(`0,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.Interval`1.#ctor(`0,`0,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы? (default:true)</param>
        </member>
        <member name="M:MathCore.Interval`1.#ctor(`0,System.Boolean,`0,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.Interval`1.Normalize(`0)">
            <summary>
            Метод возвращает указанное значение, если оно находится внутри интервала,
            либо соответствующую его границу, если значение входит за его пределы
            </summary>
            <param name="Value">Нормализуемое значение</param>
            <returns>
            Значение, переданное в качестве аргумента, если оно входит в интервал,
            иначе соответствующая граница интервала
            </returns>
        </member>
        <member name="M:MathCore.Interval`1.Normalize(`0@)">
            <summary>Замена значения ссылки на значение границы интервала, если значение не входит в интервал</summary>
            <param name="Value">Проверяемое значение</param>
        </member>
        <member name="M:MathCore.Interval`1.Check(`0)">
            <summary>Проверка на вхождение значения в интервал</summary>
            <param name="Value">Проверяемое значение</param>
            <returns>Истина, если значение входит в интервал</returns>
        </member>
        <member name="M:MathCore.Interval`1.IsInclude(MathCore.Interval{`0})">
            <summary>Проверка - входит ли указанный интервал в текущий</summary>
            <param name="I">Проверяемый интервал</param>
            <returns>Истина, если проверяемый интервал находится в границах текущего</returns>
        </member>
        <member name="M:MathCore.Interval`1.GetHashCode">
            <summary>Играет роль хэш-функции для определенного типа. </summary>
            <returns>Хэш-код для текущего объекта <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.Interval`1.Equals(MathCore.Interval{`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathCore.Interval`1.Equals(System.ValueTuple{`0,`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathCore.Interval`1.Equals(System.Object)">
            <summary>
            Определяет, равен ли заданный объект <see cref="T:System.Object"/> текущему объекту <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true, если указанный объект <see cref="T:System.Object"/> равен текущему объекту <see cref="T:System.Object"/>; в противном случае — false.
            </returns>
            <param name="obj">Объект <see cref="T:System.Object"/>, который требуется сравнить с текущим объектом <see cref="T:System.Object"/>.</param>
            <exception cref="T:System.NullReferenceException">Параметр <paramref name="obj"/> имеет значение null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.Interval`1.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval`1.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval`1.op_Implicit(MathCore.Interval{`0})~System.Predicate{`0}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathCore.Interval`1.op_ExclusiveOr(`0,MathCore.Interval{`0})">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="Value">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathCore.Interval`1.op_ExclusiveOr(MathCore.Interval{`0},`0)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="Value">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathCore.Interval">
            <summary>Интервал вещественных значений двойной точности</summary>
        </member>
        <member name="M:MathCore.Interval.Comparer_Length(MathCore.Interval,MathCore.Interval)">
            <summary>Метод сравнения двух интервалов</summary>
            <param name="a">Первый сравниваемый интервал</param>
            <param name="b">Второй сравниваемый интервал</param>
            <returns>1 - если первый интервал больше второго, -1 - если первый интервал меньше второго, 0 - если интервалы равны</returns>
        </member>
        <member name="F:MathCore.Interval._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.Interval._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.Interval._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.Interval._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.Interval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.Interval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.Interval.Length">
            <summary>Длина интервала</summary>
        </member>
        <member name="P:MathCore.Interval.Middle">
            <summary>Середина интервала</summary>
        </member>
        <member name="M:MathCore.Interval.#ctor(System.Double,System.Double)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.Interval.#ctor(System.Double,System.Double,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathCore.Interval.#ctor(System.Double,System.Boolean,System.Double,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.Interval.Normalize(System.Double)">
            <summary>
            Метод возвращает указанное значение, если оно находится внутри интервала,
            либо соответствующую его границу, если значение входит за его пределы
            </summary>
            <param name="Value">Нормализуемое значение</param>
            <returns>
            Значение, переданное в качестве аргумента, если оно входит в интервал,
            иначе соответствующая граница интервала
            </returns>
        </member>
        <member name="M:MathCore.Interval.Normalize(System.Double@)">
            <summary>Замена значения ссылки на значение границы интервала, если значение не входит в интервал</summary>
            <param name="Value">Проверяемое значение</param>
        </member>
        <member name="M:MathCore.Interval.Check(System.Double)">
            <summary>Проверка на вхождение значения в интервал</summary>
            <param name="Value">Проверяемое значение</param>
            <returns>Истина, если значение входит в интервал</returns>
        </member>
        <member name="M:MathCore.Interval.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval.ToString(System.String,System.IFormatProvider)">
            <summary>Форматирует значение текущего экземпляра с использованием заданного формата.</summary>
            <returns>Объект <see cref="T:System.String"/> содержит значение текущего экземпляра в заданном формате.</returns>
            <param name="Format">
            Объект <see cref="T:System.String"/>, задающий используемый формат.— или — 
            Значение null для использования формата по умолчанию, определенного для типа реализации 
            <see cref="T:System.IFormattable"/>. 
            </param>
            <param name="FormatProvider">
            Объект <see cref="T:System.IFormatProvider"/>, используемый для форматирования значения.— или — 
            Значение null для получения сведений о форматировании чисел на основе текущего значения параметра языкового 
            стандарта операционной системы. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.Interval.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval.Equals(MathCore.Interval)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval.Equals(System.ValueTuple{System.Double,System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval.Equals(System.ValueTuple{System.Int32,System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval.Equals(System.ValueTuple{System.Double,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Interval.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="F:MathCore.IO.LimitedStream._BaseStream">
            <summary>Поток-источник данных</summary>
        </member>
        <member name="F:MathCore.IO.LimitedStream._DataOffset">
            <summary>Смещение потока относительного исходного</summary>
        </member>
        <member name="F:MathCore.IO.LimitedStream._DataLength">
            <summary>Количество байт данных в потоке</summary>
        </member>
        <member name="F:MathCore.IO.LimitedStream._CanExpand">
            <summary>Возможность растягивать исходный поток</summary>
        </member>
        <member name="P:MathCore.IO.LimitedStream.BaseStream">
            <summary>Поток-источник данных</summary>
        </member>
        <member name="P:MathCore.IO.LimitedStream.DataOffset">
            <summary>Смещение потока относительного исходного</summary>
            <exception cref="T:System.ArgumentOutOfRangeException" accessor="set">Если передано значение меньше нуля.</exception>
        </member>
        <member name="P:MathCore.IO.LimitedStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:MathCore.IO.LimitedStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:MathCore.IO.LimitedStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:MathCore.IO.LimitedStream.CanExpand">
            <summary>Возможность растягивать исходный поток</summary>
        </member>
        <member name="P:MathCore.IO.LimitedStream.Length">
            <inheritdoc />
        </member>
        <member name="P:MathCore.IO.LimitedStream.Position">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.LimitedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.LimitedStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.LimitedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.LimitedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.LimitedStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.LimitedStream.ReadByte">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.LimitedStream.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.LimitedStream.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.IO.Win32Processes.GetLockingProcesses(System.String)">
            <summary>
            Find out what process(es) have a lock on the specified file.
            </summary>
            <param name="path">Path of the file.</param>
            <returns>Processes locking the file</returns>
            <remarks>See also:
            http://msdn.microsoft.com/en-us/library/windows/desktop/aa373661(v=vs.85).aspx
            http://wyupdate.googlecode.com/svn-history/r401/trunk/frmFilesInUse.cs (no copyright in code at time of viewing)
            </remarks>
        </member>
        <member name="T:MathCore.IoC.IServiceManager">
            <summary>Менеджер сервисов</summary>
        </member>
        <member name="P:MathCore.IoC.IServiceManager.Item(System.Type)">
            <summary>Сервис по требуемому типу</summary>
            <param name="ServiceType">Тип необходимого сервиса</param>
            <returns>Экземпляр затребованного сервиса</returns>
        </member>
        <member name="P:MathCore.IoC.IServiceManager.ServiceRegistrations">
            <summary>Информация о зарегистрированных сервисах</summary>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Get``1">
            <summary>Получить экземпляр сервиса</summary>
            <typeparam name="TServiceInterface">Тип сервиса</typeparam>
            <returns>Экземпляр сервиса</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Get``1(System.Object[])">
            <summary>Получить экземпляр сервиса</summary>
            <typeparam name="TServiceInterface">Тип сервиса</typeparam>
            <param name="parameters">Параметры создания экземпляра сервиса</param>
            <returns>Экземпляр сервиса</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Get(System.Type)">
            <summary>Получить экземпляр сервиса</summary>
            <param name="ServiceType">Тип сервиса</param>
            <returns>Экземпляр сервиса</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Get(System.Type,System.Object[])">
            <summary>Получить экземпляр сервиса</summary>
            <param name="ServiceType">Тип сервиса</param>
            <param name="parameters">Параметры создания экземпляра сервиса</param>
            <returns>Экземпляр сервиса</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Create``1(System.Object[])">
            <summary>Создать объект, возможно неизвестный менеджеру</summary>
            <typeparam name="TObject">Тип требуемого объекта</typeparam>
            <param name="parameters">Параметры объекта</param>
            <returns>Экземпляр объекта в случае его успешного создания</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Create(System.Type,System.Object[])">
            <summary>Создать объект, возможно неизвестный менеджеру</summary>
            <param name="ObjectType">Тип требуемого объекта</param>
            <param name="parameters">Параметры объекта</param>
            <returns>Экземпляр объекта в случае его успешного создания</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.ServiceAccessor``1">
            <summary>Объект доступа к экземплярам сервиса <typeparamref name="TService"/></summary>
            <typeparam name="TService">Тип требуемого сервиса</typeparam>
            <returns>Объект доступа к экземплярам сервиса <typeparamref name="TService"/></returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Run(System.Object,System.String)">
            <summary>Выполнить метод</summary>
            <param name="Instance">Экземпляр объекта</param>
            <param name="MethodName">Имя метода, который требуется выполнить</param>
            <returns>Результат выполнения</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Run``1(System.String)">
            <summary>Выполнить статический метод</summary>
            <typeparam name="T">Тип, в котором объявлен статический метод</typeparam>
            <param name="StaticMethodName">Имя статического метода, который требуется выполнить</param>
            <returns>Результат выполнения</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Register``1(MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode@)">
            <summary>Зарегистрировать тип сервиса</summary>
            <typeparam name="TServiceType">Регистрируемый тип реализации</typeparam>
            <param name="Mode">Режим регистрации</param>
            <returns>Регистрация тпа</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Register``2(MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode@)">
            <summary>Зарегистрировать интерфейс сервиса с указанием его реализации</summary>
            <typeparam name="TServiceInterface">Тип интерфейса сервиса</typeparam>
            <typeparam name="TService">Тип реализации сервиса</typeparam>
            <param name="Mode">Режим регистрации</param>
            <returns>Регистрация сервиса</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.RegisterType(System.Type,MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode)">
            <summary>Зарегистрировать тип сервиса</summary>
            <param name="ServiceType">Тип регистрируемого сервиса</param>
            <param name="Mode">Режим регистрации</param>
            <returns>Объект регистрации</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.RegisterType(System.Type,System.Type,MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode)">
            <summary>Зарегистрировать интерфейс сервиса</summary>
            <param name="InterfaceType">Тип интерфейса сервиса</param>
            <param name="ServiceType">Тип реализации интерфейса сервиса</param>
            <param name="Mode">Режим регистрации</param>
            <returns>Объект регистрации</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Unregister``1">
            <summary>Отменить регистрацию типа сервиса</summary>
            <typeparam name="TService">Тип реализации сервиса, регистрацию которого надо отменить</typeparam>
            <returns>Истина, если регистрация сервиса отменена успешно</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.Unregister(System.Type)">
            <summary>Отменить регистрацию типа сервиса</summary>
            <param name="ServiceType">Тип реализации сервиса, регистрацию которого надо отменить</param>
            <returns>Истина, если регистрация сервиса отменена успешно</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.ServiceRegistered``1">
            <summary>Зарегистрирован ли сервис</summary>
            <typeparam name="TService">Тип проверяемого сервиса</typeparam>
            <returns>Истина, если сервис зарегистрирован у менеджера</returns>
        </member>
        <member name="M:MathCore.IoC.IServiceManager.ServiceRegistered(System.Type)">
            <summary>Зарегистрирован ли сервис</summary>
            <param name="ServiceType">Тип проверяемого сервиса</param>
            <returns>Истина, если сервис зарегистрирован у менеджера</returns>
        </member>
        <member name="T:MathCore.IoC.IServiceManagerExtensions">
            <summary>Методы-расширения для менеджера сервисов</summary>
        </member>
        <member name="M:MathCore.IoC.IServiceManagerExtensions.GetRequired``1(MathCore.IoC.IServiceManager)">
            <summary>Получить сервис и сгенерировать исключение если сервис не зарегистрирован</summary>
            <typeparam name="T">Тип сервиса</typeparam>
            <param name="Manager">Менеджер сервисов</param>
            <returns>Запрошенный экземпляр сервиса</returns>
        </member>
        <member name="T:MathCore.IoC.IServiceRegistrations">
            <summary>Регистратор сервисов</summary>
        </member>
        <member name="P:MathCore.IoC.IServiceRegistrations.Item(System.Type)">
            <summary>Запрос регистрации сервиса по его типу</summary>
            <param name="ServiceType">Тип запрашиваемого сервиса</param>
        </member>
        <member name="T:MathCore.IoC.ServiceManager">
            <summary>Менеджер сервисов</summary>
        </member>
        <member name="M:MathCore.IoC.ServiceManager.Dispose">
            <inheritdoc />
        </member>
        <member name="T:MathCore.IoC.ServiceManagerAccessor`1">
            <summary>Объект доступа к экземплярам сервиса <typeparamref name="TService"/></summary>
            <typeparam name="TService">Тип сервиса</typeparam>
        </member>
        <member name="F:MathCore.IoC.ServiceManagerAccessor`1._ServiceManager">
            <summary>Экземпляр менеджера сервисов</summary>
        </member>
        <member name="P:MathCore.IoC.ServiceManagerAccessor`1.Service">
            <summary>Экземпляр сервиса <typeparamref name="TService"/></summary>
        </member>
        <member name="M:MathCore.IoC.ServiceManagerAccessor`1.#ctor(MathCore.IoC.ServiceManager)">
            <summary>Инициализация нового объекта доступа к экземплярам сервиса <typeparamref name="TService"/></summary>
            <param name="ServiceManager">Менеджер сервисов</param>
        </member>
        <member name="M:MathCore.IoC.ServiceRegistrations.ServiceRegistration.Dispose">
            <inheritdoc />
        </member>
        <member name="T:MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode">
            <summary>Режим регистрации сервиса</summary>
        </member>
        <member name="F:MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode.Singleton">
            <summary>Режим регистрации единого объекта для всех вызовов</summary>
        </member>
        <member name="F:MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode.SingleCall">
            <summary>Режим регистрации, при котором для каждого вызова будет создан новый экземпляр сервиса</summary>
        </member>
        <member name="F:MathCore.IoC.ServiceRegistrations.ServiceRegistrationMode.SingleThread">
            <summary>Режим регистрации, при котором для каждого потока будет создан единый экземпляр сервиса</summary>
        </member>
        <member name="M:MathCore.IoC.ServiceRegistrations.SingleThreadServiceRegistration`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.IoC.ServiceRegistrations.SingletonServiceRegistration`1">
            <summary>Регистрация сервиса в режиме единственного экземпляра</summary>
            <typeparam name="TService">Тип реализации сервиса</typeparam>
        </member>
        <member name="F:MathCore.IoC.ServiceRegistrations.SingletonServiceRegistration`1._Created">
            <summary>Признак того, что экземпляр сервиса был создан</summary>
        </member>
        <member name="F:MathCore.IoC.ServiceRegistrations.SingletonServiceRegistration`1._InstanceService">
            <summary>Регистрация сервиса выполнена на основе существующего экземпляра</summary>
        </member>
        <member name="M:MathCore.IoC.ServiceRegistrations.SingletonServiceRegistration`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.IProgressControl`1">
            <summary>Контроль над асинхронной операцией</summary>
            <typeparam name="T">Тип значения прогресса</typeparam>
        </member>
        <member name="P:MathCore.IProgressControl`1.Progress">
            <summary>Прогресс операции</summary>
        </member>
        <member name="P:MathCore.IProgressControl`1.Cancel">
            <summary>Флаг отмены операции</summary>
        </member>
        <member name="T:MathCore.IProgressControl">
            <summary>Контроль над асинхронной операцией</summary>
        </member>
        <member name="T:MathCore.ProgressControlEx">
            <summary>Методы-расширения над контролем асинхронной операцией</summary>
        </member>
        <member name="M:MathCore.ProgressControlEx.Report``1(MathCore.IProgressControl{``0},``0)">
            <summary>Извещение о ходе прогресса выполнения асинхронной операции</summary>
            <typeparam name="T">Тип значения прогресса</typeparam>
            <param name="Control">Объект контроля асинхронной операции</param>
            <param name="Value">Значение прогресса</param>
        </member>
        <member name="M:MathCore.ProgressControlEx.ThrowIfCancellationRequested``1(MathCore.IProgressControl{``0})">
            <summary>Проверка прерывания асинхронной операции</summary>
            <typeparam name="T">Тип значения прогресса</typeparam>
            <param name="Control">Объект контроля асинхронной операции</param>
            <exception cref="T:System.OperationCanceledException">Возникает если было затребовано прерывание операции</exception>
        </member>
        <member name="M:MathCore.ProgressControlEx.GetControl``1(System.IProgress{``0},System.Threading.CancellationToken)">
            <summary>Сформировать объект контроля асинхронной операции</summary>
            <typeparam name="T">Тип значения прогресса</typeparam>
            <param name="Progress">Прогресс операции</param>
            <param name="Cancel">Флаг отмены операции</param>
            <returns>Возвращает объект, упаковывающий внутри себя систему извещения о прогрессе и отмене операции</returns>
        </member>
        <member name="M:MathCore.ProgressControlEx.GetControl(System.IProgress{System.Double},System.Threading.CancellationToken)">
            <summary>Сформировать объект контроля асинхронной операции</summary>
            <param name="Progress">Прогресс операции</param>
            <param name="Cancel">Флаг отмены операции</param>
            <returns>Возвращает объект, упаковывающий внутри себя систему извещения о прогрессе и отмене операции</returns>
        </member>
        <member name="T:MathCore.ProgressControl`1">
            <summary>Реализация интерфейса контроля за асинхронной операцией</summary>
            <typeparam name="T">Тип значения прогресса</typeparam>
        </member>
        <member name="T:MathCore.ProgressControl">
            <summary>Реализация интерфейса контроля за асинхронной операцией</summary>
        </member>
        <member name="T:MathCore.JSON.JSONObject">
            <summary>Парсер структуры JSON</summary>
        </member>
        <member name="F:MathCore.JSON.JSONObject._Name">
            <summary>Имя структуры</summary>
        </member>
        <member name="F:MathCore.JSON.JSONObject._Data">
            <summary>Значение структуры</summary>
        </member>
        <member name="F:MathCore.JSON.JSONObject._Fields">
            <summary>Словарь полей структуры по ключу-имени поля</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.Name">
            <summary>Имя структуры</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.Data">
            <summary>Значение структуры</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.IsComplex">
            <summary>Признак того, что структура является сложной - со вложенными полями</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.Fields">
            <summary>Перечисление имён полей структуры</summary>
        </member>
        <member name="P:MathCore.JSON.JSONObject.Item(System.String)">
            <summary>Перечисление полей структуры по указанному имени</summary>
            <param name="Field">Имя поля структуры</param>
            <returns>Вложенные поля с указанным именем</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.#ctor(System.String)">
            <summary>Инициализация новой структуры JSON из строкового представления</summary>
            <param name="str">Строковое представление структуры JSON</param>
        </member>
        <member name="M:MathCore.JSON.JSONObject.#ctor(System.String,System.String)">
            <summary>Инициализация новой структуры JSON из строкового представления с указанием имени</summary>
            <param name="Name">Имя структуры</param>
            <param name="str">Строковое представление структуры JSON</param>
        </member>
        <member name="M:MathCore.JSON.JSONObject.ToInt(System.Nullable{System.Int32})">
            <summary>Преобразование значения структуры к целому числу</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Целочисленное значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.ToDouble(System.Nullable{System.Double})">
            <summary>Преобразование значения структуры к вещественному числу</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Вещественное значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.ToBool(System.Nullable{System.Boolean})">
            <summary>Преобразование значения структуры к логическому значению</summary>
            <param name="Default">Значение по умолчанию</param>
            <returns>Логическое значение структуры, либо значение по умолчанию, если преобразование невозможно</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.ToString">
            <summary>Строковое представление структуры</summary>
            <returns>Строковое представление структуры</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObject.op_Implicit(MathCore.JSON.JSONObject)~System.String">
            <summary>Оператор неявного приведения структуры JSON к строковому значению</summary>
            <param name="json">Структура JSON</param>
        </member>
        <member name="M:MathCore.JSON.JSONObject.GetText(System.String,System.Int32@,System.String,System.String)">
            <summary>
            Выделение подстроки, ограниченной шаблоном начала и шаблоном окончания строки начиная с указанного смещения
            </summary>
            <param name="Str">Входная строка</param>
            <param name="Offset">
            Смещение во входной строке начала поиска - в конце работы метода соответствует месту окончания поиска
            </param>
            <param name="Open">Шаблон начала подстроки</param>
            <param name="Close">Шаблон окончания подстроки</param>
            <returns>Подстрока, заключённая между указанными шаблонами начала и окончания</returns>
            <exception cref="T:System.FormatException">
            Если шаблон завершения строки не найден, либо если количество шаблонов начала строки превышает 
            количество шаблонов окончания во входной строке
            </exception>
        </member>
        <member name="T:MathCore.JSON.JSONObjectCreator`1">
            <summary>Генератор JSON-объекта по объекту-прототипу</summary>
            <typeparam name="T">Тип объекта-прототипа</typeparam>
        </member>
        <member name="F:MathCore.JSON.JSONObjectCreator`1._Obj">
            <summary>Объект-прототип</summary>
        </member>
        <member name="F:MathCore.JSON.JSONObjectCreator`1._FieldsDescriptions">
            <summary>Список именованных методов получения JSON-объектов - полей из объекта-прототипа</summary>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.#ctor(`0)">
            <summary>Инициализация нового генератора JSON-объектов</summary>
            <param name="obj"></param>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.AddField(System.String,System.Func{`0,System.Object})">
            <summary>Добавить новый метод определения поля JSON-объекта из объекта-прототипа</summary>
            <param name="Name">Имя поля</param>
            <param name="Field">Метод получения JSON-объекта поля</param>
            <returns>Генератор JSON-объектов с добавленным методом</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.Create">
            <summary>Создать JSON-объект из исходного объекта-прототипа</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.Create(System.Object)">
            <summary>Создать JSON-объект из указанного объекта-прототипа</summary>
            <param name="obj">Объект-прототип</param>
            <returns>JSON-объект</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.Create(`0)">
            <summary>Создать JSON-объект из указанного объекта-прототипа</summary>
            <param name="obj">Объект-прототип</param>
            <returns>JSON-объект</returns>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreator`1.op_Implicit(MathCore.JSON.JSONObjectCreator{`0})~MathCore.JSON.JSONObject">
            <summary>Оператор неявного приведения типа объекта-генератора к типу JSON-объекта</summary>
            <param name="creator">Объект-генератор</param>
        </member>
        <member name="T:MathCore.JSON.JSONObjectCreatorBase">
            <summary>Базовый класс генераторов JSON объектов</summary>
        </member>
        <member name="M:MathCore.JSON.JSONObjectCreatorBase.Create(System.Object)">
            <summary>Создать объект JSON</summary>
            <param name="obj">Объект-прототип, на основе которого генерируется JSON-объекта</param>
            <returns>Объект JSON</returns>
        </member>
        <member name="T:MathCore.LambdaComparer`1">
            <summary>Объект, представляющий метод сравнения двух объектов типа <typeparamref name="T"/>, задаваемый lambda-выражением</summary>
            <typeparam name="T">Тип сравниваемых объектов</typeparam>
        </member>
        <member name="M:MathCore.LambdaComparer`1.Compare(`0,`0)">
            <summary>Сравнивает два объекта и возвращает значение, показывающее, что один объект меньше или больше другого или равен ему</summary>
            <param name="x">Первый сравниваемый объект.</param>
            <param name="y">Второй сравниваемый объект.</param>
            <returns>
            Значение Условие Меньше нуля<paramref name="x"/> меньше, чем <paramref name="y"/>.Нуль<paramref name="x"/> равно <paramref name="y"/>.Больше нуля<paramref name="x"/> больше, чем <paramref name="y"/>.
            </returns>
        </member>
        <member name="M:MathCore.LambdaComparer`1.System#Collections#IComparer#Compare(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.Keys">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.Values">
            <inheritdoc />
        </member>
        <member name="P:MathCore.LambdaDictionary`2.Item(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Add(`0,`1)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.ContainsKey(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.TryGetValue(`0,`1@)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.LambdaEnumerable`1">
            <summary>Настраиваемое перечисление</summary>
            <typeparam name="T">Тип элемента перечисления</typeparam>
        </member>
        <member name="M:MathCore.LambdaEnumerable`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaEqualityComparer`1.Equals(`0,`0)">
            <summary>Определяет, равны ли два указанных объекта.</summary>
            <returns>Значение true, если указанные объекты равны; в противном случае — значение false.</returns>
            <param name="x">Первый сравниваемый объект типа <typeparamref name="T"/>.</param>
            <param name="y">Второй сравниваемый объект типа <typeparamref name="T"/>.</param>
        </member>
        <member name="M:MathCore.LambdaEqualityComparer`1.GetHashCode(`0)">
            <summary>Возвращает хэш-код указанного объекта.</summary>
            <returns>Хэш-код указанного объекта.</returns>
            <param name="obj">Объект <see cref="T:System.Object"/>, для которого должен быть возвращен хэш-код.</param>
            <exception cref="T:System.ArgumentNullException">Тип <paramref name="obj"/> является ссылочным типом, значением <paramref name="obj"/> является null.</exception>
        </member>
        <member name="M:MathCore.LambdaFormatter`1.GetFormat(System.Type)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaFormatter`1.Format(System.String,System.Object,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.LambdaKeyedCollection`2">
            <summary>Коллекция, ключи которой определяются указанным методом на основе значений элементов</summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения элемента</typeparam>
        </member>
        <member name="F:MathCore.LambdaKeyedCollection`2._KeyExtractor">
            <summary>Метод определения ключа элемента</summary>
        </member>
        <member name="M:MathCore.LambdaKeyedCollection`2.#ctor(System.Func{`1,`0})">
            <summary>Инициализация новой коллекции, ключи которой определяются на основе значений элементов</summary>
            <param name="KeyExtractor">Метод определения ключа элемента</param>
        </member>
        <member name="M:MathCore.LambdaKeyedCollection`2.#ctor(System.Func{`1,`0},System.Collections.Generic.IEnumerable{`1})">
            <summary>Инициализация новой коллекции, ключи которой определяются на основе значений элементов</summary>
            <param name="KeyExtractor">Метод определения ключа элемента</param>
            <param name="Values">Коллекция элементов</param>
        </member>
        <member name="M:MathCore.LambdaKeyedCollection`2.GetKeyForItem(`1)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.LambdaProperty`1">
            <summary>Класс объектов-свойств, определяемых методами установки и чтения значения</summary>
        </member>
        <member name="F:MathCore.LambdaProperty`1._GetMethod">
            <summary>Метод получения значения свойства</summary>
        </member>
        <member name="F:MathCore.LambdaProperty`1._SetMethod">
            <summary>Метод установки значения свойства</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.GetMethod">
            <summary>Метод получения значения свойства</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.SetMethod">
            <summary>Метод установки значения свойства</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.CanRead">
            <summary>Признак возможности чтения значения свойства (если задан метод чтения)</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.CanWrite">
            <summary>Признак возможности устанавливать значение свойства (если задан метод записи)</summary>
        </member>
        <member name="P:MathCore.LambdaProperty`1.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="M:MathCore.LambdaProperty`1.#ctor(System.Func{`0},System.Action{`0})">
            <summary>Новое лямбда свойство</summary>
            <param name="GetMethod">Метод чтения значения</param>
            <param name="SetMethod">Метод записи значения</param>
        </member>
        <member name="M:MathCore.LambdaProperty`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaProperty`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaProperty`1.Equals(MathCore.LambdaProperty{`0})">
            <summary>Указывает, равен ли текущий объект другому объекту того же типа.</summary>
            <returns>true, если текущий объект равен параметру <paramref name="other"/>, в противном случае — false.</returns>
            <param name="other">Объект, который требуется сравнить с данным объектом.</param>
        </member>
        <member name="M:MathCore.LambdaProperty`1.GetHashCode">
            <summary>Играет роль хэш-функции для определенного типа. </summary>
            <returns>Хэш-код для текущего объекта <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathCore.LambdaToString">
            <summary>Форматтер строки с помощью лямбда-выражения</summary>
        </member>
        <member name="M:MathCore.LambdaToString.#ctor(System.Func{System.String})">
            <summary>Новый лямбда-форматтер</summary>
            <param name="CreateMethod">Метод генерации строки</param>
        </member>
        <member name="M:MathCore.LambdaToString.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.LambdaToStringObjectIndicator`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MathEx">
            <summary>Расширенный класс математических функций</summary>
        </member>
        <member name="M:MathCore.MathEx.Sec(System.Double)">
            <summary>Секанс</summary>
        </member>
        <member name="M:MathCore.MathEx.Sec(MathCore.Complex)">
            <summary>Секанс</summary>
        </member>
        <member name="M:MathCore.MathEx.Cosec(System.Double)">
            <summary>Косеканс</summary>
        </member>
        <member name="M:MathCore.MathEx.Cosec(MathCore.Complex)">
            <summary>Косеканс</summary>
        </member>
        <member name="M:MathCore.MathEx.Tg(System.Double)">
            <summary>Тангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Tg(MathCore.Complex)">
            <summary>Тангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Ctg(System.Double)">
            <summary>Котангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Ctg(MathCore.Complex)">
            <summary>Котангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Actg(System.Double)">
            <summary>Арккотангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Actg(MathCore.Complex)">
            <summary>Арккотангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Asin(System.Double)">
            <summary>Арксинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Asin(MathCore.Complex)">
            <summary>Арксинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Acos(System.Double)">
            <summary>Арккосинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Acos(MathCore.Complex)">
            <summary>Арккосинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Asec(System.Double)">
            <summary>Арксеканс</summary>
        </member>
        <member name="M:MathCore.MathEx.Acosec(System.Double)">
            <summary>Арккосеканс</summary>
        </member>
        <member name="T:MathCore.MathEx.Hyperbolic">
            <summary>Гиперболические функции</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Sinh(System.Double)">
            <summary>Гиперболический синус</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Sinh(MathCore.Complex)">
            <summary>Гиперболический синус</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Cosh(System.Double)">
            <summary>Гиперболический косинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Cosh(MathCore.Complex)">
            <summary>Гиперболический косинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Tgh(System.Double)">
            <summary>Гиперболический тангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Tgh(MathCore.Complex)">
            <summary>Гиперболический тангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Ctgh(System.Double)">
            <summary>Гиперболический котангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Ctgh(MathCore.Complex)">
            <summary>Гиперболический котангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Sech(System.Double)">
            <summary>Гиперболический секанс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Sech(MathCore.Complex)">
            <summary>Гиперболический секанс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Cosech(System.Double)">
            <summary>Гиперболический косеканс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Cosech(MathCore.Complex)">
            <summary>Гиперболический косеканс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Asinh(System.Double)">
            <summary>Гиперболический арксинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Asinh(MathCore.Complex)">
            <summary>Гиперболический арксинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Acosh(System.Double)">
            <summary>Гиперболический арккосинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Acosh(MathCore.Complex)">
            <summary>Гиперболический арккосинус</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Atanh(System.Double)">
            <summary>Гиперболический арктангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Atanh(MathCore.Complex)">
            <summary>Гиперболический арктангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Acotanh(System.Double)">
            <summary>Гиперболический арккотангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Acotanh(MathCore.Complex)">
            <summary>Гиперболический арккотангенс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Asech(System.Double)">
            <summary>Гиперболический арксеканс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Asech(MathCore.Complex)">
            <summary>Гиперболический арксеканс</summary>
        </member>
        <member name="M:MathCore.MathEx.Hyperbolic.Acosech(System.Double)">
            <summary>Гиперболический арккосеканс</summary>
        </member>
        <member name="T:MathCore.MathParser.BlockTerm">
            <summary>Элемент мат.выражения - блок со скобками</summary>
        </member>
        <member name="F:MathCore.MathParser.BlockTerm._OpenBracket">
            <summary>Строковое значение открывающейся скобки</summary>
        </member>
        <member name="F:MathCore.MathParser.BlockTerm._CloseBracket">
            <summary>Строковое значение закрывающейся скобки</summary>
        </member>
        <member name="F:MathCore.MathParser.BlockTerm._Terms">
            <summary>Массив элементов подвыражения</summary>
        </member>
        <member name="P:MathCore.MathParser.BlockTerm.OpenBracket">
            <summary>Строковое значение открывающейся скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.BlockTerm.CloseBracket">
            <summary>Строковое значение закрывающейся скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.BlockTerm.Terms">
            <summary>Массив элементов подвыражения</summary>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.#ctor(System.String)">
            <summary>Новый блок математического выражения</summary>
            <param name="Str">Строковое значение блока</param>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.#ctor(System.String,System.String,System.String)">
            <summary>Новый блок выражения</summary>
            <param name="OpenBracket">Открывающаяся скобка</param>
            <param name="Str">Строковое значение блока</param>
            <param name="CloseBracket">Закрывающаяся скобка</param>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.GetNumberString(System.String,System.Int32@)">
            <summary>Получить цифровую строку</summary>
            <param name="Str">Исследуемая строка</param>
            <param name="pos">Исходная позиция в строке</param>
            <returns>Строка цифрового значения</returns>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.GetNameString(System.String,System.Int32@)">
            <summary>Получить имя из строки</summary>
            <param name="Str">Исходная строка</param>
            <param name="pos">Положение в строке</param>
            <returns>Строка имени</returns>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.GetTerms(System.String)">
            <summary>Получить список элементов математического выражения из строки</summary>
            <param name="Str">Строковое представление математического выражения</param>
            <returns>Массив элементов математического выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.ToString">
            <summary>Преобразование в строковое представление</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.MathParser.BlockTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Получить корень поддерева выражений</summary>
            <param name="Parser">Парсер выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Корень поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.NewRound">
            <summary>Круглые скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.NewRect">
            <summary>Квадратные скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.NewFigure">
            <summary>Фигурные скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.Start">
            <summary>Открывающая скобка</summary>
        </member>
        <member name="P:MathCore.MathParser.Bracket.Stop">
            <summary>Закрывающая скобка</summary>
        </member>
        <member name="M:MathCore.MathParser.Bracket.#ctor(System.String,System.String)">
            <summary>Скобки</summary>
            <param name="Start">Строка открывающей скобки</param>
            <param name="Stop">Строка закрывающей скобки</param>
        </member>
        <member name="M:MathCore.MathParser.Bracket.Equals(MathCore.MathParser.Bracket)">
            <summary>Проверка на эквивалентность другим скобкам</summary>
            <param name="other">Проверяемые на эквивалентность скобки</param>
            <returns>Истина, если проверяемые скобки эквивалентны данным</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.Equals(System.Object)">
            <summary>Проверка на эквивалентность</summary>
            <param name="obj">Проверяемый объект</param>
            <returns>Истина, если объект - скобки и вид скобок совпадает</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.GetHashCode">
            <summary>Получить хэш-код</summary>
            <returns>Хэш-код</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.Clone">
            <summary>Клонирование скобок</summary>
            <returns>Клон скобок</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.ToString">
            <summary>Строковое представление скобок</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.MathParser.Bracket.Surround(System.String)">
            <summary>Разместить текст в скобках</summary>
            <param name="str">Размещаемый текст</param>
            <returns>Текст в скобках</returns>
        </member>
        <member name="T:MathCore.MathParser.CharTerm">
            <summary>Символьный элемент математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.CharTerm.Value">
            <summary>Символьное значение элемента</summary>
        </member>
        <member name="M:MathCore.MathParser.CharTerm.#ctor(System.Char)">
            <summary>Новый символьный элемент</summary>
            <param name="c">Символьное значение элемента</param>
        </member>
        <member name="M:MathCore.MathParser.CharTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Получить поддерево</summary>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Результат вызова метода Parser.GetOperatorNode(Value)</returns>
        </member>
        <member name="T:MathCore.MathParser.ConstantsCollection">
            <summary>Коллекция констант</summary>
        </member>
        <member name="F:MathCore.MathParser.ConstantsCollection._Items">
            <summary>Элементы коллекции</summary>
        </member>
        <member name="P:MathCore.MathParser.ConstantsCollection.Count">
            <summary>Количество элементов коллекции</summary>
        </member>
        <member name="P:MathCore.MathParser.ConstantsCollection.Item(System.String)">
            <summary>Итератор констант по имени</summary>
            <param name="Name">Имя константы</param>
            <returns>Константа с указанным именем</returns>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.Add(MathCore.MathParser.ExpressionVariable)">
            <summary>Добавить элемент в коллекцию</summary>
            <param name="Constant">Добавляемое значение, как константа</param>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.GetNames">
            <summary>Получить имена констант коллекции</summary>
            <returns>Перечисление имён констант коллекции</returns>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.System#Collections#Generic#IEnumerable{MathCore#MathParser#ExpressionVariable}#GetEnumerator">
            <summary>Получить перечислитеь констант коллекции</summary>
            <returns>Перечислитель констант</returns>
        </member>
        <member name="M:MathCore.MathParser.ConstantsCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитеь констант коллекции</summary>
            <returns>Перечислитель констант</returns>
        </member>
        <member name="M:MathCore.MathParser.DifferentialOperator.#ctor">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.DifferentialOperator.GetValue(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.DifferentialOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.DifferentialOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MathParser.EventExpressionVariable">
            <summary>Событийная переменная</summary>
            <remarks>Переменная математического выражения, значение которой определяется через генерацию события</remarks>
        </member>
        <member name="E:MathCore.MathParser.EventExpressionVariable.Call">
            <summary>Событие запроса значения переменной</summary>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.OnCall(System.EventArgs{System.Double})">
            <summary>Метод генерации события</summary>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="F:MathCore.MathParser.EventExpressionVariable._EventArg">
            <summary>Аргумент события</summary>
        </member>
        <member name="F:MathCore.MathParser.EventExpressionVariable._ClearAtCall">
            <summary>Флаг предварительной очистки значения аргумента события</summary>
        </member>
        <member name="P:MathCore.MathParser.EventExpressionVariable.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:MathCore.MathParser.EventExpressionVariable.IsPrecomputable">
            <summary>Признак предвычислимости всегда = false</summary>
        </member>
        <member name="P:MathCore.MathParser.EventExpressionVariable.ClearAtCall">
            <summary>Флаг предварительной очистки значения аргумента события</summary>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.#ctor">
            <summary>Инициализация новой событийной переменной</summary>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.#ctor(System.String)">
            <summary>Инициализация новой событийной переменной</summary>
            <param name="Name">Имя переменной</param>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.GetValue">
            <summary>Получение значения переменной</summary>
            <returns>Значение переменой</returns>
        </member>
        <member name="M:MathCore.MathParser.EventExpressionVariable.Clone">
            <summary>Метод клонирования событийной переменной</summary>
            <returns>Клонированная событийная переменная</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionFunction">
            <summary>функция в структуре математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionFunction.Delegate">
            <summary>Делегат функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionFunction.Arguments">
            <summary>Массив имён аргументов</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.#ctor(System.String,System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>Инициализация новой функции структуры математического выражения по сигнатуре</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Список имён аргументов</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.GetValue(System.Double[])">
            <summary>Метод получения значения функции по массиву значений её аргументов</summary>
            <param name="arguments">Массив аргументов функции</param>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.IsEqualSignature(System.String,System.Int32)">
            <summary>Проверка на эквивалентность сигнатуре</summary>
            <param name="sName">Имя функции</param>
            <param name="ArgumentsCount">Количество аргументов</param>
            <returns>Истина, если сигнатура соответствует функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.IsEqualSignature(System.String,System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>Проверка на эквивалентность сигнатуре</summary>
            <param name="sName">Имя функции</param>
            <param name="Arguments">Массив имён аргументов</param>
            <returns>Истина, если сигнатура соответствует функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.GetValue">
            <summary>Метод получения значения функции. В общем виде не поддерживается.</summary>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionFunction.Clone">
            <summary>Клонирование функции</summary>
            <returns>Клон функции</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionItem">
            <summary>Элемент математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionItem.Name">
            <summary>Имя</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionItem.#ctor">
            <summary>Инициализация нового элемента математического выражения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionItem.#ctor(System.String)">
            <summary>Инициализация нового элемента математического выражения</summary><param name="Name">Имя элемента</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionItem.GetValue">
            <summary>Метод определения значения</summary><returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionOperator">
            <summary>Оператор</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionOperator.GetValue">
            <summary>Получить значение</summary>
            <returns>Значение оператора</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionParser">
            <summary>Парсер математических выражений</summary>
        </member>
        <member name="E:MathCore.MathParser.ExpressionParser.NewNodeAdded">
            <summary>Событие возникает при добавлении нового узла в дерево выражения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnNewNodeAdded(System.EventArgs{MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary>При добавлении нового узла в дерево выражения</summary>
            <param name="e">Аргумент события, содержащий добавляемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnNewNodeAdded(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@)">
            <summary>Обработка очередного добавляемого в дерево узла</summary>
            <param name="NewNode">Новый добавляемый узел дерева выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.ProcessNewNode(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@)">
            <summary>Обработка нового узла дерева выражения</summary>
            <param name="NewNode">Новый добавляемый узел</param>
        </member>
        <member name="E:MathCore.MathParser.ExpressionParser.StringPreprocessing">
            <summary>Событие предобработки входящей строки</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnStringPreprocessing(System.EventArgs{System.String})">
            <summary>Генерация события предобработки входящей строки</summary>
            <param name="args">Аргумент события, содержащий обрабатываемую строку</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnStringPreprocessing(System.String@)">
            <summary>Генерация события предобработки входящей строки</summary>
            <param name="StrExpression">Обрабатываемая строка</param>
        </member>
        <member name="T:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs">
            <summary>Аргумент события обнаружения функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.Name">
            <summary>Имя обнаруженной функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.Arguments">
            <summary>Массив имён аргументов функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.ArgumentCount">
            <summary>Количество аргументов функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.Function">
            <summary>Делегат функции, который надо использовать при её вычислении</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.#ctor(System.String,System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>Инициализация аргумента события обнаружения функции</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Массив имён аргументов функции</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.FindFunctionEventArgs.SignatureEqual(System.String,System.Int32)">
            <summary>Проверка на совпадение сигнатуры функции по имени и числу переменных</summary>
            <param name="name">Имя проверяемой функции</param>
            <param name="ArgumentsCount">Число переменных</param>
            <returns></returns>
        </member>
        <member name="E:MathCore.MathParser.ExpressionParser.FindFunction">
            <summary>Событие, возникающее в процессе разбора математического выражения при обнаружении функции</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnFindFunction(MathCore.MathParser.ExpressionParser.FindFunctionEventArgs)">
            <summary>Обработчик события обнаружения функции в процессе разбора выражения</summary>
            <param name="Args">Аргументы события, содержащие имя функции, имена аргументов и делегат метода функции</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnFunctionFind(System.String,System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>Обработчик события обнаружения функции в процессе разбора выражения</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Аргументы функции</param>
            <returns>Делегат функции</returns>
        </member>
        <member name="E:MathCore.MathParser.ExpressionParser.VariableProcessing">
            <summary>Событие обработки переменных при разборе мат.выражений</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnVariableProcessing(System.EventArgs{MathCore.MathParser.ExpressionVariable})">
            <summary> Обработка обнаруженной переменной</summary>
            <param name="e">Обнаруженная переменная</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.OnVariableProcessing(MathCore.MathParser.ExpressionVariable)">
            <summary> Обработка обнаруженной переменной</summary>
            <param name="Variable">Обнаруженная переменная</param>
        </member>
        <member name="F:MathCore.MathParser.ExpressionParser._ExcludeCharsSet">
            <summary>Множество запрещённых символов</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionParser._Constants">
            <summary>Словарь констант</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.ExcludeCharsSet">
            <summary>Множество запрещённых символов</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.ExpressionSeparator">
            <summary>Разделитель выражений (по умолчанию ';')</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.DecimalSeparator">
            <summary>Разделитель целой части и мантисcы десятичного числа</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionParser.Constants">
            <summary>Константы</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.#ctor">
            <summary>Парсер математических выражений</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.StrPreprocessing(System.String@)">
            <summary>Предварительная обработка входного строкового выражения</summary>
            <param name="Str">Обрабатываемая строка</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.Parse(System.String)">
            <summary>Разобрать строку математического выражения</summary>
            <param name="StrExpression">Строковое представление математического выражения</param>
            <returns>Математическое выражение</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.ProcessVariables(MathCore.MathParser.MathExpression)">
            <summary>Обработка переменных</summary>
            <param name="Expression">Обрабатываемое математическое выражение</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.ProcessFunctions(MathCore.MathParser.MathExpression)">
            <summary>Обработка функций</summary>
            <param name="Expression">Обрабатываемое математическое выражение</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.GetOperatorNode(System.Char)">
            <summary>Метод определения узла дерева, реализующего оператор</summary>
            <param name="Name">Имя оператора</param>
            <returns>Узел дерева оператора</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.GetFunctional(System.String)">
            <summary>Метод определения функционала по имени</summary>
            <param name="Name">Имя функционала</param>
            <returns>Функционал</returns>
            <exception cref="T:System.NotSupportedException">Возникает для неопределённых имён функционалов</exception>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.GetRoot(MathCore.MathParser.Term[],MathCore.MathParser.MathExpression)">
            <summary>Метод извлечения корня дерева из последовательности элементов математического выражения</summary>
            <param name="Group">группа элементов математического выражения</param>
            <param name="MathExpression">Ссылка на математическое выражение</param>
            <returns>Корень дерева мат.выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionParser.Combine(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Комбинация предыдущего и текущего узлов дерева</summary>
            <param name="Last">Предыдущий узел дерева (уже интегрированный в дерево)</param>
            <param name="Node">Текущий узел, который надо вставить в дерево</param>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.ExpressionTree">
            <summary>Дерево выражения</summary>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType">
            <summary>Метод обхода дерева</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.LeftRightRoot">
            <summary>Левое поддерево, правое поддерево, корень</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.LeftRootRight">
            <summary>Левое поддерево, корень, правое поддерево</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RootLeftRight">
            <summary>Корень, левое поддерево, правое поддерево</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RightLeftRoot">
            <summary>Правое поддерево, левое поддерево, корень</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RightRootLeft">
            <summary>Правое поддерево, корень, левое поддерево</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType.RootRightLeft">
            <summary>Корень, правое поддерево, левое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.ExpressionTree.Root">
            <summary>Корень</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.#ctor">
            <summary>Инициализация нового дерева математического выражения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового дерева математического выражения</summary><param name="Root">Узел - корень дерева</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Clear">
            <summary>Очистить дерево</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Remove(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Удалить узел</summary><param name="Node">Удаляемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Swap(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Заменить узел</summary><param name="OldNode">Исходный узел</param><param name="NewNode">Новый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.MoveParentDown(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Переместить узел вниз</summary><param name="Node">Перемещаемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Bypass(MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType)">
            <summary>Обойти дерево</summary><param name="type">Способ обхода</param><returns>Перечисление узлов дерева по указанному способу обхода</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Dispose">
            <summary>Уничтожить дерево</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.ToString">
            <summary>Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.</summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.Clone">
            <summary>Клонировать дерево</summary><returns>Клон дерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.System#ICloneable#Clone">
            <summary>Клонировать дерево</summary><returns>Клон дерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.GetEnumerator">
            <summary>Получить перечислитель узлов дерева по методу ЛКП</summary><returns>Перечислитель узлов дерева по методу ЛКП</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.ExpressionTree.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode">
            <summary>Узел дерева выражений, реализующий оператор сложения</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.NodeName">
            <summary>Имя узла операции "+"</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.#ctor">
            <summary>Новый оператор сложения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compute">
            <summary>Вычисление узла</summary>
            <returns>Сумма поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Linq.Expression.Add()</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Args">Массив параметров выражения</param>
            <returns>Linq.Expression.Add()</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AdditionOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Полный клон узла с клонами поддеревьев</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор ленивого И</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора ленивого И</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию И</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Args">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию И</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.AndOperatorNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.CharNode">
            <summary>Символьный узел дерева математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.Value">
            <summary>Значение символа узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.#ctor">
            <summary>Инициализация нового строкового узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.#ctor(System.Char)">
            <summary>Инициализация нового строкового узла</summary>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.op_Implicit(System.Char)~MathCore.MathParser.ExpressionTrees.Nodes.CharNode">
            <summary>Оператор неявного преобразования строки к типу строкового узла</summary>
            <param name="value">Строковое значение</param>
            <returns>Символьный узел</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.CharNode.op_Implicit(MathCore.MathParser.ExpressionTrees.Nodes.CharNode)~System.Char">
            <summary>Оператор неявного преобразования строкового узла к символьному типу</summary>
            <param name="node">Символьный узел</param>
            <returns>Значение Символьного узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode">
            <summary>Узел дерева мат.выражения, реализующий скобки с возможностью вычисления</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode._Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Bracket">
            <summary>Скобки</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.#ctor(MathCore.MathParser.Bracket,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Вычислимый блочный узел дерева</summary>
            <param name="bracket">Скобки</param>
            <param name="Node">Узел-содержимое</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compute">
            <summary>Вычислить значение узла</summary>
            <returns>Значение вложенного узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Компиляция содержимого узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла с параметрами</summary>
            <param name="Args">Список параметров выражения</param>
            <returns>Компиляция вложенного узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.Clone">
            <summary>Клон узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedBracketNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode">
            <summary>Вычислимый узел дерева математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.LeftComputedOrNull">
            <summary>Левый узел, приведённый к виду вычислимого узла (допускающий пустуй ссылку)</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.LeftComputed">
            <summary>Левый узел, приведённый к виду вычислимого узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.RightComputedOrNull">
            <summary>Правый узел, приведённый к виду вычислимого узла (допускающий пустуй ссылку)</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.RightComputed">
            <summary>Правый узел, приведённый к виду вычислимого узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ComputedNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Args">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode">
            <summary>Узел дерева, хранящий константное значение</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode._Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.IsPrecomputable">
            <summary>Флаг возможности получения значения без вычисления. Всегда = true</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Value">
            <summary>Значение узла. Не поддерживает присвоение</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor">
            <summary>Инициализация константного узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor(System.Double)">
            <summary>Инициализация константного узла</summary>
            <param name="Value">Значение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.#ctor(System.Int32)">
            <summary>Инициализация константного узла</summary>
            <param name="Value">Значение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Args">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ConstValueNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор деления</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.#ctor">
            <summary>Инициализация узла оператора деления</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла с параметрами</summary>
            <param name="Args">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.DivisionOperatorNode.Clone">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор равенства</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.__Epsilon">
            <summary>Точность вычисления равенства для чисел с плавающей точкой</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Epsilon">
            <summary>Точность вычисления равенства для чисел с плавающей точкой</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора равенства</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора равенства</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Равенство</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Args">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Равенство</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.EqualityOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode">
            <summary>Узел дерева вычислений</summary>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator">
            <summary>Перечислитель предков узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.Node">
            <summary>Исходный узел</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.Item(System.Int32)">
            <summary>Итератор предков узла, где узел с индексом 0 - первый предок узла</summary>
            <param name="i">Номер предка</param>
            <returns>Предок указанного поколения</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Новый итератор предков узла</summary>
            <param name="Node">Обрабатываемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.System#Collections#Generic#IEnumerable{MathCore#MathParser#ExpressionTrees#Nodes#ExpressionTreeNode}#GetEnumerator">
            <summary>Получить перечислитель предков узла</summary>
            <returns>Перечислитель предков узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель</summary>
            <returns>Перечислитель</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ParentsIterator.GetParentsEnumerable">
            <summary>Метод получения перечисления предков узла</summary>
            <returns>Перечисление предков узла</returns>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode._Left">
            <summary>Узел левого поддерева</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode._Right">
            <summary> Узел правого поддерева</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsPrecomputable">
            <summary>Признак возможности получения тривиального значения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsRoot">
            <summary>Является ли узел дерева корнем?</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsLeftSubtree">
            <summary>Признак - является ли текущий узел левым поддеревом</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.IsRightSubtree">
            <summary>Признак - является ли текущий узел правым поддеревом</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Parent">
            <summary>Ссылка на предка узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Left">
            <summary>Левое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Right">
            <summary>Правое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.RightNodes">
            <summary>Перечисление правых узлов правого поддерева включая корень</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LeftNodes">
            <summary>Перечисление левых узлов левого поддерева включая корень</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Parents">
            <summary>Перечислитель предков узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Root">
            <summary>Ссылка на корень дерева</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Depth">
            <summary>Глубина положения узла в дереве</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LastLeftChild">
            <summary>Самый левый дочерний узел, либо текущий</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.LastRightChild">
            <summary>Самый правый дочерний узел, либо текущий</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.String)">
            <summary>Доступ к элементам узла по указанному пути</summary>
            <param name="path">Путь к элементам узла Пример:.\.\l\r\r\l  ..\l\r\r</param>
            <returns>Элемент узла, выбранный по указанному пути</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary>Доступ к дочерним элементам узла с помощью метода выбора</summary>
            <param name="ChildSelector">Метод выбора элементов узла</param>
            <returns>Перечисление дочерних элементов по указанному методу</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Item(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode})">
            <summary> Итератор элементов узла методом выборки</summary>
            <param name="Selector">Метод выборки узлов относительно текущего</param>
            <returns>Перечисление узлов по указанному методу</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Path">
            <summary>Путь к узлу</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Bypassing(MathCore.MathParser.ExpressionTrees.ExpressionTree.BypassingType)">
            <summary>Метод обхода дерева</summary>
            <param name="type">Тип обхода дерева</param>
            <returns>Перечисление элементов дерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetChilds">
            <summary>Перечисление дочерних элементов дерева</summary>
            <returns>Перечисление дочерних элементов дерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.SwapToChild(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Поменять узел местами с дочерним</summary>
            <param name="Parent">Материнский узел</param>
            <param name="Child">Дочерний узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Swap(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Подменить узел А узлом В</summary>
            <param name="A">Замещаемый узел</param>
            <param name="B">Подменяемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.SwapTo(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Заменить узел на указанный</summary>
            <param name="Node">Узел, на который производится замена</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Remove">
            <summary>Удалить узел с перекоммутацией ссылок</summary>
            <returns>Если удаляется корень, то левое поддерево, иначе ссылка не предка узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetNextLeft">
            <summary>Получить следующий узел слева</summary>
            <returns>Узел слева от текущего</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetNextRight">
            <summary>Получить следующий узел справа</summary>
            <returns>Узел справа от текущего</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetVariables">
            <summary>Перечисление переменных, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetFunctions">
            <summary>Перечисление функций, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева функций</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.GetFunctionals">
            <summary>Перечисление функционалов, известных данному узлу дерева</summary>
            <returns>Перечисление всех известных данному узлу дерева функционалов</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Dispose">
            <summary>Уничтожить узел рекуррентно с поддеревьями</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode._Disposed">
            <summary>Объект считается уничтоженным</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Dispose(System.Boolean)">
            <summary>Уничтожить узел рекуррентно с поддеревьями</summary>
            <param name="disposing">Выполнить освобождение управляемых ресурсов</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.System#ICloneable#Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode.op_Implicit(System.String)~MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode">
            <summary>Оператор неявного преобразования строки в узел дерева</summary>
            <param name="value">Строковое значение</param>
            <returns>Строковый узел дерева</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode">
            <summary>Функциональный узел</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Name">
            <summary>Имя узла</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode._ParametersExpression">
            <summary>Выражение параметров</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode._CoreExpression">
            <summary>Выражение ядра функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Parameters">
            <summary>Выражение параметров</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Core">
            <summary>Выражение ядра функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Operator">
            <summary>Оператор</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode"/></summary>
            <param name="Name">Имя функционала</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.#ctor(MathCore.MathParser.FunctionalTerm,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode"/></summary>
            <param name="term">Блок определения функционала</param>
            <param name="Parser">Парсер выражения, конструирующий дерево</param>
            <param name="Expression">Выражение, в которое будет включён создаваемый узел</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.GetVariables">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Args">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionalNode.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode">
            <summary>Узел дерева выражения, содержащий сведения об аргументе функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.ArgumentNode">
            <summary>Узел аргумента</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.ArgumentName">
            <summary>Узел имени аргумента</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor(System.String,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
            <param name="Name">Имя</param>
            <param name="Expression">Узел выражения аргумента</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.StringNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла дерева информации об аргументе функции</summary>
            <param name="Name">Имя</param>
            <param name="Expression">Выражение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compute">
            <summary>Метод вычисления значения узла</summary>
            <returns>Значение аргумента</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compile">
            <summary>Компиляция узла аргумента</summary>
            <returns>Скомпилированное выражение</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла аргумента с учётом списка параметров</summary>
            <param name="Args">Массив параметров процесса компиляции</param>
            <returns>Скомпилированное значение узла аргумента дерева выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode">
            <summary>Узел дерева мат.выражения, хранящий данные об аргументе функции</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.EnumArguments(MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode)">
            <summary>Перечисление аргументов начиная с указанного</summary>
            <param name="Node">Первый узел аргумента</param>
            <returns>Перечисление пар имени-корня дерева аргумента</returns>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.ArgumentSubtree">
            <summary>Значение аргумента - правое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.ArgumentName">
            <summary>Имя аргумента - левое поддерево</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor">
            <summary>Инициализация узла-аргумента</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor(System.String,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация узла-аргумента</summary>
            <param name="Name">Имя аргумента</param>
            <param name="Node">Узел поддерева аргумента</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNameNode)">
            <summary>Инициализация узла-аргумента</summary>
            <param name="Node">Узел поддерева аргумента</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compile">
            <summary>Компиляция узла аргумента</summary>
            <returns>Скомпилированное выражение корня поддерева аргумента</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла аргумента</summary>
            <param name="Args">Список параметров выражения</param>
            <returns>Скомпилированное выражение корня поддерева аргумента</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionArgumentNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клонирование узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode">
            <summary>Узел дерева выражения, содержащий функцию</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Name">
            <summary>Имя функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.ArgumentsNames">
            <summary>Массив имён аргументов функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Arguments">
            <summary>Перечисление аргументов функции</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Function">
            <summary>Функция узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor">
            <summary>Инициализация нового функционального узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(System.String)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.StringNode)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.#ctor(MathCore.MathParser.FunctionTerm,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация нового функционального узла</summary>
            <param name="Term">Выражение функции</param>
            <param name="Parser">Парсер выражения</param>
            <param name="Expression">Математическое выражение</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Значение функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.GetFunctionArgumentNodes(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Получить перечисление аргументов функции</summary>
            <param name="FunctionNode">Узел функции</param>
            <returns>Перечисление аргументов функции</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Args">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.FunctionNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор больше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора больше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора больше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x больше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Больше</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Args">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Больше</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.GreaterThenOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode">
            <summary>Узел интервального значения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.IntervalNode.ToString">
            <summary>Преобразование узла в строку</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор меньше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора меньше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора меньше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод сравнения</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Меньше</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Args">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию сравнения Меньше</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LessThenOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий логическую операцию</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее логику оператора</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Args">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее логику оператора</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.LogicOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Args">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор умножения "*"</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора произведения</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора произведения</summary>
            <param name="Left">Левое поддерево произведения</param>
            <param name="Right">Правое поддерево произведения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>Произведение значений корней правого и левого поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Args">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.MultiplicationOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор отрицания</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора меньше</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора меньше</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Comparer(System.Double,System.Double)">
            <summary>Метод отрицания</summary>
            <param name="x">Первое значение</param>
            <param name="y">Второе значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.ComparerSingle(System.Double)">
            <summary>Метод отрицания</summary>
            <param name="x">Значение</param>
            <returns>1 - если x меньше y и 0 - в противном случае</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns>0 - если разность между x и y по модулю меньше Epsilon и 1 во всех остальных случаях</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию отрицания НЕ</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Args">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию отрицания НЕ</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.NotOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.IsPrecomputable">
            <summary>Оператор является предвычислимым если предвычислимы его правое и левое поддерево</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.Priority">
            <summary>Приоритет оператора</summary>
            <remarks>
            Чем выше приоритет, тем глубже в дереве должен находиться оператор
            Шакала базовых приоритетов:
             + - 0
             - - 5
             * - 10
             / - 15
             ^ - 20
            </remarks>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.Name">
            <summary>Ипя оператора</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor">
            <summary>Инициализация оператора</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor(System.String)">
            <summary>Инициализация оператора</summary>
            <param name="Name">Имя оператора</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.#ctor(System.String,System.Int32)">
            <summary>Инициализация оператора</summary>
            <param name="Name">Имя оператора</param>
            <param name="Priority">Приоритет оператора</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор ленивого ИЛИ</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора ленивого ИЛИ</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.LogicCompile">
            <summary>Компиляция логики узла</summary>
            <returns>Скомпилированное логическое выражение, реализующее операцию ИЛИ</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.LogicCompile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция логики узла</summary>
            <param name="Args">Параметры компиляции</param>
            <returns>Скомпилированное логическое выражение, реализующее операцию ИЛИ</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.OrOperatorNode.Clone">
            <summary>Клонирование поддерева</summary>
            <returns>Клон поддерева</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ParsedNode">
            <summary>Узел дерева выражения стадии разбора</summary>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode">
            <summary>Узел дерева математического выражения, реализующий оператор возведения в степень</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора возведения в степень</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compute">
            <summary>Вычисление узла выражения</summary>
            <returns>Возведение значения корня левого поддерева в степень значения корня правого поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compile">
            <summary>Компиляция выражения узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция выражения узла</summary>
            <param name="Args">Массив параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.PowerOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор выбора</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора выбора</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора выбора</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Args">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.SelectorOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.StringNode">
            <summary>Строковый узел дерева математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.#ctor">
            <summary>Инициализация нового строкового узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.#ctor(System.String)">
            <summary>Инициализация нового строкового узла</summary>
            <param name="value">Значение узла</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.ToString">
            <summary>Строковое представление узла</summary>
            <returns>Строковое представление узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.op_Implicit(System.String)~MathCore.MathParser.ExpressionTrees.Nodes.StringNode">
            <summary>Оператор неявного преобразования строки к типу строкового узла</summary>
            <param name="value">Строковое значение</param>
            <returns>Строковый узел</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.StringNode.op_Implicit(MathCore.MathParser.ExpressionTrees.Nodes.StringNode)~System.String">
            <summary>Оператор неявного преобразования строкового узла к строковому типу</summary>
            <param name="node">Строковый узел</param>
            <returns>Значение строкового узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode">
            <summary>Узел дерева выражения, реализующий оператор вычитания</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.#ctor">
            <summary>Инициализация нового оператора вычитания</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.Compute">
            <summary>Вычисление значение узла</summary>
            <returns>Значение разности значений правого и левого поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.Compile">
            <summary>Компиляция выражения узла</summary>
            <returns>Скомпилированное выражение узла</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция выражения узла</summary>
            <param name="Args">Список параметров выражения</param>
            <returns>Скомпилированное выражение узла</returns>
            <returns></returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.subtractionOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.ValueNode">
            <summary>Узел дерева мат.выражения, хранящий значение</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.ValueNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.ValueNode.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode">
            <summary>Узел дерева, хранящий переменную</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.IsPrecomputable">
            <summary>Признак возможности получения тривиального значения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Variable">
            <summary>Ссылка на переменную</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Name">
            <summary>Имя переменной</summary> 
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.#ctor(MathCore.MathParser.ExpressionVariable)">
            <summary>Новый узел переменной</summary>
            <param name="Variable">Переменная</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compute">
            <summary>Вычислить значение поддерева</summary>
            <returns>Численное значение поддерева</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compile">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Args">Массив параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode">
            <summary>Узел дерева мат.выражения, реализующий оператор определения вариантов</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.#ctor">
            <summary>Инициализация нового узла оператора определения вариантов</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.#ctor(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode,MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode)">
            <summary>Инициализация нового узла оператора определения вариантов</summary>
            <param name="Left">Левое поддерево выражения</param>
            <param name="Right">Правое поддерево выражения</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compute">
            <summary>Вычисление значения узла</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compile">
            <summary>Компиляция узла</summary>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Compile(System.Linq.Expressions.ParameterExpression[])">
            <summary>Компиляция узла</summary>
            <param name="Args">Массив параметров выражения</param>
            <returns>Скомпилированное выражение произведения узлов поддеревьев</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionTrees.Nodes.VariantOperatorNode.Clone">
            <summary>Клонирование узла</summary>
            <returns>Клон узла</returns>
        </member>
        <member name="T:MathCore.MathParser.ExpressionVariable">
            <summary>Переменная математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionVariable._Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="F:MathCore.MathParser.ExpressionVariable._IsConstant">
            <summary>Является ли константой?</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionVariable.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionVariable.IsPrecomputable">
            <summary>Признак возможности предвычисления значения</summary>
        </member>
        <member name="P:MathCore.MathParser.ExpressionVariable.IsConstant">
            <summary>Является ли константой?</summary>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.GetValue">
            <summary>Метод извлечения значения</summary>
            <returns>Численное значение переменной</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.#ctor(System.String)">
            <summary>Инициализация нового экземпляра переменной</summary>
            <param name="Name">Имя переменной</param>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.Clone">
            <summary>Клонирование переменной</summary>
            <returns>Новый экземпляр переменной с тем же именем и тем же значением</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление переменной</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.op_Implicit(System.Double)~MathCore.MathParser.ExpressionVariable">
            <summary>Оператор неявного привидения вещественного числа к типу переменной</summary>
            <param name="x">Вещественное число</param>
            <returns>Безымянная переменная, хранящая указанное число</returns>
        </member>
        <member name="M:MathCore.MathParser.ExpressionVariable.op_Implicit(MathCore.MathParser.ExpressionVariable)~System.Double">
            <summary>Оператор неявного привидения к типу вещественного числа</summary>
            <param name="variable">Приводимая переменная</param>
            <returns>Значение переменной</returns>
        </member>
        <member name="T:MathCore.MathParser.Functional">
            <summary>Функционал</summary>
        </member>
        <member name="M:MathCore.MathParser.Functional.#ctor(System.String)">
            <summary>Инициализация нового функционала</summary>
            <param name="Name">Имя функционала</param>
        </member>
        <member name="M:MathCore.MathParser.Functional.GetValue">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.Functional.GetValue(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <param name="ParametersExpression">Выражение параметров</param>
            <param name="Function">Ядро функционала</param>
            <returns>Численное значение вычисленного выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.Functional.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathCore.MathParser.Functional.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Выражение ядра функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathCore.MathParser.Functional.Initialize(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Внешнее мат.выражение</param>
        </member>
        <member name="T:MathCore.MathParser.FunctionalsCollection">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="F:MathCore.MathParser.FunctionalsCollection._Operators">
            <summary>Список функционалов</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionalsCollection.Count">
            <summary>Количество функционалов в коллекции</summary>
        </member>
        <member name="M:MathCore.MathParser.FunctionalsCollection.Add(MathCore.MathParser.Functional)">
            <summary>Добавить функционал в коллекцию</summary>
            <param name="Operator">Добавляемый функционал</param>
            <returns>Истина, если добавление прошло успешно</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionalsCollection.System#Collections#Generic#IEnumerable{MathCore#MathParser#Functional}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.FunctionalsCollection.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.FunctionalsCollection.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MathParser.FunctionalTerm">
            <summary>Блок определения функции</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionalTerm.Parameters">
            <summary>Параметры оператора</summary>
        </member>
        <member name="M:MathCore.MathParser.FunctionalTerm.#ctor(MathCore.MathParser.FunctionTerm,MathCore.MathParser.BlockTerm)">
            <summary>Инициализация блока комплексного оператора</summary>
            <param name="Header">Заголовок блока</param>
            <param name="Body">Тело блока</param>
        </member>
        <member name="M:MathCore.MathParser.FunctionalTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Получить поддерево комплексного оператора</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел комплексного оператора</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionalTerm.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление элемента</returns>
        </member>
        <member name="T:MathCore.MathParser.FunctionsCollection">
            <summary>Коллекция функций</summary>
        </member>
        <member name="F:MathCore.MathParser.FunctionsCollection._Functions">
            <summary>Список функций математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionsCollection.Names">
            <summary>Имена функций</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionsCollection.Count">
            <summary>Количество используемых функций</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionsCollection.Item(System.String,System.Int32)">
            <summary>Индексатор функций по имени и списку параметров</summary>
            <param name="Name">Имя функции</param>
            <param name="ArgumentsCount">Количество аргументов</param>
            <returns>Функция, удовлетворяющая загаданной сигнатуре</returns>
        </member>
        <member name="P:MathCore.MathParser.FunctionsCollection.Item(System.String,System.String[])">
            <summary>Индексатор функций по имени и списку параметров</summary>
            <param name="Name">Имя функции</param>
            <param name="Arguments">Список имён аргументов</param>
            <returns>Функция, удовлетворяющая загаданной сигнатуре</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionsCollection.Add(MathCore.MathParser.ExpressionFunction)">
            <summary>Добавить функцию в коллекцию</summary>
            <param name="function">Функция</param>
            <returns>Истина, если функция была добавлена</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionsCollection.System#Collections#Generic#IEnumerable{MathCore#MathParser#ExpressionFunction}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MathParser.FunctionsCollection.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MathParser.FunctionTerm">
            <summary>Функциональный элемент выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.FunctionTerm.Block">
            <summary>Блок со скобками</summary>
        </member>
        <member name="M:MathCore.MathParser.FunctionTerm.#ctor(MathCore.MathParser.StringTerm,MathCore.MathParser.BlockTerm)">
            <summary>Новый функциональный элемент выражения</summary>
            <param name="StrTerm">Строковый элемент выражения</param>
            <param name="Block">Блок выражения</param>
        </member>
        <member name="M:MathCore.MathParser.FunctionTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Получить поддерево</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел функции</returns>
        </member>
        <member name="M:MathCore.MathParser.FunctionTerm.ToString">
            <summary>Преобразование в строковую форму</summary>
            <returns>Строковое представление элемента</returns>
        </member>
        <member name="T:MathCore.MathParser.IntegralOperator">
            <summary>Комплексный оператор интегрирования</summary>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.#ctor">
            <summary>Создание нового комплексного интегратора интегрирования</summary>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.#ctor(System.String)">
            <summary>Создание нового комплексного интегратора интегрирования</summary>
            <param name="Name">Имя оператора</param>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.Initialize(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер</param>
            <param name="Expression">Внешнее выражение</param>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.GetValue(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.IntegralOperator.AdaptiveIntegralDelegate">
            <summary>Делегат адаптивного интегрирования</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Конечное значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.GetAdaptiveIntegral(System.Delegate,System.Double,System.Double,System.Double[])">
            <summary>Получить численное значение интеграла адаптивным методом</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Конечное значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="T:MathCore.MathParser.IntegralOperator.IntegralDelegate">
            <summary>Получить численное значение интеграла методом трапеций</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Конечное значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <param name="dx">Шаг интерполяции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.GetIntegral(System.Delegate,System.Double,System.Double,System.Double[],System.Double)">
            <summary>Получить численное значение интеграла методом трапеций</summary>
            <param name="d">Делегат интегрируемой функции</param>
            <param name="Min">Начальное значение интервала интегрирования</param>
            <param name="Max">Конечное значение интервала интегрирования</param>
            <param name="Parameters">Массив параметров интегрируемой функции</param>
            <param name="dx">Шаг интерполяции</param>
            <returns>Значение интеграла</returns>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="M:MathCore.MathParser.IntegralOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Ядро функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение <see cref="N:System.Linq.Expressions"/></returns>
        </member>
        <member name="T:MathCore.MathParser.LambdaExpressionVariable">
            <summary>лямбда-переменная</summary>
            <remarks>Значение переменной - результат вычисления лямбда-функции</remarks>
        </member>
        <member name="F:MathCore.MathParser.LambdaExpressionVariable._Value">
            <summary>Функция вычисления значения переменной</summary>
        </member>
        <member name="P:MathCore.MathParser.LambdaExpressionVariable.IsPrecomputable">
            <summary>Признак отсутствия возможности предвычисления значения</summary>
        </member>
        <member name="M:MathCore.MathParser.LambdaExpressionVariable.#ctor(System.Func{System.Double})">
            <summary>Инициализация нового экземпляра лямбда-переменной</summary>
            <param name="Source">лямбда-функция получения значения переменной</param>
        </member>
        <member name="M:MathCore.MathParser.LambdaExpressionVariable.#ctor(System.String,System.Func{System.Double})">
            <summary>Инициализация нового экземпляра лямбда-переменной</summary>
            <param name="Name">Имя переменной</param>
            <param name="Source">лямбда-функция получения значения переменной</param>
        </member>
        <member name="M:MathCore.MathParser.LambdaExpressionVariable.GetValue">
            <summary>Получить значение переменной</summary>
            <returns>Численное значение переменной</returns>
        </member>
        <member name="M:MathCore.MathParser.LambdaExpressionVariable.Clone">
            <summary>Клонировать переменную</summary>
            <returns>Новый экземпляр лямбда-переменной с тем же именем и клоном функции</returns>
        </member>
        <member name="T:MathCore.MathParser.MathExpression">
            <summary>Математическое выражение</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._ExpressionTree">
            <summary>Дерево математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Variables">
            <summary>Коллекция переменных математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Constants">
            <summary>Коллекция констант математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Functions">
            <summary>Коллекция функций, участвующих в выражении</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Functionals">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="F:MathCore.MathParser.MathExpression._Name">
            <summary>Имя выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Name">
            <exception cref="T:System.ArgumentNullException" accessor="set"><paramref name="value"/> is <see langword="null" />.</exception>
            <exception cref="T:System.ArgumentException" accessor="set">Указано пустое имя функции</exception>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.IsPrecomputable">
            <summary>Является ли выражение предвычислимым?</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Tree">
            <summary>Дерево математического выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.VariableNodes">
            <summary>Перечисление узлов дерева, содержащих переменные</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Variable">
            <summary>Переменные, входящие в математическое выражение</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Constants">
            <summary>Константы, входящие в математическое выражение</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Functions">
            <summary>Коллекция функций, участвующих в выражении</summary>
        </member>
        <member name="P:MathCore.MathParser.MathExpression.Functionals">
            <summary>Коллекция функционалов</summary>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.#ctor(System.String)">
            <summary>Инициализация пустого математического выражения</summary>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.#ctor(MathCore.MathParser.ExpressionTrees.ExpressionTree,System.String)">
            <summary>Инициализация нового математического выражения</summary>
            <param name="Tree">Дерево математического выражения</param>
            <param name="Name">Имя функции</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.#ctor(System.String,MathCore.MathParser.ExpressionParser)">
            <summary>Инициализация нового математического выражения</summary>
            <param name="StrExpression">Строковое представление выражения</param>
            <param name="Parser">Ссылка на парсер</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Dispose">
            <summary>Уничтожить математическое выражение</summary>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов выражения</summary>
            <param name="disposing">Требуется ли выполнить освобождение управляемых ресурсов?</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compute">
            <summary>Вычисление математического выражения</summary>
            <returns>Значение выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compute(System.Double[])">
            <summary>Вычисление математического выражения</summary>
            <returns>Значение выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile">
            <summary>Компиляция математического выражения в функцию без параметров</summary>
            <returns>Функция типа double func(void) без параметров</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile1">
            <summary>Компиляция функции одной переменной</summary>
            <returns>Делегат функции одной переменной</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile2">
            <summary>Компиляция функции двух переменных</summary>
            <returns>Делегат функции двух переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile3">
            <summary>Компиляция функции трёх переменных</summary>
            <returns>Делегат функции трёх переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile(System.String[])">
            <summary>Компиляция математического выражения в функцию указанного типа</summary>
            <param name="ArgumentName">Список имён параметров</param>
            <returns>Делегат скомпилированного выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.CompileMultiParameters(System.String[])">
            <summary>Многопараметрическая компиляция мат.выражения</summary>
            <param name="ArgumentName">Массив имён компилируемых параметров</param>
            <returns>Делегат функции, принимающий на вход массив значений параметров</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Compile``1(System.String[])">
            <summary>Компиляция математического выражения в функцию указанного типа</summary>
            <typeparam name="TDelegate">Тип делегата функции</typeparam>
            <param name="ArgumentName">Список имён параметров</param>
            <returns>Делегат скомпилированного выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.GetExpression(System.Linq.Expressions.ParameterExpression[]@,System.String[])">
            <summary>Получить Linq.Expression выражение, построенное на основе дерева выражений</summary>
            <param name="vars">Список входных переменных</param>
            <param name="ArgumentName">Список имён аргументов</param>
            <returns>Выражение типа Linq.Expression</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.GetExpression``1(System.Linq.Expressions.ParameterExpression[]@,System.String[])">
            <summary>Получить Linq.Expression выражение, построенное на основе дерева выражений</summary>
            <typeparam name="TDelegate">Тип делегата выражения</typeparam>
            <param name="vars">Список входных переменных</param>
            <param name="ArgumentName">Список имён аргументов</param>
            <returns>Выражение типа Linq.Expression</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Строковое представление</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.CheckConstantsCollection(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Перенос констант из выражения источника в выражение приёмник</summary>
            <param name="Source">Выражение источник</param>
            <param name="Result">Выражение приёмник</param>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.Clone">
            <summary>Клонирование выражения</summary>
            <returns>Копия объектной модели выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.CombineExpressions(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,MathCore.MathParser.ExpressionTrees.Nodes.OperatorNode)">
            <summary>Комбинация двух выражений с использованием узла-оператора</summary>
            <param name="x">Первое выражение</param>
            <param name="y">Второе выражение</param>
            <param name="node">Узел операции</param>
            <returns>Математическое выражение, в корне дерева которого лежит узел оператора. Поддеревья - корни первого и второго выражений</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Addition(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор сложения двух выражений</summary>
            <param name="x">Первое слагаемое</param>
            <param name="y">Второе слагаемое</param>
            <returns>Выражение-сумма, корень которого - узел суммы. Поддеревья - корни выражений слагаемых</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Subtraction(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор вычитания двух выражений</summary>
            <param name="x">Уменьшаемое</param>
            <param name="y">Вычитаемое</param>
            <returns>Выражение-разность, корень которого - узел разности. Поддеревья - корни выражений вычитаемого и уменьшаемого</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Multiply(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор умножения двух выражений</summary>
            <param name="x">Первый сомножитель</param>
            <param name="y">Второй сомножитель</param>
            <returns>Выражение-произведения, корень которого - узел произведения. Поддеревья - корни выражений сомножителей</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Division(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор деления двух выражений</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Выражение-частное, корень которого - узел деления. Поддеревья - корни выражений делимого и делителя</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_ExclusiveOr(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Оператор возведения в степень</summary>
            <param name="x">Основание</param>
            <param name="y">Показатель степени</param>
            <returns>Выражение-степень, корень которого - узел степени. Поддеревья - корни выражений Основания и показателя степени</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Implicit(MathCore.MathParser.MathExpression)~MathCore.MathParser.ExpressionTrees.ExpressionTree">
            <summary>Оператор неявного приведения типов математического выражения к типу дерева выражения</summary>
            <param name="Expression">Математическое выражение</param>
            <returns>Дерево математического выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Implicit(MathCore.MathParser.ExpressionTrees.ExpressionTree)~MathCore.MathParser.MathExpression">
            <summary>Оператор неявного приведения типов дерева выражения к типу математического выражения</summary>
            <param name="Tree">Дерево математического выражения</param>
            <returns>Математическое выражение, содержащее указанное дерево</returns>
        </member>
        <member name="M:MathCore.MathParser.MathExpression.op_Implicit(MathCore.MathParser.MathExpression)~System.Func{System.Double}">
            <summary>Оператор неявного приведения типов математического выражения к типу делегата функции double Func(void)</summary>
            <param name="expr">Математическое выражения</param>
            <returns>Результат компиляции математического выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.NumberTerm">
            <summary>Числовой элемент математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.NumberTerm._IntValue">
            <summary>Численное значение элемента</summary>
        </member>
        <member name="P:MathCore.MathParser.NumberTerm.Value">
            <summary>Численное значение элемента</summary>
        </member>
        <member name="M:MathCore.MathParser.NumberTerm.#ctor(System.String)">
            <summary>Новый численный элемент мат.выражения</summary>
            <param name="Str">Строковое значение элемента</param>
        </member>
        <member name="M:MathCore.MathParser.NumberTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Извлечь поддерево</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел константного значения</returns>
        </member>
        <member name="M:MathCore.MathParser.NumberTerm.TryAddFractionPart(MathCore.MathParser.ExpressionTrees.Nodes.ExpressionTreeNode@,MathCore.MathParser.Term,System.Char,MathCore.MathParser.Term)">
            <summary>Попытаться добавить дробное значение числа</summary>
            <param name="node">Узел выражения</param>
            <param name="SeparatorTerm">Блок разделитель</param>
            <param name="DecimalSeparator">Блок с целой частью числа</param>
            <param name="FractionPartTerm">Блок с дробной частью числа</param>
            <returns>Истина, если действие совершено успешно. Ложь, если в последующих блоках не содержится нужной информации</returns>
        </member>
        <member name="T:MathCore.MathParser.StringTerm">
            <summary>Строковый элемент выражения</summary>
        </member>
        <member name="P:MathCore.MathParser.StringTerm.Name">
            <summary>Имя строкового элемента</summary>
        </member>
        <member name="M:MathCore.MathParser.StringTerm.#ctor(System.String)">
            <summary>Новый строковый элемент</summary>
            <param name="Name">Имя строкового элемента</param>
        </member>
        <member name="M:MathCore.MathParser.StringTerm.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Поддерево элемента, состоящее из узла-переменной</summary>
            <param name="Parser">Парсер</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел дерева с переменной, полученной из Expression.Variable[Name]</returns>
        </member>
        <member name="T:MathCore.MathParser.SumOperator">
            <summary>Оператор суммы</summary>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.#ctor">
            <summary>Инициализация нового оператора суммы</summary>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.#ctor(System.String)">
            <summary>Инициализация нового оператора суммы</summary>
            <param name="Name"></param>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.Initialize(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Инициализация оператора</summary>
            <param name="Parameters">Блок параметров</param>
            <param name="Function">Блок ядра функции</param>
            <param name="Parser">Парсер мат.выражения</param>
            <param name="Expression">Внешнее мат.выражение</param>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.GetValue(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Метод определения значения</summary>
            <returns>Численное значение элемента выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.SumOperator.SumDelegate">
            <summary>Метод суммирования</summary>
            <param name="d">Суммируемая функция - ядро</param>
            <param name="Min">Начало интервала</param>
            <param name="Max">Конец интервала</param>
            <param name="Parameters">Массив параметров функции</param>
            <returns>Значение суммы функции</returns>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.GetSum(System.Delegate,System.Double,System.Double,System.Double[])">
            <summary>Получение значения суммы</summary>
            <param name="d">Суммируемая функция - ядро</param>
            <param name="Min">Начало интервала суммирования</param>
            <param name="Max">Конец интервала суммирования</param>
            <param name="Parameters">Массив параметров</param>
            <returns>Сумма функции</returns>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression)">
            <summary>Скомпилировать в выражение</summary>
            <param name="ParametersExpression">Выражение блока параметров</param>
            <param name="Function">Выражение блока ядра оператора - функции</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="M:MathCore.MathParser.SumOperator.Compile(MathCore.MathParser.MathExpression,MathCore.MathParser.MathExpression,System.Linq.Expressions.ParameterExpression[])">
            <summary>Скомпилировать в выражение</summary>
            <param name="Function">Ядро функции</param>
            <param name="Parameters">Массив параметров</param>
            <param name="ParametersExpression">Выражение параметров</param>
            <returns>Скомпилированное выражение System.Linq.Expressions</returns>
        </member>
        <member name="T:MathCore.MathParser.Term">
            <summary>Элемент математического выражения</summary>
        </member>
        <member name="F:MathCore.MathParser.Term._Value">
            <summary>Строковое содержимое</summary>
        </member>
        <member name="M:MathCore.MathParser.Term.#ctor(System.String)">
            <summary>Конструктор элемента математического выражения</summary>
            <param name="Value">Строковое содержимое</param>
        </member>
        <member name="M:MathCore.MathParser.Term.GetSubTree(MathCore.MathParser.ExpressionParser,MathCore.MathParser.MathExpression)">
            <summary>Метод извлечения поддерева для данного элемента математического выражения</summary>
            <param name="Parser">Парсер математического выражения</param>
            <param name="Expression">Математическое выражение</param>
            <returns>Узел дерева мат.выражения, являющийся поддеревом для данного элемента мат.выражения</returns>
        </member>
        <member name="M:MathCore.MathParser.Term.ToString">
            <summary>Строковое представление элемента мат.выражения</summary>
            <returns>Строковое содержимое элемента мат.выражения</returns>
        </member>
        <member name="T:MathCore.MathParser.VariablesCollection">
            <summary>Коллекция переменных</summary>
        </member>
        <member name="F:MathCore.MathParser.VariablesCollection._Expression">
            <summary>Математическое выражение</summary>
        </member>
        <member name="P:MathCore.MathParser.VariablesCollection.Count">
            <summary>Количество переменных в коллекции</summary>
        </member>
        <member name="P:MathCore.MathParser.VariablesCollection.Item(System.String)">
            <summary>Итератор переменных коллекции</summary>
            <param name="Name">Имя переменной</param>
            <returns>Переменная с указанным именем</returns>
        </member>
        <member name="P:MathCore.MathParser.VariablesCollection.Item(System.Int32)">
            <summary>Итератор переменных коллекции</summary>
            <param name="i">Индекс переменной</param>
            <returns>Переменная с указанным индексом</returns>
        </member>
        <member name="P:MathCore.MathParser.VariablesCollection.Names">
            <summary>Перечисление всех имён переменных коллекции</summary>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.#ctor(MathCore.MathParser.MathExpression)">
            <summary>Инициализация новой коллекции переменных</summary>
            <param name="expression">Математическое выражение, которому принадлежит коллекция</param>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Add(MathCore.MathParser.ExpressionVariable)">
            <summary>Добавить переменную в коллекцию</summary>
            <param name="Variable">Переменная</param>
            <returns>Истина, если переменная была добавлена</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.MoveToConstCollection(System.String)">
            <summary>Переместить переменную из коллекции переменных в коллекцию констант</summary>
            <param name="Variable">Перемещаемая переменная</param>
            <returns>Истина, если переменная была перемещена из коллекции переменных в коллекцию констант</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.MoveToConstCollection(MathCore.MathParser.ExpressionVariable)">
            <summary>Переместить переменную из коллекции переменных в коллекцию констант</summary>
            <param name="Variable">Перемещаемая переменная</param>
            <returns>Истина, если переменная была перемещена из коллекции переменных в коллекцию констант</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Remove(MathCore.MathParser.ExpressionVariable)">
            <summary>Удаление переменной из коллекции</summary>
            <param name="Variable">Удаляемая переменная</param>
            <returns>Истина, если удаление прошло успешно</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.RemoveFromCollection(MathCore.MathParser.ExpressionVariable)">
            <summary>Удалить переменную из коллекции</summary>
            <param name="Variable">Удаляемая переменная</param>
            <returns>Истина, если переменная удалена успешно</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.ClearCollection">
            <summary>Очистить коллекцию переменных</summary>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Exist(System.String)">
            <summary>Существует ли в коллекции переменная с указанным именем</summary>
            <param name="Name">Искомое имя переменной</param>
            <returns>Истина, если в коллекции присутствует переменная с указанным именем</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Exist(MathCore.MathParser.ExpressionVariable)">
            <summary>Проверка на существование переменной в коллекции</summary>
            <param name="variable">Проверяемая переменная</param>
            <returns>Истина, если указанная переменная входит в коллекцию</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.Exist(System.Predicate{MathCore.MathParser.ExpressionVariable})">
            <summary>Существует ли переменная в коллекции с заданным критерием поиска</summary>
            <param name="exist">Критерий поиска переменной</param>
            <returns>Истина, если найдена переменная по указанному критерию</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.ExistInTree(System.String)">
            <summary>Существует ли узел переменной в дереве с указанным именем</summary>
            <param name="Name">Искомое имя переменной</param>
            <returns>Истина, если указанное имя переменной существует в дереве</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.ExistInTree(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Существует ли узел переменной в дереве</summary>
            <param name="exist">Критерий поиска</param>
            <returns>Истина, если найден узел по указанному критерию</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodes(System.String)">
            <summary>Получить перечисление узлов переменных с указанным именем</summary>
            <param name="VariableName">Искомое имя переменной</param>
            <returns>Перечисление узлов с переменными с указанным именем</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodes(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Получить перечисление узлов дерева с переменными</summary>
            <param name="selector">Метод выборки узлов</param>
            <returns>Перечисление узлов переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodesOf``1">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodesVOf``1(System.Func{``0,System.Boolean})">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <param name="selector">Метод выбора узлов по содержащимся в них переменным</param>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.GetTreeNodesOf``1(System.Func{MathCore.MathParser.ExpressionTrees.Nodes.VariableValueNode,System.Boolean})">
            <summary>Получить перечисление узлов дерева выражения, содержащих указанный тип переменных</summary>
            <typeparam name="TVariable">Тип переменной</typeparam>
            <param name="selector">Метод выбора узлов</param>
            <returns>Перечисление узлов дерева с указанным типом переменных</returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.System#Collections#Generic#IEnumerable{MathCore#MathParser#ExpressionVariable}#GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:MathCore.MathParser.VariablesCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="T:MathCore.Matrix">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки,<br/>
            j (второй индекс) - номер столбца<br/>
            +----------- j -------------><br/>
            | a11 a12 a13 a14 a15 a16 a1M<br/>
            | a21........................<br/>
            | a31........................<br/>
            | a41.......aij..............<br/>
            i a51........................<br/>
            | a61........................<br/>
            | aN1.....................aNM<br/>
            \/
            </remarks>
        </member>
        <member name="T:MathCore.Matrix.Array">
            <summary>Операции над двумерными массивами</summary>
        </member>
        <member name="M:MathCore.Matrix.Array.MatrixToColsArray(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-столбцов</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.MatrixToRowsArray(System.Double[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-строк</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.ColsArrayToMatrix(System.Double[][])">
            <summary>Создать двумерный массив массив матрицы из массива столбцов</summary>
            <param name="cols">Массив столбцов матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="cols"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.RowsArrayToMatrix(System.Double[][])">
            <summary>Создать двумерный массив массив матрицы из массива строк</summary>
            <param name="rows">Массив строк матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rows"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.IsMatrixSingular(System.Double[0:,0:])">
            <summary>Проверка - является ли матрица вырожденной</summary>
            <param name="matrix">Проверяемая матрица</param>
            <returns>Истина, если определитель матрицы равен нулю</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов, или если матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Rank(System.Double[0:,0:])">
            <summary>Определение ранга матрицы</summary>
            <param name="matrix">Матрица, ранг которой требуется определить</param>
            <returns>Ранг матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CreateDiagonal(System.Double[])">
            <summary>Создать диагональную матрицу</summary>
            <param name="elements">Элементы диагонали матрицы</param>
            <returns>Двумерный массив, содержащий на главной диагонали элементы диагональной матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="elements"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMatrixShadow(System.Double[0:,0:])">
            <summary>Получить массив элементов тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Массив элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.EnumerateMatrixShadow(System.Double[0:,0:])">
            <summary>Перечислить элементы тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Перечисление элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Permutation_Left(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Permutation_Right(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Permutation_Left_Internal(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Permutation_Right_Internal(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CreateMatrix(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Double})">
            <summary>Создать и инициализировать двумерный массив-матрицу</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="Creator">Функция, принимающая номер строки и номер столбца и возвращающая значение элемента матрицы</param>
            <returns>Массив элементов матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.CreateColArray(System.Double[])">
            <summary>Создать двумерный массив элементов матрицы-столбца</summary>
            <param name="data">Элементы массива матрицы-столбца</param>
            <returns>Двумерный массив элементов матрицы столбца</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CreateRowArray(System.Double[])">
            <summary>Создать двумерный массив элементов матрицы-строки</summary>
            <param name="data">Элементы массива матрицы-строки</param>
            <returns>Двумерный массив элементов матрицы строки</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLength(System.Double[0:,0:],System.Int32@,System.Int32@,System.String)">
            <summary>Получить размерность массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матрицы</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetSquareLength(System.Double[0:,0:],System.String)">
            <summary>Определение размера квадратной матрицы</summary>
            <param name="matrix">Квадратная матрица, размер которой надо определить</param>
            <returns>Возвращает число строк матрицы</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на массив</exception>
            <exception cref="T:System.InvalidOperationException">Если матрица не является квадратной</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRowsCount(System.Double[0:,0:],System.Int32@,System.String)">
            <summary>Получить число строк массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матрицы</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetColsCount(System.Double[0:,0:],System.Int32@,System.String)">
            <summary>Получить число столбцов (элементов строки) массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetUnitaryArrayMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="N"/> меньше 1</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.InitializeUnitaryMatrix(System.Double[0:,0:])">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTransvection(System.Double[0:,0:],System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="i0">Опорная строка</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорная строка <paramref name="i0"/> матрицы <paramref name="A"/> &lt; 0 и &gt; числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Transvection(System.Double[0:,0:],System.Int32,System.Double[0:,0:])">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j0">Опорный столбец</param>
            <param name="result">Двумерный массив элементов матрицы результата</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрицы <paramref name="A"/> и <paramref name="result"/> не заданы</exception>  
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорный столбец <paramref name="j0"/> матрицы <paramref name="A"/> меньше 0 или больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentException">В случае если размер матрицы <paramref name="result"/> не совпадает с размером матрицы <paramref name="A"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetCol(System.Double[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Матрица-столбец, составленная из элементов столбца матрицы c индексом j</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetCol_Array(System.Double[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде массива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetCol_Array(System.Double[0:,0:],System.Int32,System.Double[])">
            <summary>Получить столбец матрицы в виде массива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <param name="result">Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу строк матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRow(System.Double[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Матрица-строка, составленная из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRow_Array(System.Double[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Массив, составленный из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRow_Array(System.Double[0:,0:],System.Int32,System.Double[])">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <param name="result">Массив, составленный из элементов строки матрицы с индексом i</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу столбцов матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Inverse(System.Double[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаемая матрица</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Inverse(System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаемая матрица</param>
            <param name="p">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Размерность массива 0х0</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Inverse(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Матрица, подлежащая обращению</param>
            <param name="result">Обратная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetSolve(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>Метод решения СЛАУ A*X=B -&gt; X</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <returns>Матрица решения уравнения A*X=B -&gt; X</returns>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Solve(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Boolean)">
            <summary>Метод решения СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.TrySolve(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Boolean)">
            <summary>Попытаться решить СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <returns>Истина, если решение СЛАУ получено; ложь - если матрица СЛАУ <paramref name="matrix"/> вырождена</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Transpose(System.Double[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Transpose(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <param name="matrix">Исходная матрица</param>
            <param name="result">Транспонированная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetAdjunct(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CopyMinor(System.Double[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,System.Double[0:,0:])">
            <summary>Скопировать минор из матрицы в матрицу результата</summary>
            <param name="matrix">Массив элементов исходной матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="result">Минор матрицы</param>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMinor(System.Double[0:,0:],System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <returns>Минор элемента матрицы [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMinor(System.Double[0:,0:],System.Int32,System.Int32,System.Double[0:,0:])">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="result">Минор элемента матрицы [n,m]</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число строк матрицы результата <paramref name="result"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов матрицы результата <paramref name="result"/> не равно числу столбцов исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetDeterminant(System.Double[0:,0:])">
            <summary>Определитель матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Определитель матрицы</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Swap``1(``0@,``0@)">
            <summary>Поменять значения местами</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхне-треугольная матрица</param>
            <param name="p">Матрица преобразований P*X = L*U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="matrix"/> меньше 1</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхне-треугольная матрица</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы N меньше 1</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="p">Массив матрицы перестановок</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если операция выполнена успешно</returns>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUPDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура выполнена успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetLUDecomposition(System.Double[0:,0:],System.Double[0:,0:]@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <returns>Истина, если разложение выполнено успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.CreatePermutationMatrix(System.Int32[])">
            <summary>Создать матрицу перестановок из массива индексов</summary>
            <param name="indexes">Массив индексов элементов столбцов</param>
            <returns>Матрица перестановок</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:]@,System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:],System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetTriangle(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@,System.Int32@,System.Double@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="clone_b">Клонировать матрицу правых частей</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double[0:,0:]@,System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:],System.Double[0:,0:],System.Double@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:]@,System.Double[0:,0:],System.Double@,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <param name="clone">Клонировать исходную матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Triangulate(System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double@,System.Boolean,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <param name="clone_matrix">Клонировать исходную матрицу</param>
            <param name="clone_b">Клонировать присоединённую матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.AreEquals(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <returns>Истина, если оба массивы не определены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.AreEquals(System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <param name="eps">Точность сравнения</param>
            <returns>Истина, если оба массивы не определены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMaxRowAbsSum(System.Double[0:,0:])">
            <summary>Вычисление максимума от сумм абсолютных значений по элементам строк</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetMaxColAbsSum(System.Double[0:,0:])">
            <summary>Вычисление максимума от сумм абсолютных значений по элементам столбцов</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.GetRMS(System.Double[0:,0:])">
            <summary>Вычисление среднеквадратичного значения элементов матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Среднеквадратичное значение элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Sqr(System.Double)">
            <summary>Квадрат числа</summary>
            <param name="x">Значение, квадрат которого требуется получить</param>
            <returns>Квадрат указанного числа</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.GaussSeidelConverge(System.Double[0:,0:]@,System.Double[0:,0:]@,System.Double,System.Int32,System.Int32)">
            <summary>Метод проверки сходимости метода Метод Гаусса — Зейделя</summary>
            <remarks>Метод меняет местами матрицы решения текущего и прошлого шагов, если метод Гаусса — Зейделя не сошёлся на текущем шаге</remarks>
            <param name="new_x">Новое полученное решение</param>
            <param name="last_x">Решение, полученное на прошлом шаге метода</param>
            <param name="eps">Требуемая точность решения</param>
            <param name="N">Число строк матрицы решения</param>
            <param name="M">Число столбцов матрицы решения</param>
            <returns>Истина, если метод сошёлся Метод Гаусса — Зейделя</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.GaussSeidelSolve(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:],System.Double)">
            <summary>Метод Гаусса — Зейделя решения системы линейных уравнений</summary>
            <param name="matrix">Матрица коэффициентов</param>
            <param name="x">Матрица неизвестных</param>
            <param name="b">Матрица правых частей</param>
            <param name="eps">Требуемая точность</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица системы не содержит элементов</exception>
            <exception cref="T:System.ArgumentException">Матрица системы не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк массива неизвестных не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число строк массива правой части СЛАУ не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число столбцов массива правых частей не совпадает с числом столбцов массива неизвестных</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="eps"/> &lt;= <see cref="T:System.Double"/>.<see cref="F:System.Double.Epsilon"/></exception> Solve
        </member>
        <member name="M:MathCore.Matrix.Array.QRDecomposition(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - должна быть передана квадратная матрица nxn != null</param>
            <param name="r">Верхне-треугольная матрица - должна быть передана квадратная матрица nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.QRDecomposition(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[0:,0:]@)">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - создаётся квадратная матрица nxn != null</param>
            <param name="r">Верхне-треугольная матрица - создаётся квадратная матрица nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.SVD(System.Double[0:,0:],System.Double[0:,0:]@,System.Double[]@,System.Double[0:,0:]@)">
            <summary>SVD-разложение</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="u">Матрица левых сингулярных векторов</param>
            <param name="w">Вектор собственных чисел</param>
            <param name="v">Матрица правых сингулярных векторов</param>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Метод не сошёлся за 30 итераций</exception>
        </member>
        <member name="T:MathCore.Matrix.Array.Operator">
            <summary>Операторы над двумерными массивами</summary>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[],System.Double[])">
            <summary>Скалярное произведение векторов</summary>
            <param name="v1">Первый множитель скалярного произведения</param>
            <param name="v2">второй множитель скалярного произведения</param>
            <returns>Скалярное произведение векторов</returns>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.VectorLength(System.Double[])">
            <summary>Длина вектора</summary>
            <param name="v">Вектор элементов</param>
            <returns>Длина вектора</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[],System.Double)">
            <summary>Умножение вектора на число</summary>
            <param name="v1">Первый сомножитель - вектор элементов</param>
            <param name="v2">Второй сомножитель - число, на которое должны быть умножены все элементы вектора</param>
            <returns>Вектор произведений элементов входного вектора и числа</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Divide(System.Double[],System.Double)">
            <summary>Деление вектора элементов на число</summary>
            <param name="v1">Вектор-делимое</param>
            <param name="v2">Число-делитель</param>
            <returns>Вектор, составленный из частного элементов вектора-делимого и числового делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Projection(System.Double[],System.Double[])">
            <summary>Проекция вектора на вектор</summary>
            <returns>Вектор - произведение компонентов исходных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> or <paramref name="v2"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Длины векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Add(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления суммы двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив суммы элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Add(System.Double[],System.Double[])">
            <summary>Поэлементное сложение двух матриц</summary>
            <param name="a">Матрица - первое слагаемое</param>
            <param name="b">Матрица - второе слагаемое</param>
            <returns>Матрица, составленная из элементов - сумм элементов исходных матриц</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Subtract(System.Double[],System.Double[])">
            <summary>Оператор вычитания между двумя столбцами</summary>
            <param name="a">Столбец уменьшаемого</param>
            <param name="b">Столбец вычитаемого</param>
            <returns>Вектор-столбец разности указанных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyElements(System.Double[],System.Double[])">
            <summary>Оператор вычисления поэлементного произведения двух векторов</summary>
            <param name="a">Вектор элементов первого множителя</param>
            <param name="b">Вектор элементов второго множителя</param>
            <returns>Вектор элементов произведения</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.DivideElements(System.Double[],System.Double[])">
            <summary>Оператор вычисления поэлементного деления двух векторов</summary>
            <param name="a">Вектор - делимое</param>
            <param name="b">Вектор - делитель</param>
            <returns>Вектор, составленный из поэлементного частного элементов векторов делимого и делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Subtract(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Subtract(System.Double,System.Double[0:,0:])">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Divide(System.Double[0:,0:],System.Double)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Divide(System.Double,System.Double[0:,0:])">
            <summary>Оператор вычисления частного двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив частного элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Add(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления суммы элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив суммы элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Subtract(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления разности элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив разности элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyCol(System.Double[0:,0:],System.Double[])">
            <summary>Оператор вычисления произведения элементов матрицы на столбец</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="col">Массив элементов столбца</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и столбца не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyRow(System.Double[],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения элементов строки и матрицы</summary>
            <param name="B">Массив элементов первой матрицы</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и строки не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyRowToCol(System.Double[],System.Double[])">
            <summary>Оператор вычисления произведения элементов строки и элементов столбца</summary>
            <param name="col">Массив элементов столбца</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов строки и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности строки и столбца не равны</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив произведения двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyAtB(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц (первая - транспонированная)</summary>
            <param name="At">Массив элементов первой матрицы (транспонированной)</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив произведения двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="At"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.MultiplyABt(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="Bt">Массив элементов второй матрицы</param>
            <returns>Массив произведения двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="Bt"/> не определена</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Multiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <param name="result">Массив элементов произведения</param>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="result"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц не согласованы</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк <paramref name="result"/> не равно числу строк <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов <paramref name="result"/> не равно числу строк <paramref name="B"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Divide(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц не согласованы</exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.Concatenate(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Объединение матриц по строкам, либо столбцам</summary>
            <returns>Двумерный массив, содержащий объединение элементов исходных массивов по строкам, либо столбцам</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.BiliniarMultiply(System.Double[],System.Double[0:,0:],System.Double[])">
            <summary>Оператор вычисления билинейной формы с векторными операндами b = <paramref name="x"/>*<paramref name="A"/>*<paramref name="y"/></summary>
            <param name="x">Массив компонент левой строки билинейной формы</param>
            <param name="A">Матрица билинейной формы</param>
            <param name="y">Массив компонент правого столбца билинейной формы</param>
            <returns>Результат вычисления билинейной формы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="y"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Если длина строки <paramref name="x"/> не равна числу строк матрицы <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">Если длина столбца <paramref name="y"/> не равна числу столбцов матрицы <paramref name="A"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.BiliniarMultiply(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вычисления билинейной формы с векторными операндами b = <paramref name="x"/>*<paramref name="a"/>*<paramref name="y"/></summary>
            <param name="x">Двумерный массив компонент матрицы первого операнда билинейной формы</param>
            <param name="a">Двумерный массив компонент матрицы оператора билинейной нормы</param>
            <param name="y">Двумерный массив компонент матрицы второго операнда билинейной формы</param>
            <returns>
            Двумерный массив компонент матрицы результата вычисления билинейной формы, 
            число строк которого равно числу строк операнда <paramref name="x"/>, число столбцов - равно числу столбцов операнда <paramref name="y"/>
            </returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="y"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Число столбцов <paramref name="x"/> не равно числу строк <paramref name="a"/></exception>
            <exception cref="T:System.ArgumentException">Число строк <paramref name="y"/> не равно числу столбцов <paramref name="a"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.BiliniarMultiplyAuto(System.Double[],System.Double[0:,0:])">
            <summary>Вычисление оператора билинейной формы для одного операнда B = X*A*X^T</summary>
            <param name="x">Элементы массива вектора операнда оператора билинейной формы</param>
            <param name="a">Элементы двумерного массива матрицы оператора билинейной формы (должна быть квадратной с числом строк, равным числу элементов вектора операнда <paramref name="x"/>)</param>
            <returns>Численное значение результата вычисления билинейной формы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Если массив элементов матрицы <paramref name="a"/> не квадратный</exception>
            <exception cref="T:System.ArgumentException">Если число элементов вектора <paramref name="x"/> не равно числу строк массива элементов матрицы <paramref name="a"/></exception>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.AXAt(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вида Y = A * X * A^T</summary>
        </member>
        <member name="M:MathCore.Matrix.Array.Operator.AXAt(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>Оператор вида Y = A * X * A^T</summary>
        </member>
        <member name="M:MathCore.Matrix.SVD(MathCore.Matrix@,System.Double[]@,MathCore.Matrix@)">
            <summary>SVD-разложение матрицы</summary>
            <param name="U"></param>
            <param name="w"></param>
            <param name="V"></param>
        </member>
        <member name="M:MathCore.Matrix.SVD(MathCore.Matrix@,MathCore.Matrix@,MathCore.Matrix@)">
            <summary>SVD-разложение матрицы</summary>
            <param name="U"></param>
            <param name="S"></param>
            <param name="V"></param>
        </member>
        <member name="M:MathCore.Matrix.op_Explicit(MathCore.Matrix)~MathCore.MatrixInt">
            <summary>Оператор явного приведения вещественной матрицы к целочисленной</summary>
            <param name="matrix">Вещественная матрица</param>
        </member>
        <member name="M:MathCore.Matrix.CreateCol(System.Double[])">
            <summary>Создать матрицу-столбец</summary><param name="data">Элементы столбца</param><returns>Матрица-столбец</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.Matrix.CreateRow(System.Double[])">
            <summary>Создать матрицу-строку</summary><param name="data">Элементы строки</param><returns>Матрица-строка</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.Matrix.CreateDiagonal(System.Double[])">
            <summary>Создать диагональную матрицу</summary><param name="elements">Элементы диагональной матрицы</param>
            <returns>Диагональная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetUnitary(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param><returns>Единичная матрица размерности NxN с 1 на главной диагонали</returns>
        </member>
        <member name="M:MathCore.Matrix.GetTransvection(MathCore.Matrix,System.Int32)">
            <summary>Трансвекция матрицы</summary><param name="A">Трансвецируемая матрица</param><param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.Matrix._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.Matrix._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.Matrix._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.Matrix.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.Matrix.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.Matrix.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.Matrix.Item(System.Int32)">
            <summary>Вектор-столбец</summary><param name="j">Номер столбца</param><returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.Matrix.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.Matrix.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.Matrix.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.Matrix.IsScalar">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:MathCore.Matrix.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="P:MathCore.Matrix.Norm_m">
            <summary>Максимум среди абсолютных сумм элементов строк</summary>
        </member>
        <member name="P:MathCore.Matrix.Norm_l">
            <summary>Максимум среди абсолютных сумм элементов столбцов</summary>
        </member>
        <member name="P:MathCore.Matrix.Norm_k">
            <summary>Среднеквадратичное значение элементов матрицы</summary>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N"/> &lt; 0 || <paramref name="M"/> &lt; 0</exception>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary><param name="N">Размерность</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N" /> &lt; 0</exception>
        </member>
        <member name="T:MathCore.Matrix.MatrixItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param><param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32,MathCore.Matrix.MatrixItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32,System.Int32,MathCore.Matrix.MatrixItemCreator)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Int32[0:,0:])">
            <summary>Инициализация новой матрицы по двумерному массиву её элементов</summary>
            <param name="Data">Двумерный массив элементов матрицы</param>
            <param name="clone">Создать копию данных</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Double[0:,0:],System.Boolean)">
            <summary>Инициализация новой матрицы по двумерному массиву её элементов</summary>
            <param name="Data">Двумерный массив элементов матрицы</param>
            <param name="clone">Создать копию данных</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Collections.Generic.IList{System.Double},System.Boolean)">
            <summary>Инициализация новой матрицы - столбца/строки</summary>
            <param name="DataCol">Элементы столбца матрицы</param>
            <param name="IsColumn">Создаётся матрица-столбец</param>
        </member>
        <member name="M:MathCore.Matrix.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Double}})">
            <summary>Инициализация новой матрицы на основе перечисления строк (перечисления элементов строк) </summary>
            <param name="Items">Перечисление строк, состоящих из перечисления элементов строк</param>
        </member>
        <member name="M:MathCore.Matrix.GetElements(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{System.Double}})">
            <summary>Получить двумерный массив элементов матрицы</summary>
            <param name="ColsItems">Перечисление элементов (по столбцам)</param>
            <returns>Двумерный массив элементов матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.Matrix.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.Matrix.GetTriangle(MathCore.Matrix@,System.Int32@,System.Double@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="D">Определитель</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetTriangle(MathCore.Matrix@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="B">Присоединённая матрица правой части СЛАУ</param>
            <param name="CloneB">Работать с клоном матрицы <paramref name="B"/></param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="B"/> <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.Matrix.GetTriangle(MathCore.Matrix@,MathCore.Matrix@,System.Int32@,System.Double@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="B">Матрица правой части СЛАУ</param>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="CloneB">Клонировать матрицу правой части</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetInverse(MathCore.Matrix@)">
            <summary>Получить обратную матрицу</summary>                                                     
            <param name="P">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.Matrix.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.Matrix.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.Matrix.GetLUDecomposition(MathCore.Matrix@,MathCore.Matrix@,MathCore.Matrix@,System.Double@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <param name="L">Нижне-треугольная матрица</param>
            <param name="U">Верхне-треугольная матрица</param>
            <param name="P">Матрица преобразований P*X = L*U</param>
            <param name="D">Знак определителя</param>
            <returns>Истина, если разложение выполнено успешно, ложь - если матрица вырожденная</returns>
        </member>
        <member name="M:MathCore.Matrix.GetData">
            <summary>Получить внутренний массив элементов матрицы</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.Matrix.ToString">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.ToStringFormat(System.String,System.String,System.IFormatProvider)">
            <summary>Преобразование матрицы в строку с форматированием</summary>
            <param name="Format">Строка формата вывода чисел</param>
            <param name="Splitter">Разделитель элементов матрицы</param>
            <param name="provider">Механизм форматирования чисел матрицы</param>
            <returns>Строковое представление матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.MathCore#ICloneable{System#Double[,]}#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.op_Equality(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор равенства двух матриц</summary>
            <returns>Истина, если матрицы совпадают по размеру и поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Inequality(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор неравенства двух матриц</summary>
            <returns>Истина, если матрицы не совпадают по размеру или поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Equality(System.Double[0:,0:],MathCore.Matrix)">
            <summary>Оператор равенства матрицы и двумерного массива</summary>
            <returns>Истина, если матрица и двумерный массив совпадают по размеру и поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Equality(MathCore.Matrix,System.Double[0:,0:])">
            <summary>Оператор равенства матрицы и двумерного массива</summary>
            <returns>Истина, если матрица и двумерный массив совпадают по размеру и поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Inequality(System.Double[0:,0:],MathCore.Matrix)">
            <summary>Оператор неравенства матрицы и двумерного массива</summary>
            <returns>Истина, если матрица и двумерный массив не совпадают по размеру или поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Inequality(MathCore.Matrix,System.Double[0:,0:])">
            <summary>Оператор неравенства матрицы и двумерного массива</summary>
            <returns>Истина, если матрица и двумерный массив не совпадают по размеру или поэлементно</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Addition(MathCore.Matrix,System.Double)">
            <summary>Оператор суммы матрицы и числа</summary>
            <returns>Матрица, элементы которой равны сумме элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Addition(System.Double,MathCore.Matrix)">
            <summary>Оператор суммы матрицы и числа</summary>
            <returns>Матрица, элементы которой равны сумме элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Subtraction(MathCore.Matrix,System.Double)">
            <summary>Оператор разности матрицы и числа</summary>
            <returns>Матрица, элементы которой равны разности элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_UnaryNegation(MathCore.Matrix)">
            <summary>Оператор отрицания элементов матрицы</summary>
            <returns>Матрица, элементы которой являются отрицательными по отношению к элементам исходной матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Subtraction(System.Double,MathCore.Matrix)">
            <summary>Оператор разности числа и матрицы</summary>
            <returns>Матрица, элементы которой равны разности числа и элементов исходной матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(MathCore.Matrix,System.Double)">
            <summary>Оператор произведения матрицы и числа</summary>
            <returns>Матрица, элементы которой равны произведения элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(System.Double,MathCore.Matrix)">
            <summary>Оператор суммы матрицы и числа</summary>
            <returns>Матрица, элементы которой равны сумме элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(System.Double[0:,0:],MathCore.Matrix)">
            <summary>Оператор матричного произведения двумерного массива и матрицы</summary>
            <returns>Матрица - результат матричного умножения двухмерного массива и матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(System.Double[],MathCore.Matrix)">
            <summary>Оператор матричного произведения одномерного массива (строки) и матрицы</summary>
            <returns>Матрица - результат матричного умножения одномерного массива (строки) и матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(MathCore.Matrix,System.Double[])">
            <summary>Оператор матричного произведения матрицы и одномерного массива (столбца)</summary>
            <returns>Матрица - результат матричного умножения матрицы и одномерного массива (столбца)</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(MathCore.Matrix,System.Double[0:,0:])">
            <summary>Оператор матричного произведения матрицы и двумерного массива</summary>
            <returns>Матрица - результат матричного умножения матрицы и двумерного массива</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Division(MathCore.Matrix,System.Double)">
            <summary>Оператор деления матрицы и числа</summary>
            <returns>Матрица, элементы которой равны результату деления элементов исходной матрицы и числа</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Division(System.Double,MathCore.Matrix)">
            <summary>Оператор деления числа и матрицы</summary>
            <returns>Матрица, элементы которой равны результату деления числа и элементов исходной матрицы</returns>
        </member>
        <member name="M:MathCore.Matrix.op_ExclusiveOr(MathCore.Matrix,System.Int32)">
            <summary>Оператор возведения матрицы в степень</summary>
            <param name="M">Матрица - основание</param>
            <param name="n">Показатель степени</param>
            <returns>Матрица - результат возведения исходной матрицы в целую степень</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Addition(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param><param name="B">Второе слагаемое</param><returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Subtraction(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param><param name="B">Вычитаемое</param><returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Multiply(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param><param name="B">Второй сомножитель</param><returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Division(MathCore.Matrix,MathCore.Matrix)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param><param name="B">Делитель</param><returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.Matrix.op_BitwiseOr(MathCore.Matrix,MathCore.Matrix)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param><param name="B">Второе слагаемое</param><returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Implicit(System.Double)~MathCore.Matrix">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.Matrix.op_Explicit(MathCore.Matrix)~System.Double[0:,0:]">
            <summary>Оператор явного приведения матрицы к двумерному массиву</summary>
            <param name="M">Исходная матрица</param>
        </member>
        <member name="M:MathCore.Matrix.op_Explicit(System.Double[0:,0:])~MathCore.Matrix">
            <summary>Оператор явного приведения типа двумерного массива к матрице</summary>
            <param name="Data">Двумерный массив</param>
        </member>
        <member name="M:MathCore.Matrix.op_Explicit(System.Double[])~MathCore.Matrix">
            <summary>Оператор явного приведения одномерного массива к матрице (столбцу)</summary>
            <param name="Data">Одномерный массив</param>
        </member>
        <member name="M:MathCore.Matrix.Equals(System.Double[0:,0:])">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.Equals(MathCore.Matrix)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.Matrix.ToMatrixArray">
            <summary>Преобразовать в матрицу на линейном массиве</summary>
            <returns>Матрица на линейном массиве</returns>
        </member>
        <member name="M:MathCore.Matrix.FomMatrixArray(MathCore.MatrixArray)">
            <summary>Создать на основе матрицы на линейном массиве</summary>
            <param name="matrix">Матрица на линейном массиве</param>
            <returns>Матрица на двумерном массиве</returns>
        </member>
        <member name="T:MathCore.MatrixComplex">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки, 
            j (второй индекс) - номер столбца
            ------------ j ---------->
            | a11 a12 a13 a14 a15 a16 a1M
            | a21........................
            | a31........................
            | a41.......aij..............
            i a51........................
            | a61........................
            | aN1.....................aNM
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixComplex.CreateCol(MathCore.Complex[])">
            <summary>Создать матрицу-столбец</summary><param name="data">Элементы столбца</param><returns>Матрица-столбец</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.CreateRow(MathCore.Complex[])">
            <summary>Создать матрицу-строку</summary><param name="data">Элементы строки</param><returns>Матрица-строка</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.CreateDiagonalMatrixComplex(MathCore.Complex[])">
            <summary>Создать диагональную матрицу</summary><param name="elements">Элементы диагональной матрицы</param>
            <returns>Диагональная матрица</returns>
        </member>
        <member name="T:MathCore.MatrixComplex.Array">
            <summary>Операции над двумерными массивами</summary>
        </member>
        <member name="T:MathCore.MatrixComplex.Array.Operator">
            <summary>Операторы над двумерными массивами</summary>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[],MathCore.Complex[])">
            <summary>Скалярное произведение векторов</summary>
            <param name="v1">Первый множитель скалярного произведения</param>
            <param name="v2">второй множитель скалярного произведения</param>
            <returns>Скалярное произведение векторов</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.VectorLength(MathCore.Complex[])">
            <summary>Длина вектора</summary>
            <param name="v">Вектор элементов</param>
            <returns>Длина вектора</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[],MathCore.Complex)">
            <summary>Умножение вектора на число</summary>
            <param name="v1">Первый сомножитель - вектор элементов</param>
            <param name="v2">Второй сомножитель - число, на которое должны быть умножены все элементы вектора</param>
            <returns>Вектор произведений элементов входного вектора и числа</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Divide(MathCore.Complex[],MathCore.Complex)">
            <summary>Деление вектора элементов на число</summary>
            <param name="v1">Вектор-делимое</param>
            <param name="v2">Число-делитель</param>
            <returns>Вектор, составленный из частного элементов вектора-делимого и числового делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Projection(MathCore.Complex[],MathCore.Complex[])">
            <summary>Проекция вектора на вектор</summary>
            <returns>Вектор - произведение компонентов исходных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="v1"/> or <paramref name="v2"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Длины векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Add(MathCore.Complex[0:,0:],MathCore.Complex)">
            <summary>Оператор вычисления суммы двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив суммы элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Add(MathCore.Complex[],MathCore.Complex[])">
            <summary>Поэлементное сложение двух матриц</summary>
            <param name="a">Матрица - первое слагаемое</param>
            <param name="b">Матрица - второе слагаемое</param>
            <returns>Матрица, составленная из элементов - сумм элементов исходных матриц</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Subtract(MathCore.Complex[],MathCore.Complex[])">
            <summary>Оператор вычитания между двумя столбцами</summary>
            <param name="a">Столбец уменьшаемого</param>
            <param name="b">Столбец вычитаемого</param>
            <returns>Вектор-столбец разности указанных векторов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.MultiplyComponent(MathCore.Complex[],MathCore.Complex[])">
            <summary>Оператор вычисления поэлементного произведения двух векторов</summary>
            <param name="a">Вектор элементов первого множителя</param>
            <param name="b">Вектор элементов второго множителя</param>
            <returns>Вектор элементов произведения</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Размеры векторов не совпадают</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.DivideComponent(MathCore.Complex[],MathCore.Complex[])">
            <summary>Оператор вычисления поэлементного деления двух векторов</summary>
            <param name="a">Вектор - делимое</param>
            <param name="b">Вектор - делитель</param>
            <returns>Вектор, составленный из поэлементного частного элементов векторов делимого и делителя</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="a"/> or <paramref name="b"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Subtract(MathCore.Complex[0:,0:],MathCore.Complex)">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Subtract(MathCore.Complex,MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления разности двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив разности элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[0:,0:],MathCore.Complex)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Divide(MathCore.Complex[0:,0:],MathCore.Complex)">
            <summary>Оператор вычисления произведения двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив произведения элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Divide(MathCore.Complex,MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления частного двумерного массива элементов матрицы с числом</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="x">Число</param>
            <returns>Массив частного элементов матрицы с числом</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="matrix"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Add(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления суммы элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив суммы элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Subtract(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления разности элементов двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив разности элементов двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.MultiplyCol(MathCore.Complex[0:,0:],MathCore.Complex[])">
            <summary>Оператор вычисления произведения элементов матрицы на столбец</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="col">Массив элементов столбца</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и столбца не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.MultiplyRow(MathCore.Complex[],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления произведения элементов строки и матрицы</summary>
            <param name="B">Массив элементов первой матрицы</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов матрицы и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матрицы и строки не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.MultiplyRowToCol(MathCore.Complex[],MathCore.Complex[])">
            <summary>Оператор вычисления произведения элементов строки и элементов столбца</summary>
            <param name="col">Массив элементов столбца</param>
            <param name="row">Массив элементов строки</param>
            <returns>Массив произведения элементов строки и столбца</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="col"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="row"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности строки и столбца не равны</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <returns>Массив произведения двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Multiply(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор вычисления произведения двух матриц</summary>
            <param name="A">Массив элементов первой матрицы</param>
            <param name="B">Массив элементов второй матрицы</param>
            <param name="result">Массив элементов произведения</param>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="result"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц не согласованы</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк <paramref name="result"/> не равно числу строк <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов <paramref name="result"/> не равно числу строк <paramref name="B"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Divide(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="A"/> не определена</exception>
            <exception cref="T:System.ArgumentNullException">В случае если <paramref name="B"/> не определена</exception>
            <exception cref="T:System.ArgumentException">В случае если размерности матриц не согласованы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Operator.Concatenate(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Объединение матриц по строкам, либо столбцам</summary>
            <returns>Двумерный массив, содержащий объединение элементов исходных массивов по строкам, либо столбцам</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="A"/> or <paramref name="B"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.MatrixToColsArray(MathCore.Complex[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-столбцов</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.MatrixToRowsArray(MathCore.Complex[0:,0:])">
            <summary>Преобразовать двумерный массив элементов матрицы в массив массивов-строк</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Массив строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.ColsArrayToMatrix(MathCore.Complex[][])">
            <summary>Создать двумерный массив массив матрицы из массива столбцов</summary>
            <param name="cols">Массив столбцов матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="cols"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.RowsArrayToMatrix(MathCore.Complex[][])">
            <summary>Создать двумерный массив массив матрицы из массива строк</summary>
            <param name="rows">Массив строк матрицы</param>
            <returns>Двумерный массив элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="rows"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.IsMatrixSingular(MathCore.Complex[0:,0:])">
            <summary>Проверка - является ли матрица вырожденной</summary>
            <param name="matrix">Проверяемая матрица</param>
            <returns>Истина, если определитель матрицы равен нулю</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов, или если матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Determinant(MathCore.Complex[0:,0:])">
            <summary>Вычисление определителя матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Значение определителя матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Rank(MathCore.Complex[0:,0:])">
            <summary>Определение ранга матрицы</summary>
            <param name="matrix">Матрица, ранг которой требуется определить</param>
            <returns>Ранг матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CreateDiagonal(MathCore.Complex[])">
            <summary>Создать диагональную матрицу</summary>
            <param name="elements">Элементы диагонали матрицы</param>
            <returns>Двумерный массив, содержащий на главной диагонали элементы диагональной матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="elements"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMatrixShadow(MathCore.Complex[0:,0:])">
            <summary>Получить массив элементов тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Массив элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.EnumerateMatrixShadow(MathCore.Complex[0:,0:])">
            <summary>Перечислить элементы тени (главной диагонали) матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Перечисление элементов тени матрицы</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Массив не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Permutation_Left(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Permutation_Right(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов)</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="p"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица перестановок не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк матрицы не равно числу столбцов матрицы перестановок</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Permutation_Left_Internal(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Применение матрицы перестановок слева (перестановка строк) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке строк</param>
            <param name="p">Матрица перестановок (строк)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Permutation_Right_Internal(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Применение матрицы перестановок справа (перестановка столбцов) без проверок</summary>
            <param name="matrix">Матрица, подвергаемая перестановке столбцов</param>
            <param name="p">Матрица перестановок (столбцов)</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="p"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CreateColArray(MathCore.Complex[])">
            <summary>Создать двумерный массив элементов матрицы-столбца</summary>
            <param name="data">Элементы массива матрицы-столбца</param>
            <returns>Двумерный массив элементов матрицы столбца</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CreateRowArray(MathCore.Complex[])">
            <summary>Создать двумерный массив элементов матрицы-строки</summary>
            <param name="data">Элементы массива матрицы-строки</param>
            <returns>Двумерный массив элементов матрицы строки</returns>
            <exception cref="T:System.ArgumentNullException">Если массив <paramref name="data"/> не определён</exception>
            <exception cref="T:System.ArgumentException">Если массив <paramref name="data"/> имеет длину 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLength(MathCore.Complex[0:,0:],System.Int32@,System.Int32@)">
            <summary>Получить размерность массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матрицы</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRowsCount(MathCore.Complex[0:,0:],System.Int32@)">
            <summary>Получить число строк массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="N">Число строк матрицы</param>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetColsCount(MathCore.Complex[0:,0:],System.Int32@)">
            <summary>Получить число столбцов (элементов строки) массива матрицы</summary>
            <param name="matrix">Массив элементов матрицы, размеры которого требуется получить</param>
            <param name="M">Число столбцов (элементов строки) матрицы</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetUnitaryArrayMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="N"/> меньше 1</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.InitializeUnitaryArrayMatrix(MathCore.Complex[0:,0:])">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <returns>Квадратный двумерный массив размерности NxN с 1 на главной диагонали</returns>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTransvection(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="i0">Опорная строка</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="A"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорная строка <paramref name="i0"/> матрицы <paramref name="A"/> &lt; 0 и &gt; числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Transvection(MathCore.Complex[0:,0:],System.Int32,MathCore.Complex[0:,0:])">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <param name="result">Двумерный массив элементов матрицы результата</param>
            <returns>Трансвекция матрицы А</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрицы <paramref name="A"/> и <paramref name="result"/> не заданы</exception>  
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="A"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если опорный столбец <paramref name="j"/> матрицы <paramref name="A"/> меньше 0 или больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentException">В случае если размер матрицы <paramref name="result"/> не совпадает с размером матрицы <paramref name="A"/></exception>                  
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetCol(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Матрица-столбец, составленная из элементов столбца матрицы c индексом j</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetCol_Array(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Получить столбец матрицы в виде массива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <returns>Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetCol_Array(MathCore.Complex[0:,0:],System.Int32,MathCore.Complex[])">
            <summary>Получить столбец матрицы в виде массива</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="j">Номер столбца</param>
            <param name="result">Массив, составленная из элементов столбца матрицы c индексом <paramref name="j"/></param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу строк матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер столбца <paramref name="j"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа столбцов матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRow(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Матрица-строка, составленная из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRow_Array(MathCore.Complex[0:,0:],System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <returns>Массив, составленный из элементов строки матрицы с индексом <paramref name="i"/></returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRow_Array(MathCore.Complex[0:,0:],System.Int32,MathCore.Complex[])">
            <summary>Получить строку матрицы</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="i">Номер строки</param>
            <param name="result">Массив, составленный из элементов строки матрицы с индексом i</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если массив <paramref name="result"/> не задан</exception>
            <exception cref="T:System.ArgumentException">В случае если размер массива <paramref name="result"/> не соответствует числу столбцов матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если указанный номер строки <paramref name="i"/> матрицы <paramref name="matrix"/> меньше 0, либо больше числа строк матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Inverse(MathCore.Complex[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаемая матрица</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Inverse(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@)">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Обращаемая матрица</param>
            <param name="p">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Размерность массива 0х0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetSolve(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@)">
            <summary>Метод решения СЛАУ A*X=B -&gt; X</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <returns>Матрица решения уравнения A*X=B -&gt; X</returns>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Solve(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,System.Boolean)">
            <summary>Метод решения СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <exception cref="T:System.InvalidOperationException">Невозможно найти обратную матрицу для вырожденной матрицы</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.TrySolve(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,System.Boolean)">
            <summary>Попытаться решить СЛАУ</summary>
            <param name="matrix">Матрица СЛАУ</param>
            <param name="b">Правая часть СЛАУ</param>
            <param name="p">Матрица перестановок</param>
            <param name="clone_b">Работать с копией <paramref name="b"/></param>
            <returns>Истина, если решение СЛАУ получено; ложь - если матрица СЛАУ <paramref name="matrix"/> вырождена</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">В случае если матрица системы <paramref name="matrix"/> не квадратная</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Inverse(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Получить обратную матрицу</summary>
            <param name="matrix">Матрица, подлежащая обращению</param>
            <param name="result">Обратная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Transpose(MathCore.Complex[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Transpose(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Транспонирование матрицы</summary>
            <param name="matrix">Исходная матрица</param>
            <param name="result">Транспонированная матрица</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="result"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetAdjunct(MathCore.Complex[0:,0:],System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CopyMinor(MathCore.Complex[0:,0:],System.Int32,System.Int32,System.Int32,System.Int32,MathCore.Complex[0:,0:])">
            <summary>Скопировать минор из матрицы в матрицу результата</summary>
            <param name="matrix">Массив элементов исходной матрицы</param>
            <param name="n">Номер строки</param>
            <param name="m">Номер столбца</param>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="result">Минор матрицы</param>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMinor(MathCore.Complex[0:,0:],System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMinor(MathCore.Complex[0:,0:],System.Int32,System.Int32,MathCore.Complex[0:,0:])">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <param name="result">Минор элемента матрицы [n,m]</param>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер строки <paramref name="n"/> меньше 0, или больше, либо равен числу строк матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если номер столбца <paramref name="m"/> меньше 0, или больше, либо равен числу столбцов матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число строк матрицы результата <paramref name="result"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentException">В случае если число столбцов матрицы результата <paramref name="result"/> не равно числу столбцов исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetDeterminant(MathCore.Complex[0:,0:])">
            <summary>Определитель матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Определитель матрицы</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если матрица <paramref name="matrix"/> не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Swap``1(``0@,``0@)">
            <summary>Поменять значения местами</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUPDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхне-треугольная матрица</param>
            <param name="p">Матрица преобразований P*X = L*U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу <paramref name="matrix"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы <paramref name="matrix"/> меньше 1</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="l">Нижне-треугольная матрица</param>
            <param name="u">Верхне-треугольная матрица</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура декомпозиции прошла успешно. Ложь, если матрица вырождена</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">В случае если размерность матрицы N меньше 1</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUPDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <remarks>
            This method is based on the 'LU Decomposition and Its Applications' 
            section of Numerical Recipes in C by William H. Press, Saul A. Teukolsky, William T. 
            Vetterling and Brian P. Flannery,  University of Cambridge Press 1992.  
            </remarks>
            <param name="matrix">Массив элементов матрицы</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="p">Массив матрицы перестановок</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если операция выполнена успешно</returns>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUPDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <param name="d">Определитель матрицы</param>
            <returns>Истина, если процедура выполнена успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetLUDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@)">
            <summary>LU-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="c">Матрица с результатами разложения: элементы ниже главной диагонали - матрица L, элементы выше - матрица U</param>
            <returns>Истина, если разложение выполнено успешно</returns>
            <exception cref="T:System.ArgumentNullException">В случае если отсутствует ссылка на матрицу matrix</exception>
            <exception cref="T:System.ArgumentException">Матрица не квадратная</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.CreatePermutationMatrix(System.Int32[])">
            <summary>Создать матрицу перестановок из массива индексов</summary>
            <param name="indexes">Массив индексов элементов столбцов</param>
            <returns>Матрица перестановок</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTriangle(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,System.Int32@,MathCore.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTriangle(MathCore.Complex[0:,0:],System.Int32@,MathCore.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTriangle(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],System.Int32@,MathCore.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetTriangle(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,System.Int32@,MathCore.Complex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="matrix">Двумерный массив элементов матрицы</param>
            <param name="b">Матрица правой части</param>
            <param name="p">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="clone_b">Клонировать матрицу правых частей</param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:],MathCore.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex@)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:],MathCore.Complex@,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <param name="clone">Клонировать исходную матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Triangulate(MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,MathCore.Complex@,System.Boolean,System.Boolean)">
            <summary>Приведение матрицы к треугольному виду</summary>
            <param name="matrix">Матрица, приводимая к треугольному виду</param>
            <param name="b">Присоединённая матрица, над которой выполняются те же операции, что и над <paramref name="matrix"/></param>
            <param name="p">Матрица перестановок</param>
            <param name="d">Определитель матрицы (произведение диагональных элементов)</param>
            <param name="clone_matrix">Клонировать исходную матрицу</param>
            <param name="clone_b">Клонировать присоединённую матрицу</param>
            <returns>Ранг матрицы (число ненулевых строк)</returns>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="matrix"/> не задана</exception>
            <exception cref="T:System.ArgumentNullException">В случае если матрица <paramref name="b"/> не задана</exception>
            <exception cref="T:System.ArgumentException">В случае если число строк присоединённой матрицы <paramref name="b"/> не равно числу строк исходной матрицы <paramref name="matrix"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.AreEquals(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <returns>Истина, если оба массивы не определены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.AreEquals(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],System.Double)">
            <summary>Сравнение двух двумерных массивов элементов матриц</summary>
            <param name="A">Первый массив</param>
            <param name="B">Второй массив</param>
            <param name="eps">Точность сравнения</param>
            <returns>Истина, если оба массивы не определены, либо если оба массивы - один и тот же массив, либо если элементы массивов идентичны</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMaxRowAbsSum(MathCore.Complex[0:,0:])">
            <summary>Вычисление максимума от сумм абсолютных значений по элементам строк</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов строк</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetMaxColAbsSum(MathCore.Complex[0:,0:])">
            <summary>Вычисление максимума от сумм абсолютных значений по элементам столбцов</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Максимальная из сумм абсолютных значений элементов столбцов</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GetRMS(MathCore.Complex[0:,0:])">
            <summary>Вычисление среднеквадратичного значения элементов матрицы</summary>
            <param name="matrix">Массив элементов матрицы</param>
            <returns>Среднеквадратичное значение элементов матрицы</returns>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.Sqr(MathCore.Complex)">
            <summary>Квадрат числа</summary>
            <param name="x">Значение, квадрат которого требуется получить</param>
            <returns>Квадрат указанного числа</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GaussSeidelConverge(MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@,System.Double,System.Int32,System.Int32)">
            <summary>Метод проверки сходимости метода Метод Гаусса — Зейделя</summary>
            <remarks>Метод меняет местами матрицы решения текущего и прошлого шагов, если метод Гаусса — Зейделя не сошёлся на текущем шаге</remarks>
            <param name="new_x">Новое полученное решение</param>
            <param name="last_x">Решение, полученное на прошлом шаге метода</param>
            <param name="eps">Требуемая точность решения</param>
            <param name="N">Число строк матрицы решения</param>
            <param name="M">Число столбцов матрицы решения</param>
            <returns>Истина, если метод сошёлся Метод Гаусса — Зейделя</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.GaussSeidelSolve(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],System.Double)">
            <summary>Метод Гаусса — Зейделя решения системы линейных уравнений</summary>
            <param name="matrix">Матрица коэффициентов</param>
            <param name="x">Матрица неизвестных</param>
            <param name="b">Матрица правых частей</param>
            <param name="eps">Требуемая точность</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="x"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="b"/> == <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица системы не содержит элементов</exception>
            <exception cref="T:System.ArgumentException">Матрица системы не квадратная</exception>
            <exception cref="T:System.ArgumentException">Число строк массива неизвестных не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число строк массива правой части СЛАУ не совпадает с числом строк матрицы системы</exception>
            <exception cref="T:System.ArgumentException">Число столбцов массива правых частей не совпадает с числом столбцов массива неизвестных</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="eps"/> &lt;= <see cref="T:MathCore.Complex"/>.<see cref="F:MathCore.Complex.Epsilon"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.QRDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:],MathCore.Complex[0:,0:])">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - должна быть передана квадратная матрица nxn != null</param>
            <param name="r">Верхне-треугольная матрица - должна быть передана квадратная матрица nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.QRDecomposition(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[0:,0:]@)">
            <summary>QR-разложение матрицы</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="q">Унитарная матрица (ортогональная) - создаётся квадратная матрица nxn != null</param>
            <param name="r">Верхне-треугольная матрица - создаётся квадратная матрица nxn != null</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="matrix"/> is <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Матрица не содержит элементов</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.Array.SVD(MathCore.Complex[0:,0:],MathCore.Complex[0:,0:]@,MathCore.Complex[]@,MathCore.Complex[0:,0:]@)">
            <summary>SVD-разложение</summary>
            <param name="matrix">Разлагаемая матрица</param>
            <param name="u">Матрица левых сингулярных векторов</param>
            <param name="w">Вектор собственных чисел</param>
            <param name="v">Матрица правых сингулярных векторов</param>
            <exception cref="T:System.ArgumentNullException">matrix is <see langword="null"/></exception>
            <exception cref="T:System.InvalidOperationException">Метод не сошёлся за 30 итераций</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param><returns>Единичная матрица размерности NxN с 1 на главной диагонали</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTransvection(MathCore.MatrixComplex,System.Int32)">
            <summary>Трансвекция матрицы</summary><param name="A">Трансвецируемая матрица</param><param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixComplex._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixComplex._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixComplex._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixComplex.Item(System.Int32)">
            <summary>Вектор-столбец</summary><param name="j">Номер столбца</param><returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixComplex.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.IsScalar">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.Norm_m">
            <summary>Максимум среди абсолютных сумм элементов строк</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.Norm_l">
            <summary>Максимум среди абсолютных сумм элементов столбцов</summary>
        </member>
        <member name="P:MathCore.MatrixComplex.Norm_k">
            <summary>Среднеквадратичное значение элементов матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N"/> &lt; 0 || <paramref name="M"/> &lt; 0</exception>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary><param name="N">Размерность</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="N" /> &lt; 0</exception>
        </member>
        <member name="T:MathCore.MatrixComplex.MatrixComplexItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param><param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Int32,MathCore.MatrixComplex.MatrixComplexItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Int32,System.Int32,MathCore.MatrixComplex.MatrixComplexItemCreator)">
            <summary>Матрица</summary><param name="N">Число строк</param><param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(MathCore.Complex[0:,0:],System.Boolean)">
            <summary>Инициализация новой матрицы по двумерному массиву её элементов</summary>
            <param name="Data">Двумерный массив элементов матрицы</param>
            <param name="clone">Создать копию данных</param>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Collections.Generic.IList{MathCore.Complex},System.Boolean)">
            <summary>Инициализация новой матрицы - столбца/строки</summary>
            <param name="DataCol">Элементы столбца матрицы</param>
            <param name="IsColumn">Создаётся матрица-столбец</param>
        </member>
        <member name="M:MathCore.MatrixComplex.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{MathCore.Complex}})">
            <summary>Инициализация новой матрицы на основе перечисления строк (перечисления элементов строк) </summary>
            <param name="Items">Перечисление строк, состоящих из перечисления элементов строк</param>
        </member>
        <member name="M:MathCore.MatrixComplex.GetElements(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{MathCore.Complex}})">
            <summary>Получить двумерный массив элементов матрицы</summary>
            <param name="ColsItems">Перечисление элементов (по столбцам)</param>
            <returns>Двумерный массив элементов матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTriangle(MathCore.MatrixComplex@,System.Int32@,MathCore.Complex@)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="D">Определитель</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTriangle(MathCore.MatrixComplex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="B">Присоединённая матрица правой части СЛАУ</param>
            <param name="CloneB">Работать с клоном матрицы <paramref name="B"/></param>
            <returns>Треугольная матрица</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="B"/> <see langword="null"/></exception>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTriangle(MathCore.MatrixComplex@,MathCore.MatrixComplex@,System.Int32@,MathCore.Complex@,System.Boolean)">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <param name="B">Матрица правой части СЛАУ</param>
            <param name="P">Матрица перестановок</param>
            <param name="rank">Ранг матрицы</param>
            <param name="d">Определитель матрицы</param>
            <param name="CloneB">Клонировать матрицу правой части</param>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetInverse(MathCore.MatrixComplex@)">
            <summary>Получить обратную матрицу</summary>                                                     
            <param name="P">Матрица перестановок</param>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixComplex.GetLUDecomposition(MathCore.MatrixComplex@,MathCore.MatrixComplex@,MathCore.MatrixComplex@,MathCore.Complex@)">
            <summary>Разложение матрицы на верхне-треугольную и нижне-треугольную</summary>
            <param name="L">Нижне-треугольная матрица</param>
            <param name="U">Верхне-треугольная матрица</param>
            <param name="P">Матрица преобразований P*X = L*U</param>
            <param name="D">Знак определителя</param>
            <returns>Истина, если разложение выполнено успешно, ложь - если матрица вырожденная</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.GetData">
            <summary>Получить внутренний массив элементов матрицы</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixComplex.ToString">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.ToStringFormat(System.String,System.String,System.IFormatProvider)">
            <summary>Преобразование матрицы в строку с форматированием</summary>
            <param name="Format">Строка формата вывода чисел</param>
            <param name="Splitter">Разделитель элементов матрицы</param>
            <param name="provider">Механизм форматирования чисел матрицы</param>
            <returns>Строковое представление матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.System#ICloneable#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.MathCore#ICloneable{MathCore#Complex[,]}#Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.Clone">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Addition(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param><param name="B">Второе слагаемое</param><returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Subtraction(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param><param name="B">Вычитаемое</param><returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Multiply(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param><param name="B">Второй сомножитель</param><returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Division(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param><param name="B">Делитель</param><returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_BitwiseOr(MathCore.MatrixComplex,MathCore.MatrixComplex)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param><param name="B">Второе слагаемое</param><returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.op_Implicit(MathCore.Complex)~MathCore.MatrixComplex">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixComplex.Equals(MathCore.Complex[0:,0:])">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.Equals(MathCore.MatrixComplex)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:MathCore.MatrixComplex.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="T:MathCore.MatrixDecimal">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки,<br/>
            j (второй индекс) - номер столбца<br/>
            ------------ j ----------><br/>
            | a11 a12 a13 a14 a15 a16 a1M<br/>
            | a21........................<br/>
            | a31........................<br/>
            | a41.......aij..............<br/>
            i a51........................<br/>
            | a61........................<br/>
            | aN1.....................aNM<br/>
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetTransvection(MathCore.MatrixDecimal,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixDecimal._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixDecimal._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixDecimal._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixDecimal.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixDecimal.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixDecimal.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathCore.MatrixDecimal.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixDecimal.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathCore.MatrixDecimal.MatrixDecimalItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.#ctor(System.Int32,MathCore.MatrixDecimal.MatrixDecimalItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixDecimal.#ctor(System.Int32,System.Int32,MathCore.MatrixDecimal.MatrixDecimalItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixDecimal.LUDecomposition(System.Decimal[0:,0:],System.Decimal[0:,0:]@,System.Decimal[0:,0:]@,System.Decimal[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower triangular matrix is returned</param>
            <param name="U">An array where the upper triangular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathCore.MatrixDecimal.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixDecimal.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Addition(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Subtraction(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Multiply(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Division(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_BitwiseOr(MathCore.MatrixDecimal,MathCore.MatrixDecimal)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.op_Implicit(System.Decimal)~MathCore.MatrixDecimal">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixDecimal.System#IEquatable{MathCore#MatrixDecimal}#Equals(MathCore.MatrixDecimal)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixDecimal.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixDecimal.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MatrixFloat">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки,<br/>
            j (второй индекс) - номер столбца<br/>
            ------------ j ----------><br/>
            | a11 a12 a13 a14 a15 a16 a1M<br/>
            | a21........................<br/>
            | a31........................<br/>
            | a41.......aij..............<br/>
            i a51........................<br/>
            | a61........................<br/>
            | aN1.....................aNM<br/>
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixFloat.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetTransvection(MathCore.MatrixFloat,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixFloat._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixFloat._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixFloat._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixFloat.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixFloat.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixFloat.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathCore.MatrixFloat.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixFloat.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathCore.MatrixFloat.MatrixFloatItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.#ctor(System.Int32,MathCore.MatrixFloat.MatrixFloatItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixFloat.#ctor(System.Int32,System.Int32,MathCore.MatrixFloat.MatrixFloatItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixFloat.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixFloat.LUDecomposition(System.Single[0:,0:],System.Single[0:,0:]@,System.Single[0:,0:]@,System.Single[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note - This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower triangular matrix is returned</param>
            <param name="U">An array where the upper triangular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathCore.MatrixFloat.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixFloat.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Addition(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Subtraction(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Multiply(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Division(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_BitwiseOr(MathCore.MatrixFloat,MathCore.MatrixFloat)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.op_Implicit(System.Single)~MathCore.MatrixFloat">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixFloat.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixFloat.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MatrixInt">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки,<br/>
            j (второй индекс) - номер столбца<br/>
            ------------ j ----------><br/>
            | a11 a12 a13 a14 a15 a16 a1M<br/>
            | a21........................<br/>
            | a31........................<br/>
            | a41.......aij..............<br/>
            i a51........................<br/>
            | a61........................<br/>
            | aN1.....................aNM<br/>
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixInt.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetTransvection(MathCore.MatrixInt,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixInt._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixInt._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixInt._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixInt.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixInt.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixInt.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixInt.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixInt.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixInt.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixInt.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixInt.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathCore.MatrixInt.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixInt.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:MathCore.MatrixInt.MatrixIntItemCreator">
            <summary>Метод определения значения элемента матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:MathCore.MatrixInt.#ctor(System.Int32,MathCore.MatrixInt.MatrixIntItemCreator)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixInt.#ctor(System.Int32,System.Int32,MathCore.MatrixInt.MatrixIntItemCreator)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixInt.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixInt.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixInt.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixInt.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Addition(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Subtraction(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Multiply(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Division(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_BitwiseOr(MathCore.MatrixInt,MathCore.MatrixInt)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixInt.op_Implicit(System.Int32)~MathCore.MatrixInt">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixInt.System#IEquatable{MathCore#MatrixInt}#Equals(MathCore.MatrixInt)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixInt.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixInt.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MatrixLong">
            <summary>Матрица NxM</summary>
            <remarks>
            i (первый индекс) - номер строки,<br/>
            j (второй индекс) - номер столбца<br/>
            ------------ j ----------><br/>
            | a11 a12 a13 a14 a15 a16 a1M<br/>
            | a21........................<br/>
            | a31........................<br/>
            | a41.......aij..............<br/>
            i a51........................<br/>
            | a61........................<br/>
            | aN1.....................aNM<br/>
            \/
            </remarks>
        </member>
        <member name="M:MathCore.MatrixLong.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetTransvection(MathCore.MatrixLong,System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="A">Трансвецируемая матрица</param>
            <param name="j">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>
        </member>
        <member name="F:MathCore.MatrixLong._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixLong._M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:MathCore.MatrixLong._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixLong.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixLong.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixLong.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце)</param>
            <param name="j">Номер столбца (элемента в строке)</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixLong.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:MathCore.MatrixLong.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:MathCore.MatrixLong.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:MathCore.MatrixLong.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:MathCore.MatrixLong.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="M:MathCore.MatrixLong.#ctor(System.Int32,System.Int32)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixLong.#ctor(System.Int32)">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="M:MathCore.MatrixLong.#ctor(System.Int32,System.Func{System.Int32,System.Int32,System.Int64})">
            <summary>Квадратная матрица</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixLong.#ctor(System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Int64})">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:MathCore.MatrixLong.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:MathCore.MatrixLong.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:MathCore.MatrixLong.LUDecomposition(System.Int64[0:,0:],System.Int64[0:,0:]@,System.Int64[0:,0:]@,System.Int64[0:,0:]@)">
            <summary>
            Returns the LU Decomposition of a matrix. 
            the output is: lower triangular matrix L, upper
            triangular matrix U, and permutation matrix P so that
            P*X = L*U.
            In case of an error the error is raised as an exception.
            Note: This method is based on the 'LU Decomposition and Its Applications'
            section of Numerical Recipes in C by William H. Press,
            Saul A. Teukolsky, William T. Vetterling and Brian P. Flannery,
            University of Cambridge Press 1992.  
            </summary>
            <param name="Mat">Array which will be LU Decomposed</param>
            <param name="L">An array where the lower triangular matrix is returned</param>
            <param name="U">An array where the upper triangular matrix is returned</param>
            <param name="P">An array where the permutation matrix is returned</param>
        </member>
        <member name="M:MathCore.MatrixLong.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixLong.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Addition(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Subtraction(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Multiply(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Division(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_BitwiseOr(MathCore.MatrixLong,MathCore.MatrixLong)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:MathCore.MatrixLong.op_Implicit(System.Int64)~MathCore.MatrixLong">
            <summary>
            Оператор неявного приведения типа вещественного числа двойной точности к типу 
            Матрица порядка 1х1
            </summary>
            <param name="X">Приводимое число</param>
            <returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:MathCore.MatrixLong.System#IEquatable{MathCore#MatrixLong}#Equals(MathCore.MatrixLong)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixLong.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.MatrixLong.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.MatrixArray">
            <summary>Матрица на линейном массиве</summary>
        </member>
        <member name="M:MathCore.MatrixArray.CreateZeros(System.Int32)">
            <summary>Создать квадратную нулевую матрицу</summary>
            <param name="N">Размер матрицы</param>
            <returns>Квадратная матрица, составленная из нулей</returns>
        </member>
        <member name="M:MathCore.MatrixArray.CreateZeros(System.Int32,System.Int32)">
            <summary>Создать нулевую матрицу</summary>
            <param name="N">Число строк матрицы</param>
            <param name="M">Число столбцов матрицы</param>
            <returns>Прямоугольная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixArray.CreateUnitary(System.Int32)">
            <summary>Создать единичную (квадратную матрицу)</summary>
            <param name="N">Размер матрицы</param>
            <returns>Единичная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixArray.CreateOnes(System.Int32)">
            <summary>Создать квадратную матрицу, заполненную единицами</summary>
            <param name="N">Размер матрицы</param>
            <returns>Квадратная матрица, заполненная единицами</returns>
        </member>
        <member name="M:MathCore.MatrixArray.CreateOnes(System.Int32,System.Int32)">
            <summary>Создать матрицу, заполенную единицами</summary>
            <param name="N">Число строк матрицы</param>
            <param name="M">Число столбцов матрицы</param>
            <returns>Прямоугольная матрица, заполненная единицами</returns>
        </member>
        <member name="F:MathCore.MatrixArray._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixArray._M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="F:MathCore.MatrixArray._Values">
            <summary>Массив значений матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixArray.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixArray.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:MathCore.MatrixArray.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns></returns>
        </member>
        <member name="M:MathCore.MatrixArray.#ctor(System.Int32,System.Int32)">
            <summary>Матрица на основе одномерного массива</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:MathCore.MatrixArray.#ctor(System.Int32,System.Int32,System.Double[],System.Boolean)">
            <summary>Матрица</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="Values">Массив значений ячеек матрицы</param>
            <param name="Clone">Слонировать массив?</param>
        </member>
        <member name="M:MathCore.MatrixArray.GetTransposed">
            <summary>Создать транспонированную матрицу</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:MathCore.MatrixArray.ToMatrix">
            <summary>Преобразовать матрицу на линейном массиве в матрицу на двумерном массиве</summary>
            <returns>Матрица на двумерном массиве</returns>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.ActionWork">
            <summary>Работа, выполняющая действие</summary>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.ActionWork._WorkAction">
            <summary>Действие, выполняемое работой</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.ActionWork.#ctor(System.Action,MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация нового работы на основе действия</summary>
            <param name="WorkAction">Действие, выполняемое в рамках работы</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.ActionWork.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.ConstValueWork`1">
            <summary>Работа, возвращающая указанное константное значение</summary>
            <typeparam name="T">Тип возвращаемого работой значения</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.ConstValueWork`1.Value">
            <summary>Значение, возвращаемое работой</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.ConstValueWork`1.#ctor(`0,MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, возвращающей константное значение</summary>
            <param name="Value">Значение, которое будет возвращать работа</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.ConstValueWork`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.FunctionWork`1">
            <summary>Работа, выполняющая указанную функцию</summary>
            <typeparam name="T">Тип значения функции</typeparam>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.FunctionWork`1._WorkFunction">
            <summary>Функция, выполняемая в рамках работы</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.FunctionWork`1.#ctor(System.Func{`0},MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, выполняющей указанную функцию</summary>
            <param name="WorkFunction">Функция, выполняемая работой</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.FunctionWork`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.IWorkResult">
            <summary>Результат выполнения работы</summary>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult.Error">
            <summary>Ошибка, которая произошла в ходе выполнения работы</summary>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult.Success">
            <summary>Признак того, что работа завершилась успешно</summary>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult.Failure">
            <summary>Признак того, что работа завершилась провалом</summary>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.IWorkResult`1">
            <summary>Результат выполнения работы со значением</summary>
            <typeparam name="T">Тип результата, доступного после выполнения работы</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult`1.Result">
            <summary>Результат выполнения работы</summary>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.IWorkResult`2">
            <summary>Результат выполнения параметрической работы</summary>
            <typeparam name="TParameter">Тип параметра работы</typeparam>
            <typeparam name="T">Тип значения, доступного по завершении работы</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.IWorkResult`2.Parameter">
            <summary>Параметр, с которым работа была выполнена</summary>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work`2">
            <summary>Работа, выполняющая преобразование данных указанным методом</summary>
            <typeparam name="TParameter">Тип сходных данных для преобразования</typeparam>
            <typeparam name="TResult">Тип результата преобразования</typeparam>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work`2._WorkFunction">
            <summary>Функция преобразования значения, выполняемая в рамках работы</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`2.#ctor(System.Func{`0,`1},MathCore.Monads.WorkFlow.Work)">
            <summary>Внутренняя инициализация новой работы по преобразованию значения на основе указанной функции</summary>
            <param name="WorkFunction">Функция, преобразующая значение</param>
            <param name="BaseWork">Базовая работа, являющаяся источником аргумента функции</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`2.#ctor(System.Func{`0,`1},MathCore.Monads.WorkFlow.Work{`0})">
            <summary>Инициализация новой работы по преобразованию значения на основе указанной функции</summary>
            <param name="WorkFunction">Функция, преобразующая значение</param>
            <param name="BaseWork">Базовая работа, являющаяся источником аргумента функции</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`2.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`2.Execute">
            <summary>Выполнение работы</summary>
            <returns>Результат выполнения работы, содержавший исходные данные и полученное значение</returns>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work`1">
            <summary>Работа, возвращающая значение</summary>
            <typeparam name="T">Тип результата работы</typeparam>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work`1.FunctionWorkIfSuccess`2">
            <summary>Работа по преобразованию значения, выполняемая в случае, если предыдущая работа была выполнена успешно</summary>
            <typeparam name="TParameter">Тип исходных данных преобразования</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.FunctionWorkIfSuccess`2.#ctor(System.Func{`1,`2},MathCore.Monads.WorkFlow.Work{`1})">
            <summary>Инициализация новой работы по преобразованию значения, выполняемой в случае если предыдущая работа была выполнена успешно</summary>
            <param name="WorkFunction">Метод преобразования значения</param>
            <param name="BaseWork">Предыдущая работа, формирующая исходные данные для текущей выполняемой работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.FunctionWorkIfSuccess`2.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work`1.ActionWork`1">
            <summary>Работа, выполняемая над результатом предыдущей работы</summary>
            <typeparam name="TParameter">Тип результата предыдущей работы</typeparam>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work`1.ActionWork`1._WorkAction">
            <summary>Действие, выполняемое над результатом предыдущей работы</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.ActionWork`1.#ctor(System.Action{`1},MathCore.Monads.WorkFlow.Work{`1})">
            <summary>Инициализация новой работы, выполняющей действие над результатом выполнения предыдущей работы</summary>
            <param name="WorkAction">Действие, выполняемое над результатом предыдущей работы</param>
            <param name="BaseWork">Предыдущая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.ActionWork`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.#ctor(MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы</summary><param name="BaseWork">объект базовой работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.Execute">
            <summary>Выполнение работы</summary><returns>Результат работы</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.Invoke(System.Action{`0})">
            <summary>Действие, выполняемое в любом случае для результата предыдущей работы</summary>
            <param name="action">Выполняемое действие</param>
            <returns>Работа, выполняющая действие для результата выполнения предыдущей работы</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.Get``1(System.Func{`0,``0})">
            <summary>Работа, в результате которой формируется результат</summary>
            <typeparam name="TResult">Тип результата работы</typeparam>
            <param name="function">Функция, выполняемая в рамках работы над параметром, получаемым от предыдущей работы</param>
            <returns>Работа по получению результата</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.GetIfSuccess``1(System.Func{`0,``0})">
            <summary>Выполнение преобразования в случае если предыдущая работа выполнена успешно</summary>
            <typeparam name="TResult">Результат преобразования</typeparam>
            <param name="function">Метод преобразования значения</param>
            <returns>Работа по преобразованию значения, выполняемая в случае, если предыдущая работа выполнена успешно</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.GetIfFailure(System.Func{System.Exception,`0})">
            <summary>Добавление обработчика исключительных ситуаций</summary>
            <param name="ErrorHandler">Функция, получающая в качестве параметра исключение и на его основе формирующая значение функции</param>
            <returns>Работа по обработке исключений, возникающих на предыдущих этапах выполнения работы</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work`1.op_Implicit(MathCore.Monads.WorkFlow.Work{`0})~`0">
            <summary>Оператор неявного преобразования типа <see cref="T:MathCore.Monads.WorkFlow.Work`1"/> к типу <typeparamref name="T"/></summary>
            <param name="work">Работа с типизированным результатом <see cref="T:MathCore.Monads.WorkFlow.Work`1"/></param>
            <returns>Результат выполнения работы типа <typeparamref name="T"/></returns>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work">
            <summary>Класс-оболочка для выполняемой работы</summary>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.ActionWorkIfSuccess">
            <summary>Работа на основе действия, выполняемая лишь в том случае, если базовая работа выполнилась успешно</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ActionWorkIfSuccess.#ctor(System.Action,MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, выполняемой в случае успешного выполнения предыдущей работы</summary>
            <param name="WorkAction">Действие, выполняемое в рамках работы</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ActionWorkIfSuccess.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.ActionWorkIfFailure">
            <summary>Работа на основе действия, выполняемая лишь в том случае, если базовая работа выполнилась с ошибкой</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ActionWorkIfFailure.#ctor(System.Action,MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, выполняемой в случае ошибочного выполнения предыдущей работы</summary>
            <param name="WorkAction">Действие, выполняемое в рамках работы</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ActionWorkIfFailure.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.ExceptionActionHandler">
            <summary>Работа по обработке ошибок</summary>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work.ExceptionActionHandler._ErrorHandler">
            <summary>Действие-обработчик исключения</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ExceptionActionHandler.#ctor(System.Action{System.Exception},MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы по обработке ошибок</summary>
            <param name="ErrorHandler">Действие-обработчик ошибок</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ExceptionActionHandler.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.FunctionWorkIfSuccess`1">
            <summary>Работа, возвращающая результат выполнения функции в случае если предыдущая работа завершилась успешно</summary>
            <typeparam name="T">Тип значения функции</typeparam>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.FunctionWorkIfSuccess`1.#ctor(System.Func{`0},MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, возвращающей значение функции в случае если предыдущая работа завершилась успешно</summary>
            <param name="WorkFunction">Функция, выполняемая в рамках работы</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.FunctionWorkIfSuccess`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.FunctionWorkIfFailure`1">
            <summary>Работа по преобразованию значения, выполняемая в случае, если предыдущая работа завершилась исключением</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.FunctionWorkIfFailure`1.#ctor(System.Func{`0},MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация новой работы, выполняемой в случае неудачи предыдущей работы</summary>
            <param name="WorkFunction">Функция - генератор значения</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.FunctionWorkIfFailure`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.Work.ExceptionFunctionHandler`1">
            <summary>Работа по обработке ошибок</summary><typeparam name="T">Тип исключительной ситуации</typeparam>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work.ExceptionFunctionHandler`1._ErrorHandler">
            <summary>Функция-обработчик исключения</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ExceptionFunctionHandler`1.#ctor(System.Func{System.Exception,`0},MathCore.Monads.WorkFlow.Work{`0})">
            <summary>Инициализация новой работы по обработке ошибок</summary>
            <param name="ErrorHandler">Функция-обработчик ошибок</param>
            <param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.ExceptionFunctionHandler`1.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.BeginInvoke(System.Action)">
            <summary>Начало работы на основе делегата действия</summary>
            <param name="WorkAction">Делегат, на основе которого формируется работа</param>
            <returns>Работа, выполняющая указанный делегат</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.BeginGet``1(System.Func{``0})">
            <summary>Начало работы с указанной функцией</summary>
            <typeparam name="T">Тип значения, возвращаемого функцией</typeparam>
            <param name="WorkFunction">Функция, выполняемая работой</param>
            <returns>Работа, выполняющая указанную функцию, возвращающую значение</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.With``1(``0)">
            <summary>Фиксированное исходное значение для начала работы</summary>
            <typeparam name="T">Тип значения</typeparam>
            <param name="value">Исходное, используемое в дальнейшем, значение</param>
            <returns>Работа, результатом которой является указанное значение</returns>
        </member>
        <member name="F:MathCore.Monads.WorkFlow.Work._BaseWork">
            <summary>Базовая работа</summary>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.#ctor(MathCore.Monads.WorkFlow.Work)">
            <summary>Инициализация нового работы</summary><param name="BaseWork">Базовая работа</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.Execute(MathCore.Monads.WorkFlow.IWorkResult)">
            <summary>Выполнить действие текущей работы</summary>
            <param name="BaseResult">Результат выполнения предыдущей работы</param>
            <returns>Результат выполнения действия</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.Execute">
            <summary>Выполнить работу</summary>
            <returns>Результат выполнения работы</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.Invoke(System.Action)">
            <summary>Действие, выполняемое в любом случае</summary>
            <param name="action">Выполняемое действие</param>
            <returns>Сформированная работа, выполняемая в любом случае</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.InvokeIfSuccess(System.Action)">
            <summary>Действие, выполняемое в случае успеха предыдущего действия</summary>
            <param name="action">Выполняемое действие</param>
            <returns>Сформированная работа, выполняемая в случае успеха предыдущего действия</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.InvokeIfFailure(System.Action)">
            <summary>Работа, которую надо выполнить в случае, если предыдущая работа завершилась с ошибкой</summary>
            <param name="action">Действие, выполняемое в случае неудачи предыдущего действия</param>
            <returns>Сформированная работа, выполняемая в случае неудачи предыдущего действия</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.InvokeIfFailure(System.Action{System.Exception})">
            <summary>Действие, выполняемое в случае неудачи предыдущего действия</summary>
            <param name="ErrorHandler">Обработчик ошибки</param>
            <returns>Сформированная работа, выполняемая в случае неудачи предыдущего действия</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.Get``1(System.Func{``0})">
            <summary>Выполнение функции в любом случае</summary>
            <typeparam name="T">Тип значения функции</typeparam>
            <param name="function">Функция, выполняемая в рамках работы</param>
            <returns>Работа, выполняющая функцию, возвращающую значение</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.GetIfSuccess``1(System.Func{``0})">
            <summary>Выполнение функции в случае если предыдущая работа завершилась успешно</summary>
            <typeparam name="T">Тип результата функции</typeparam>
            <param name="function">Выполняемая функция</param>
            <returns>Работа, выполняющая функцию в случае если предыдущая работа завершилась успешно</returns>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.Work.GetIfFailure``1(System.Func{``0})">
            <summary>Работа, выполняемая в случае если функция завершилась ошибкой</summary>
            <typeparam name="T">Тип значения функции</typeparam>
            <param name="function">Функция, выполняемая в случае неудачи</param>
            <returns>Работа, выполняющая функцию в случае неудачи предыдущей работы</returns>
        </member>
        <member name="T:MathCore.Monads.WorkFlow.WorkResult">
            <summary>Результат выполнения работы</summary>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult.Error">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult.Success">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult.Failure">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult.#ctor(System.Exception,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
            <param name="CurrentError">Ошибка текущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.WorkResult`1">
            <summary>Результат выполнения работы со значением</summary>
            <typeparam name="T">Тип результата, доступного после выполнения работы</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`1.Error">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`1.Success">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`1.Failure">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`1.Result">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.#ctor(`0,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="Result">Результат выполнения работы</param>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.#ctor(System.Exception,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
            <param name="CurrentError">Ошибка текущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.Equals(MathCore.Monads.WorkFlow.WorkResult{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Monads.WorkFlow.WorkResult`2">
            <summary>Результат выполнения параметрической работы</summary>
            <typeparam name="TParameter">Тип параметра работы</typeparam>
            <typeparam name="T">Тип значения, доступного по завершении работы</typeparam>
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Error">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Success">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Failure">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Parameter">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Monads.WorkFlow.WorkResult`2.Result">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.#ctor(System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.#ctor(`0,`1,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="Parameter">Параметр текущего процесса выполнения работы</param>
            <param name="Result">Результат выполнения работы</param>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.#ctor(`0,System.Exception,System.Exception)">
            <summary>Инициализация нового результата выполнения работы</summary>
            <param name="Parameter">Параметр текущего процесса выполнения работы</param>
            <param name="PrevError">Ошибка предыдущего процесса выполнения работы</param>
            <param name="CurrentError">Ошибка текущего процесса выполнения работы</param>
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.Equals(MathCore.Monads.WorkFlow.WorkResult{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Monads.WorkFlow.WorkResult`2.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Numeric">
            <summary>Алгоритмы над числами</summary>
        </member>
        <member name="M:MathCore.Numeric.HiBit(System.Int32)">
            <summary>Выделение старшего бита</summary>
        </member>
        <member name="M:MathCore.Numeric.HiBit(System.UInt32)">
            <summary>Выделение старшего бита</summary>
        </member>
        <member name="M:MathCore.Numeric.HiBit(System.Byte)">
            <summary>Выделение старшего бита</summary>
        </member>
        <member name="M:MathCore.Numeric.HiBit(System.SByte)">
            <summary>Выделение старшего бита</summary>
        </member>
        <member name="M:MathCore.Numeric.HiBit(System.Int16)">
            <summary>Выделение старшего бита</summary>
        </member>
        <member name="M:MathCore.Numeric.HiBit(System.UInt16)">
            <summary>Выделение старшего бита</summary>
        </member>
        <member name="M:MathCore.Numeric.HiBit(System.Int64)">
            <summary>Выделение старшего бита</summary>
        </member>
        <member name="M:MathCore.Numeric.HiBit(System.UInt64)">
            <summary>Выделение старшего бита</summary>
        </member>
        <member name="M:MathCore.Numeric.SignedBitCount(System.Int32)">
            <summary>Подсчёт числа единичных бит</summary>
        </member>
        <member name="M:MathCore.Numeric.SignedBitCount(System.UInt32)">
            <summary>Подсчёт числа единичных бит</summary>
        </member>
        <member name="M:MathCore.Numeric.SignedBitCount(System.Byte)">
            <summary>Подсчёт числа единичных бит</summary>
        </member>
        <member name="M:MathCore.Numeric.SignedBitCount(System.SByte)">
            <summary>Подсчёт числа единичных бит</summary>
        </member>
        <member name="M:MathCore.Numeric.SignedBitCount(System.Int16)">
            <summary>Подсчёт числа единичных бит</summary>
        </member>
        <member name="M:MathCore.Numeric.SignedBitCount(System.UInt16)">
            <summary>Подсчёт числа единичных бит</summary>
        </member>
        <member name="M:MathCore.Numeric.SignedBitCount(System.Int64)">
            <summary>Подсчёт числа единичных бит</summary>
        </member>
        <member name="M:MathCore.Numeric.SignedBitCount(System.UInt64)">
            <summary>Подсчёт числа единичных бит</summary>
        </member>
        <member name="T:MathCore.ProducerConsumerCollectionBase`1">
            <summary>
            Provides a base implementation for producer-consumer collections that wrap other
            producer-consumer collections.
            </summary>
            <typeparam name="T">Specifies the type of elements in the collection.</typeparam>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>Initializes the ProducerConsumerCollectionBase instance.</summary>
            <param name="contained">The collection to be wrapped by this instance.</param>
        </member>
        <member name="P:MathCore.ProducerConsumerCollectionBase`1.ContainedCollection">
            <summary>Gets the contained collection.</summary>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.TryAdd(`0)">
            <summary>Attempts to add the specified value to the end of the deque.</summary>
            <param name="item">The item to add.</param>
            <returns>true if the item could be added; otherwise, false.</returns>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.TryTake(`0@)">
            <summary>Attempts to remove and return an item from the collection.</summary>
            <param name="item">
            When this method returns, if the operation was successful, item contains the item removed. If
            no item was available to be removed, the value is unspecified.
            </param>
            <returns>
            true if an element was removed and returned from the collection; otherwise, false.
            </returns>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryAdd(`0)">
            <summary>Attempts to add the specified value to the end of the deque.</summary>
            <param name="item">The item to add.</param>
            <returns>true if the item could be added; otherwise, false.</returns>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.System#Collections#Concurrent#IProducerConsumerCollection{T}#TryTake(`0@)">
            <summary>Attempts to remove and return an item from the collection.</summary>
            <param name="item">
            When this method returns, if the operation was successful, item contains the item removed. If
            no item was available to be removed, the value is unspecified.
            </param>
            <returns>
            true if an element was removed and returned from the collection; otherwise, false.
            </returns>
        </member>
        <member name="P:MathCore.ProducerConsumerCollectionBase`1.Count">
            <summary>Gets the number of elements contained in the collection.</summary>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.ToArray">
            <summary>Creates an array containing the contents of the collection.</summary>
            <returns>The array.</returns>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the contents of the collection to an array.</summary>
            <param name="array">The array to which the data should be copied.</param>
            <param name="index">The starting index at which data should be copied.</param>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the contents of the collection to an array.</summary>
            <param name="array">The array to which the data should be copied.</param>
            <param name="index">The starting index at which data should be copied.</param>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.GetEnumerator">
            <summary>Gets an enumerator for the collection.</summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="M:MathCore.ProducerConsumerCollectionBase`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Gets an enumerator for the collection.</summary>
            <returns>An enumerator.</returns>
        </member>
        <member name="P:MathCore.ProducerConsumerCollectionBase`1.System#Collections#ICollection#IsSynchronized">
            <summary>Gets whether the collection is synchronized.</summary>
        </member>
        <member name="P:MathCore.ProducerConsumerCollectionBase`1.System#Collections#ICollection#SyncRoot">
            <summary>Gets the synchronization root object for the collection.</summary>
        </member>
        <member name="T:MathCore.IProducerConsumerCollection_DebugView`1">
            <summary>Debug view for the IProducerConsumerCollection.</summary>
            <typeparam name="T">Specifies the type of the data being aggregated.</typeparam>
        </member>
        <member name="T:MathCore.ObjectPool`1">
            <summary>Provides a thread-safe object pool.</summary>
            <typeparam name="T">Specifies the type of the elements stored in the pool.</typeparam>
        </member>
        <member name="M:MathCore.ObjectPool`1.#ctor(System.Func{`0})">
            <summary>Initializes an instance of the ObjectPool class.</summary>
            <param name="Factory">The function used to create items when no items exist in the pool.</param>
        </member>
        <member name="M:MathCore.ObjectPool`1.#ctor(System.Func{`0},System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>Initializes an instance of the ObjectPool class.</summary>
            <param name="Factory">The function used to create items when no items exist in the pool.</param>
            <param name="collection">The collection used to store the elements of the pool.</param>
        </member>
        <member name="M:MathCore.ObjectPool`1.PutObject(`0)">
            <summary>Adds the provided item into the pool.</summary>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:MathCore.ObjectPool`1.GetObject">
            <summary>Gets an item from the pool.</summary>
            <returns>The removed or created item.</returns>
            <remarks>If the pool is empty, a new item will be created and returned.</remarks>
        </member>
        <member name="M:MathCore.ObjectPool`1.ToArrayAndClear">
            <summary>Clears the object pool, returning all of the data that was in the pool.</summary>
            <returns>An array containing all of the elements in the pool.</returns>
        </member>
        <member name="T:MathCore.ObservableHashSet`1">
            <summary>Хеш-таблица с уведомлением об изменениях</summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
        </member>
        <member name="E:MathCore.ObservableHashSet`1.PropertyChanged">
            <summary>Событие происходит при изменении значения свойства</summary>
        </member>
        <member name="M:MathCore.ObservableHashSet`1.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения значения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="E:MathCore.ObservableHashSet`1.CollectionChanged">
            <summary>Событие происходит при изменении коллекции</summary>
        </member>
        <member name="M:MathCore.ObservableHashSet`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>Метод генерации события изменения коллекции</summary>
            <param name="e">Параметры события</param>
        </member>
        <member name="F:MathCore.ObservableHashSet`1._HashSet">
            <summary>Внутренняя хеш-таблица</summary>
        </member>
        <member name="M:MathCore.ObservableHashSet`1.#ctor">
            <summary>Инициализация новой хеш-таблицы с уведомлениями об изменениях в содержимом</summary>
        </member>
        <member name="M:MathCore.ObservableHashSet`1.#ctor(System.Collections.Generic.HashSet{`0})">
            <summary>Инициализация новой хеш-таблицы с уведомлениями об изменениях в содержимом</summary>
            <param name="Set">Внутренняя таблица</param>
        </member>
        <member name="M:MathCore.ObservableHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Инициализация новой хеш-таблицы с уведомлениями об изменениях в содержимом</summary>
            <param name="Items">Исходный набор элементов</param>
        </member>
        <member name="P:MathCore.ObservableHashSet`1.Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.ObservableHashSet`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ObservableHashSet`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ObservableHashSet`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ObservableHashSet`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ObservableHashSet`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ObservableHashSet`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ObservableHashSet`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ObservableHashSet`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm._Inertia">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm._LocalWeight">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm.LocalWeight">
            <summary>Коэффициент стремления точки к своему собственному лучшему значению</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm._GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm.GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm1D._Inertia">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm1D._LocalWeight">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm1D.LocalWeight">
            <summary>Коэффициент стремления точки к своему собственному лучшему значению</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm1D._GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm1D.GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="T:MathCore.Optimization.ParticleSwarm.Swarm2D">
            <summary>Рой двумерных частиц</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm2D._Inertia">
            <summary>Вес инерции</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm2D._LocalWeight">
            <summary>Коэффициент локального веса</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm2D.LocalWeight">
            <summary>Коэффициент стремления точки к своему собственному лучшему значению</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm2D._GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="P:MathCore.Optimization.ParticleSwarm.Swarm2D.GlobalWeight">
            <summary>Коэффициент стремления всех точек к лучшему значению</summary>
        </member>
        <member name="T:MathCore.Optimization.ParticleSwarm.Swarm2D.Particle2D">
            <summary>Частица</summary>
        </member>
        <member name="F:MathCore.Optimization.ParticleSwarm.Swarm2D._ParticleCount">
            <summary>Размер роя</summary>
        </member>
        <member name="T:MathCore.PatternString">
            <summary>Строковый процессор, формирующий строку на основе шаблона</summary>
        </member>
        <member name="F:MathCore.PatternString.__Regex">
            <summary>Регулярное выражение поиска составных частей шаблона</summary>
        </member>
        <member name="P:MathCore.PatternString.FormatProvider">
            <summary>Способ форматирования типов <seealso cref="T:System.IFormattable"/></summary>
        </member>
        <member name="P:MathCore.PatternString.Pattern">
            <summary>
            Искомый шаблон в формате регулярного выражения. <br/>
            Должен содержать обязательно группу (?&lt;name&gt;\w), обнаруживающую имя поля и группу (?&lt;format&gt;.+?) с форматом значения поля. <br/>
            Примеры:<br/>
            &#0032;{(?&lt;name&gt;\w+)(?::(?&lt;format&gt;.+?))?} преобразует {FileName}[{date:yyy-MM-ddTHH-mm-ss}].{ext}<br/>
            &#x0020;\[\[(?&lt;name&gt;\w+)(:(?&lt;format&gt;.*?))?\]\] преобразует [[FileName]][[[date:yyy-MM-ddTHH-mm-ss]]].[[ext]]
            </summary>
        </member>
        <member name="P:MathCore.PatternString.Item(System.String)">
            <summary>Добавление источников данных для замены полей в строке формата</summary>
            <param name="FieldName">Замещаемое поле в строке формата</param>
            <returns>Функция генерации значения</returns>
        </member>
        <member name="M:MathCore.PatternString.#ctor(System.String)">
            <summary>Новый процессор шаблона строки</summary>
            <param name="Pattern">Шаблон строки, содержащий набор полей для подстановки в них данных</param>
        </member>
        <member name="M:MathCore.PatternString.Add(System.String,System.Object)">
            <summary>Добавить значение для поля</summary>
            <param name="FieldName">Имя поля для подстановки</param>
            <param name="value">Значение, замещающее указанный <see cref="!:FieldName"/></param>
        </member>
        <member name="M:MathCore.PatternString.Add(System.String,System.Func{System.Object})">
            <summary>Добавить значение</summary>
            <param name="FieldName">Имя поля для подстановки</param>
            <param name="Selector">Функция генерации значения для замещения <see cref="!:FieldName"/></param>
        </member>
        <member name="M:MathCore.PatternString.Add(System.String,System.Func{System.String,System.Object})">
            <summary>Добавить значение</summary>
            <param name="FieldName">Имя поля для подстановки</param>
            <param name="Selector">Функция генерации значения для замещения <see cref="!:FieldName"/>, в которую передаётся имя токена</param>
        </member>
        <member name="M:MathCore.PatternString.Remove(System.String)">
            <summary>Удалить значение токена</summary>
            <param name="FieldName">Имя удаляемого поля</param>
        </member>
        <member name="M:MathCore.PatternString.Contains(System.String)">
            <summary>Проверка наличия значения для указанного поля по его имени</summary>
            <param name="FieldName">Имя проверяемого поля</param>
            <returns>Истина, если поле значение для поля определено</returns>
        </member>
        <member name="M:MathCore.PatternString.PatternPartSelector(System.Text.RegularExpressions.Match)">
            <summary>Метод, выполняемый регулярным выражением в процессе подстановки значений в строку шаблона</summary>
            <param name="Match">Найденное поле</param>
            <returns>Строка, подставляемая вместо найденного поля</returns>
        </member>
        <member name="F:MathCore.PE.Headers.DOS.Length">
            <summary>Размер заголовка 62 байта</summary>
        </member>
        <member name="P:MathCore.PE.Headers.DOS.Magic">
            <summary>Должно быть равно 'M', 'Z' = 4D5A</summary>
        </member>
        <member name="P:MathCore.PE.Headers.DOS.lfanew">
            <summary>Смещение PE-заголовка</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.EXPORT">
            <summary>Export Directory</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.IMPORT">
            <summary>Import Directory</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.RESOURCE">
            <summary>Resource Directory</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.EXCEPTION">
            <summary>Exception Directory</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.SECURITY">
            <summary>Security Directory</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.BASERELOC">
            <summary>Base Relocation Table</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.DEBUG">
            <summary>Debug Directory</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.COPYRIGHT">
            <summary>Architecture Specific Data (X86 usage)</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.ARCHITECTURE">
            <summary>Architecture Specific Data</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.GLOBALPTR">
            <summary>RVA of GP</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.TLS">
            <summary>TLS Directory</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.LOAD_CONFIG">
            <summary>Load Configuration Directory</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.BOUND_IMPORT">
            <summary>Bound Import Directory in headers</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.IAT">
            <summary>Import Address Table</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.DELAY_IMPORT">
            <summary>Delay Load Import Descriptors</summary>
        </member>
        <member name="F:MathCore.PE.Headers.IMAGE_DIRECTORY_ENTRY.COM_DESCRIPTOR">
            <summary>COM Runtime descriptor</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.Signature">
            <summary>Должно быть равно "PE\0\0" = 0x50450000</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.MachineType.I386">
            <summary>x86</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.MachineType.IA64">
            <summary>Intel Itanium</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.MachineType.AMD64">
            <summary>x64</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageFileHeader.NumberOfSections">
            <summary>Количество секций</summary>
            <remarks>
            Это значение указывает на размер таблицы разделов, которая сразу следует за заголовками.<br/>
            Обратите внимание, что загрузчик Windows ограничивает количество разделов 96.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageFileHeader.TimeDateStamp">
            <summary>
            Младшие 32 бита временной метки изображения.
            Это представляет собой дату и время, когда изображение было создано компоновщиком.
            Значение представлено в количестве секунд, прошедших с полуночи
            (00:00:00) 1 января 1970 года по UTC, согласно системным часам.
            </summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageFileHeader.PointerToSymbolTable">
            <summary>Смещение таблицы символов в байтах или ноль, если таблица символов COFF не существует</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageFileHeader.NumberOfSymbols">
            <summary>Количество символов в таблице символов</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageFileHeader.SizeOfOptionalHeader">
            <summary>Размер необязательного заголовка в байтах. Это значение должно быть равно 0 для объектных файлов.</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageFileHeader.Characteristics">
            <summary>Характеристики изображения</summary>
        </member>
        <member name="T:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue">
            <summary>Характеристики изображения</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.RelocsStripped">
            <summary>
            Информация о перемещении была удалена из файла.
            Файл должен быть загружен по его предпочтительному базовому адресу.
            Если базовый адрес недоступен, загрузчик сообщает об ошибке.
            </summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.ExecutableImage">
            <summary>Файл является исполняемым (нет неразрешенных внешних ссылок)</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.LineNumsStripped">
            <summary>Номера строк COFF были удалены из файла</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.LocalSymsStripped">
            <summary>Записи таблицы символов COFF были удалены из файла</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.AggresiveWsTrim">
            <summary>Агрессивно обрезайте рабочий набор (устарело)</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.LargeAddressAware">
            <summary>Приложение может обрабатывать адреса размером более 2 ГБ</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.BytesReversedLo">
            <summary>Байты слова меняются местами (устарело)</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.Is32BitMachine">
            <summary>Компьютер поддерживает 32-разрядные слова</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.DebugStripped">
            <summary>Отладочная информация была удалена и сохранена отдельно в другом файле</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.RemovableRunFromSwap">
            <summary>Если изображение находится на съемном носителе, скопируйте его и запустите из файла подкачки</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.NetRunFromSwap">
            <summary>Если изображение находится в сети, скопируйте его и запустите из файла подкачки</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.System">
            <summary>Изображение представляет собой системный файл</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.Dll">
            <summary>
            Изображение представляет собой DLL-файл.
            Хотя это исполняемый файл, его нельзя запустить напрямую.
            </summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.UpSystemOnly">
            <summary>Файл должен запускаться только на однопроцессорном компьютере</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageFileHeader.CharacteristicsValue.BytesReversedHi">
            <summary>Байты слова меняются местами (устарело)</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.Magic">
            <summary>Состояние файла изображения</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.MagicValue.NT_HDR32">
            <summary>Файл представляет собой исполняемый образ</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.MagicValue.NT_HDR64">
            <summary>Файл представляет собой исполняемый образ</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.MagicValue.ROM_HDR">
            <summary>Файл представляет собой образ ПЗУ</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.LinkerVersion">
            <summary>Номер версии компоновщика</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfCode">
            <summary>Размер раздела кода в байтах или сумма всех таких разделов, если имеется несколько разделов кода</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfInitializedData">
            <summary>Размер раздела инициализированных данных в байтах или сумма всех таких разделов, если имеется несколько разделов инициализированных данных</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfUninitializedData">
            <summary>Размер неинициализированного раздела данных в байтах или сумма всех таких разделов, если имеется несколько неинициализированных разделов данных</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.AddressOfEntryPoint">
            <summary>Указатель на функцию точки входа относительно базового адреса изображения</summary>
            <remarks>
            Для исполняемых файлов это начальный адрес.
            Для драйверов устройств это адрес функции инициализации.
            Функция точки входа является необязательной для DLL.
            Если точка входа отсутствует, этот элемент равен нулю.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.BaseOfCode">
            <summary>Указатель на начало раздела кода относительно основы изображения</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.BaseOfData">
            <summary>Указатель на начало раздела данных относительно базы изображений</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageBase">
            <summary>Предпочтительный адрес первого байта изображения при его загрузке в память.</summary>
            <remarks>
            Это значение кратно 64 КБ байт.
            Значение по умолчанию для библиотек DLL равно <c>0x10000000</c>.
            Значение по умолчанию для приложений равно <c>0x00400000</c>,
            за исключением Windows CE, где оно равно <c>0x00010000</c>.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SectionAlignment">
            <summary>Выравнивание разделов, загруженных в память, в байтах</summary>
            <remarks>
            Это значение должно быть больше или равно члену <see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.FileAlignment"/>.<br/>
            Значением по умолчанию является размер страницы для системы.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.FileAlignment">
            <summary>Выравнивание необработанных данных разделов в файле изображения в байтах</summary>
            <remarks>
            Значение должно быть степенью 2 от 512 до 64 КБ (включительно).
            Значение по умолчанию равно 512.
            Если размер элемента <see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SectionAlignment"/> меньше размера системной страницы,
            этот элемент должен быть таким же, как SectionAlignment.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.OperatingSystemVersion">
            <summary>Номер версии требуемой операционной системы</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageVersion">
            <summary>Номер версии изображения</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemVersion">
            <summary>Номер версии подсистемы</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.Win32VersionValue">
            <summary>Этот элемент зарезервирован и должен быть равен 0</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfImage">
            <summary>Размер изображения в байтах, включая все заголовки</summary>
            <remarks>Должно быть кратно <see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SectionAlignment"/></remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfHeaders">
            <summary>
            Общий размер следующих элементов, округленный до кратного значения, указанного в элементе <see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.FileAlignment"/><br/>
            - <see cref="P:MathCore.PE.Headers.DOS.lfanew"/><br/>
            - подпись размером 4 байта<br/>
            - размер <see cref="T:MathCore.PE.Headers.NT.ImageFileHeader"/> = 20 байт<br/>
            - размер необязательного заголовка<br/>
            - размер всех заголовков разделов<br/>
            </summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.CheckSum">
            <summary>Контрольная сумма файла изображения</summary>
            <remarks>
            Во время загрузки проверяются следующие файлы:<br/>
            - все драйверы, любая библиотека DLL,<br/>
            - загруженная во время загрузки, и любая библиотека DLL,<br/>
            - загруженная в критический системный процесс.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.Subsystem">
            <summary>Подсистема, необходимая для запуска этого образа</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.Unknown">
            <summary>Неизвестная подсистема</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.Native">
            <summary>Подсистема не требуется (драйверы устройств и собственные системные процессы)</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.WindowsGUI">
            <summary>Подсистема графического пользовательского интерфейса (GUI) Windows</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.WindowsCUI">
            <summary>Подсистема пользовательского интерфейса (CUI) в символьном режиме Windows</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.OS2CUI">
            <summary>Подсистема CUI OS / 2</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.PosixCUI">
            <summary>Подсистема POSIX CUI</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.WindowsCEGUI">
            <summary>Система Windows CE</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.EFIApplication">
            <summary>Приложение с расширяемым интерфейсом встроенного программного обеспечения (EFI)</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.EFIBootServiceDriver">
            <summary>Драйвер EFI со службами загрузки</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.EFIRuntimeDriver">
            <summary>Драйвер EFI со службами времени выполнения</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.EFIROM">
            <summary>Образ EFI ROM</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.Xbox">
            <summary>Система Xbox</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.SubsystemValue.WindowsBootApplication">
            <summary>Загрузчик приложения</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristics">
            <summary>Характеристики DLL образа</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.HighEntropyVA">
            <summary>ASLR с 64-разрядным адресным пространством</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.DynamicBase">
            <summary>Библиотека DLL может быть перемещена во время загрузки</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.ForceIntegrity">
            <summary>Проверка целостности кода выполняется принудительно</summary>
            <remarks>
            Если вы установили этот флаг и раздел содержит только неинициализированные данные,
            установите для элемента PointerToRawData элемента <see cref="T:MathCore.PE.Headers.SectionHeader"/>
            для этого раздела значение ноль;
            в противном случае загрузка изображения не удастся,
            поскольку невозможно проверить цифровую подпись.
            </remarks>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.NxCompat">
            <summary>Изображение совместимо с предотвращением выполнения данных (DEP)</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.NoIsolation">
            <summary>Изображение поддерживает изоляцию, но не должно быть изолировано</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.NoSeh">
            <summary>Изображение не использует структурированную обработку исключений (SEH)</summary>
            <remarks>В этом изображении нельзя вызывать обработчики</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.NoBind">
            <summary>Не привязывайте изображение</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.AppContainer">
            <summary>Изображение должно выполняться в AppContainer</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.WdmDriver">
            <summary>Драйвер WDM</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.GuardCF">
            <summary>Изображение поддерживает защиту потока управления</summary>
        </member>
        <member name="F:MathCore.PE.Headers.NT.ImageOptionalHeader.DllCharacteristicsValue.ServerAware">
            <summary>Изображение поддерживает сервер терминалов</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfStack">
            <summary>Количество байтов, которые необходимо зарезервировать для стека</summary>
            <remarks>
            Во время загрузки выделяется только память, указанная членом <see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfStack"/>.<see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOf.Commit"/>;
            остальная часть становится доступной по одной странице за раз,
            пока не будет достигнут этот резервный размер.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOf.Reserve">
            <summary>Количество байт зарезервировано</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOf.Commit">
            <summary>Количество байт для фиксации</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfHeap">
            <summary>Количество байтов, которые необходимо зарезервировать для локальной кучи</summary>
            <remarks>
            Во время загрузки выделяется только память, указанная членом <see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOfHeap"/>.<see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.SizeOf.Commit"/>;
            остальная часть становится доступной по одной странице за раз,
            пока не будет достигнут этот резервный размер.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.LoaderFlags">
            <summary>Этот элемент устарел</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.NumberOfRvaAndSizes">
            <summary>Количество записей каталога в оставшейся части необязательного заголовка</summary>
            <remarks>Каждая запись описывает местоположение и размер</remarks>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.Export">
            <summary>Каталог экспортируемых объектов</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.Import">
            <summary>Каталог импортируемых объектов</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.Resource">
            <summary>Каталог ресурсов</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.Exception">
            <summary>Каталог исключений</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.Security">
            <summary>Каталог безопасности</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.BaseReloc">
            <summary>Таблица переадресации</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.Debug">
            <summary>Отладочный каталог</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.Copyright">
            <summary>Строки описания</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.TLS">
            <summary>Каталог TLS (Thread local storage - локальная память потоков)</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.Descriptor">
            <summary>Информация COM-объектов</summary>
        </member>
        <member name="T:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.ImageDataDirectoryValue">
            <summary>IMAGE_DATA_DIRECTORY</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.ImageDataDirectoryValue.VirtualAddress">
            <summary>Относительный виртуальный адрес таблицы</summary>
        </member>
        <member name="P:MathCore.PE.Headers.NT.ImageOptionalHeader.ImageDataDirectory.ImageDataDirectoryValue.Size">
            <summary>Размер таблицы в байтах</summary>
        </member>
        <member name="T:MathCore.PE.Headers.SectionHeader">
            <summary>IMAGE_SECTION_HEADER</summary>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.Name">
            <summary>8-байтовая строка UTF-8 с заполнением нулем</summary>
            <remarks>
            Завершающий нулевой символ отсутствует,
            если длина строки составляет ровно восемь символов.
            Для более длинных имен этот элемент содержит косую черту (/),
            за которой следует представление десятичного числа в формате ASCII,
            которое является смещением в таблице строк.
            Исполняемые образы не используют таблицу строк
            и не поддерживают имена разделов длиной более восьми символов.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.PhysicalAddress">
            <summary>Адрес файла</summary>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.VirtualSize">
            <summary>Общий размер раздела при загрузке в память, в байтах</summary>
            <remarks>
            Если это значение больше, чем элемент <see cref="P:MathCore.PE.Headers.SectionHeader.SizeOfRawData"/>, раздел заполняется нулями.
            Это поле действительно только для исполняемых образов и должно быть установлено в 0
            для объектных файлов
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.VirtualAddress">
            <summary>Адрес первого байта раздела при загрузке в память относительно базы изображений</summary>
            <remarks>Для объектных файлов это адрес первого байта перед применением перемещения</remarks>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.SizeOfRawData">
            <summary>Размер инициализированных данных на диске в байтах</summary>
            <remarks>
            Это значение должно быть кратно члену <see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.FileAlignment"/>
            структуры <see cref="T:MathCore.PE.Headers.NT.ImageOptionalHeader"/>.
            Если это значение меньше, чем элемент <see cref="P:MathCore.PE.Headers.SectionHeader.VirtualSize"/>,
            оставшаяся часть раздела заполняется нулями.
            Если раздел содержит только неинициализированные данные, член равен нулю.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.PointerToRawData">
            <summary>Указатель файла на первую страницу в файле COFF</summary>
            <remarks>
            Это значение должно быть кратно члену <see cref="P:MathCore.PE.Headers.NT.ImageOptionalHeader.FileAlignment"/>
            структуры <see cref="T:MathCore.PE.Headers.NT.ImageOptionalHeader"/>.
            Если раздел содержит только неинициализированные данные,
            установите для этого элемента значение ноль.
            </remarks>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.PointerToRelocations">
            <summary>Указатель файла на начало записей перемещения для раздела</summary>
            <remarks>Если перемещений нет, это значение равно нулю</remarks>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.PointerToLineNumbers">
            <summary>Указатель файла на начало записей с номерами строк для раздела</summary>
            <remarks>Если номера строк COFF отсутствуют, это значение равно нулю</remarks>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.NumberOfRelocations">
            <summary>Количество записей перемещения для раздела</summary>
            <remarks>Это значение равно нулю для исполняемых образов</remarks>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.NumberOfLineNumbers">
            <summary>Количество записей с номерами строк для раздела</summary>
        </member>
        <member name="P:MathCore.PE.Headers.SectionHeader.Characteristics">
            <summary>Характеристики изображения</summary>
        </member>
        <member name="T:MathCore.PE.Headers.SectionHeader.CharacteristicsValue">
            <summary>Характеристики изображения</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.TypeNoPad">
            <summary>Раздел не следует дополнять до следующей границы</summary>
            <remarks> Этот флаг устарел и заменяется на <see cref="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align1Bytes"/></remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.CntCode">
            <summary>Раздел содержит исполняемый код</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.CntInitializedData">
            <summary>Раздел содержит инициализированные данные</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.CntUninitializedData">
            <summary>Раздел содержит неинициализированные данные</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.LnkOther">
            <summary>Зарезервировано</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.LnkInfo">
            <summary>Раздел содержит комментарии или другую информацию</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.LnkRemove">
            <summary>Раздел не станет частью изображения</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.LnkComdat">
            <summary>Раздел содержит данные COMDAT</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.NoDeferSpecExc">
            <summary>Сбросьте биты обработки спекулятивных исключений в записях TLB для этого раздела</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Gprel">
            <summary>Раздел содержит данные, на которые ссылается глобальный указатель</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemPurgeable">
            <summary>Зарезервировано</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemLocked">
            <summary>Зарезервировано</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemPreload">
            <summary>Зарезервировано</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align1Bytes">
            <summary>Выровнять данные по границе в 1 байт</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align2Bytes">
            <summary>Выровняйте данные по 2-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align4Bytes">
            <summary>Выровняйте данные по 4-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align8Bytes">
            <summary>Выровняйте данные по 8-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align16Bytes">
            <summary>Выровняйте данные по 16-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align32Bytes">
            <summary>Выровняйте данные по 32-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align64Bytes">
            <summary>Выровняйте данные по 64-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align128Bytes">
            <summary>Выровняйте данные по 128-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align256Bytes">
            <summary>Выровняйте данные по 256-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align512Bytes">
            <summary>Выровняйте данные по 512-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align1024Bytes">
            <summary>Выровняйте данные по 1024-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align2048Bytes">
            <summary>Выровняйте данные по 2048-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align4096Bytes">
            <summary>Выровняйте данные по 4096-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.Align8192Bytes">
            <summary>Выровняйте данные по 8192-байтовой границе</summary>
            <remarks>Это действительно только для объектных файлов</remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.LnkNrelocOvfl">
            <summary>Раздел содержит расширенные перемещения</summary>
            <remarks>
            Количество перемещений для раздела превышает 16 бит,
            зарезервированных для него в заголовке раздела.
            Если поле <see cref="P:MathCore.PE.Headers.SectionHeader.NumberOfRelocations"/> в заголовке раздела равно <c>0xFFFF</c>,
            фактическое количество перемещений сохраняется в поле <see cref="P:MathCore.PE.Headers.SectionHeader.VirtualAddress"/>
            первого перемещения.
            Это ошибка, если установлено значение <see cref="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.LnkNrelocOvfl"/>
            и в разделе меньше перемещений <c>0xFFFF</c>.
            </remarks>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemDiscardable">
            <summary>Раздел может быть удален по мере необходимости</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemNotCached">
            <summary>Раздел не может быть кэширован</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemNotPaged">
            <summary>Раздел не может быть выгружен</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemShared">
            <summary>Раздел может быть общим в памяти</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemExecute">
            <summary>Раздел может быть выполнен в виде кода</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemRead">
            <summary>Раздел можно прочитать</summary>
        </member>
        <member name="F:MathCore.PE.Headers.SectionHeader.CharacteristicsValue.MemWrite">
            <summary>В раздел можно записать</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.Characteristics">
            <summary>Зарезервировано, всегда равно 0</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.TimeDateStamp">
            <summary>Дата и время создания таблицы экспорта в формате Unix</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.MajorVersion">
            <summary>Старшая цифра номера версии, не используется</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.MinorVersion">
            <summary>Младшая цифра номера версии, не используется</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.Name">
            <summary>RVA ASCIIZ-строки, содержащей имя данного файла</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.Base">
            <summary>Начальный номер экспортируемых символов (больше или равен 1)</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.NumberOfFunctions">
            <summary>Количество элементов в таблице адресов</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.NumberOfNames">
            <summary>Количество элементов в таблице имен и таблице номеров</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.AddressOfFunctions">
            <summary>RVA таблицы адресов</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.AddressOfNames">
            <summary>RVA таблицы имен</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals">
            <summary>RVA таблицы номеров</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_IMPORT_DESCRIPTOR.OriginalFirstThunk">
            <summary>RVA таблицы имен импорта (INT)</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp">
            <summary>Дата и время</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_IMPORT_DESCRIPTOR.ForwarderChain">
            <summary>Индекс первого перенаправленного символа</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_IMPORT_DESCRIPTOR.Name">
            <summary>RVA ASCIIZ-строки, содержащей имя DLL</summary>
        </member>
        <member name="P:MathCore.PE.Tables.IMAGE_IMPORT_DESCRIPTOR.FirstThunk">
            <summary>RVA таблицы адресов импорта (IAT)</summary>
        </member>
        <member name="T:MathCore.PIDController">
            <summary>Пропорционально-интегрально-дифференциальный регулятор</summary>
        </member>
        <member name="P:MathCore.PIDController.IntegralError">
            <summary>Интеграл ошибки</summary>
        </member>
        <member name="P:MathCore.PIDController.Error">
            <summary>Ошибка предыдущего шага управления</summary>
        </member>
        <member name="P:MathCore.PIDController.P">
            <summary>Коэффициент пропорционального регулирования</summary>
        </member>
        <member name="P:MathCore.PIDController.I">
            <summary>Коэффициент интегрального регулирования</summary>
        </member>
        <member name="P:MathCore.PIDController.D">
            <summary>Коэффициент дифференциального регулирования</summary>
        </member>
        <member name="M:MathCore.PIDController.#ctor(System.Double,System.Double,System.Double)">
            <summary>Инициализация нового PID-регулятора</summary>
            <param name="P">Коэффициент пропорционального регулирования</param>
            <param name="I">Коэффициент интегрального регулирования</param>
            <param name="D">Коэффициент дифференциального регулирования</param>
        </member>
        <member name="M:MathCore.PIDController.Process(System.Double,System.Double,System.Double)">
            <summary>Обработка очередного значения</summary>
            <param name="Input">Текущее значение</param>
            <param name="Target">Требуемое значение</param>
            <param name="dt">Интервал времени, прошедший после предыдущего измерения</param>
            <returns>Регулирующий сигнал</returns>
        </member>
        <member name="T:MathCore.Polynom">
            <summary>
            Полином степени N-1
             a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)
            где N - число элементов массива коэффициентов
            Нулевой элемент массива при нулевой степени члена полинома 
            </summary>
        </member>
        <member name="T:MathCore.Polynom.Array">
            <summary>Операции над коэффициентами полинома, в представлении массива значений</summary>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Double[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,System.Double[])">
            <summary>Рассчитать комплексное значение полинома</summary>
            <param name="z">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,MathCore.Complex[])">
            <summary>Рассчитать комплексное значение полинома</summary>
            <param name="z">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,MathCore.Complex[])">
            <summary>Рассчитать комплексное значение полинома с комплексными коэффициентами</summary>
            <param name="z">Комплексный аргумент полинома</param>
            <param name="A">Массив комплексных коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Collections.Generic.IList{System.Double})">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,System.Collections.Generic.IList{System.Double})">
            <summary>Рассчитать комплексное значение полинома</summary>
            <param name="z">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Collections.Generic.IList{MathCore.Complex})">
            <summary>Рассчитать комплексное значение полинома</summary>
            <param name="z">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,System.Collections.Generic.IList{MathCore.Complex})">
            <summary>Рассчитать комплексное значение полинома с комплексными коэффициентами</summary>
            <param name="z">Комплексный аргумент полинома</param>
            <param name="A">Массив комплексных коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Рассчитать комплексное значение полинома</summary>
            <param name="z">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Рассчитать комплексное значение полинома</summary>
            <param name="z">Аргумент полинома</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Рассчитать комплексное значение полинома с комплексными коэффициентами</summary>
            <param name="z">Комплексный аргумент полинома</param>
            <param name="A">Массив комплексных коэффициентов полинома</param>
            <returns>Комплексное значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Double@,System.Double[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="dy">Значение первой производной в точке</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,MathCore.Complex@,System.Double[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="dy">Значение первой производной в точке</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,MathCore.Complex@,MathCore.Complex[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="dy">Значение первой производной в точке</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,MathCore.Complex@,MathCore.Complex[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="dy">Значение первой производной в точке</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,System.Double@,System.Double@,System.Double[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="dy">Значение первой производной в точке</param>
            <param name="d2y">Значение второй производной в точке</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(System.Double,MathCore.Complex@,MathCore.Complex@,MathCore.Complex[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="dy">Значение первой производной в точке</param>
            <param name="d2y">Значение второй производной в точке</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,MathCore.Complex@,MathCore.Complex@,System.Double[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="dy">Значение первой производной в точке</param>
            <param name="d2y">Значение второй производной в точке</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetValue(MathCore.Complex,MathCore.Complex@,MathCore.Complex@,MathCore.Complex[])">
            <summary>Рассчитать значение полинома</summary>
            <param name="x">Аргумент полинома</param>
            <param name="dy">Значение первой производной в точке</param>
            <param name="d2y">Значение второй производной в точке</param>
            <param name="A">Массив коэффициентов полинома</param>
            <returns>Значение полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficients(System.Double[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficients(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Преобразовать последовательность корней полинома в коэффициенты при степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficients(System.Double[],System.Double[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при степенях</summary>
            <param name="Root">Массив корней полинома</param>
            <param name="a">Массив, который требуется рассчитать коэффициенты полинома (длина должна быть на 1 больше массива <paramref name="Root"/>)</param>
            <exception cref="T:System.InvalidOperationException">При <paramref name="a"/><c>.Length</c> != <paramref name="Root"/><c>.Length + 1</c></exception>
            <exception cref="T:System.ArgumentException">При <paramref name="Root"/><c>.Length</c> == 0</exception>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficientsInverted(System.Double[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при обратных степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при обратных степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficients(MathCore.Complex[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficients(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Преобразовать последовательность корней полинома в коэффициенты при степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficients(MathCore.Complex[],MathCore.Complex[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при степенях</summary>
            <param name="Root">Массив корней полинома</param>
            <param name="a">Массив, который требуется рассчитать коэффициенты полинома (длина должна быть на 1 больше массива <paramref name="Root"/>)</param>
            <exception cref="T:System.InvalidOperationException">При <paramref name="a"/><c>.Length</c> != <paramref name="Root"/><c>.Length + 1</c></exception>
            <exception cref="T:System.ArgumentException">При <paramref name="Root"/><c>.Length</c> == 0</exception>
        </member>
        <member name="M:MathCore.Polynom.Array.GetCoefficientsInverted(MathCore.Complex[])">
            <summary>Преобразовать массив корней полинома в коэффициенты при обратных степенях</summary>
            <param name="Root">Корни полинома</param>
            <returns>Коэффициенты при обратных степенях</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetDifferential(System.Double[],System.Int32)">
            <summary>Дифференциал полинома</summary>
            <param name="p">Массив коэффициентов полинома</param>
            <param name="Order">Порядок дифференцирования</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Если <paramref name="Order"/> &gt; 20</exception>
            <returns>Массив коэффициентов полинома - дифференциала</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetDifferential(MathCore.Complex[],System.Int32)">
            <summary>Дифференциал полинома</summary>
            <param name="p">Массив коэффициентов полинома</param>
            <param name="Order">Порядок дифференцирования</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Если <paramref name="Order"/> &gt; 20</exception>
            <returns>Массив коэффициентов полинома - дифференциала</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetIntegral(System.Double[],System.Double,System.Int32)">
            <summary>Интеграл полинома</summary>
            <param name="p">Массив коэффициентов полинома</param>
            <param name="C">Константа интегрирования</param>
            <param name="Order">Кратность интегрирования</param>
            <returns>Массив коэффициентов полинома - интеграла</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.GetIntegral(MathCore.Complex[],MathCore.Complex,System.Int32)">
            <summary>Интеграл полинома</summary>
            <param name="p">Массив коэффициентов полинома</param>
            <param name="C">Константа интегрирования</param>
            <param name="Order">Кратность интегрирования</param>
            <returns>Массив коэффициентов полинома - интеграла</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Sum(System.Double[],System.Double[])">
            <summary>Суммирование полиномов</summary>
            <param name="p">Коэффициенты полинома - первого слагаемого</param>
            <param name="q">Коэффициенты полинома - первого слагаемого</param>
            <returns>Коэффициенты полинома - суммы</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Subtract(System.Double[],System.Double[])">
            <summary>Разность полиномов</summary>
            <param name="p">Коэффициенты полинома - первого уменьшаемого</param>
            <param name="q">Коэффициенты полинома - первого вычитаемого</param>
            <returns>Коэффициенты полинома - разности</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Divide(System.Double[],System.Double[],System.Double[]@,System.Double[]@)">
            <summary>Деление полиномов</summary>
            <param name="dividend">Коэффициенты полинома - делимое</param>
            <param name="divisor">Коэффициенты полинома - делитель</param>
            <param name="quotient">Коэффициенты полинома - частного</param>
            <param name="remainder">Коэффициенты полинома - остаток от деления</param>
            <returns>Коэффициенты полинома - частное</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Multiply(System.Double[],System.Double[])">
            <summary>Умножение полиномов</summary>
            <param name="p">Коэффициенты полинома - первый сомножитель</param>
            <param name="q">Коэффициенты полинома - второй сомножитель</param>
            <returns>Коэффициенты полинома - произведение</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Add(System.Double[],System.Double)">
            <summary>Сложение полинома с вещественным числом</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - суммы</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Subtract(System.Double[],System.Double)">
            <summary>Вычитание вещественного числа из полинома</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - разности</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Subtract(System.Double,System.Double[])">
            <summary>Вычитание полинома из вещественного числа</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - разности</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Negate(System.Double[])">
            <summary>Отрицание полинома</summary>
            <param name="p">Коэффициенты полинома</param>
            <returns>Коэффициенты полинома Q(x) = 0 - P(x)</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Multiply(System.Double[],System.Double)">
            <summary>Умножение полинома на вещественное число</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - произведения</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.Divide(System.Double[],System.Double)">
            <summary>Деление полинома на вещественное число</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - частного</returns>
        </member>
        <member name="M:MathCore.Polynom.Array.DivideScalar(System.Double,System.Double[])">
            <summary>Скалярное деление полинома на вещественное число</summary>
            <param name="p">Коэффициенты полинома</param>
            <param name="x">Вещественное число</param>
            <returns>Коэффициенты полинома - частного</returns>
        </member>
        <member name="T:MathCore.Polynom.PolynomDivisionResult">
            <summary>Результат деления полиномов</summary>
        </member>
        <member name="P:MathCore.Polynom.PolynomDivisionResult.Result">
            <summary>Частное полиномов</summary>
        </member>
        <member name="P:MathCore.Polynom.PolynomDivisionResult.Remainder">
            <summary>Остаток деления полиномов</summary>
        </member>
        <member name="P:MathCore.Polynom.PolynomDivisionResult.Divisor">
            <summary>Полином - делитель</summary>
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.#ctor(MathCore.Polynom,MathCore.Polynom,MathCore.Polynom)">
            <summary>Инициализация результата деления полиномов</summary>
            <param name="Divisor"></param>
            <param name="Result">Частное</param>
            <param name="Remainder">Остаток от деления</param>
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.Value(System.Double)">
            <summary>Значение результата деления полиномов</summary>
            <param name="x">Аргумент</param>
            <returns>Результат вычисления значения результата деления полиномов</returns>
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.GetFunction">
            <summary>Получить функцию</summary>
            <returns>Функция вычисления значения результата деления полиномов</returns>
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.PolynomDivisionResult.op_Implicit(MathCore.Polynom.PolynomDivisionResult)~MathCore.Polynom">
            <summary>Оператор неявного преобразования результата деления полиномов в полином результата</summary>
            <param name="Result">Результат деления полиномов</param>
            <returns>Частное</returns>
        </member>
        <member name="M:MathCore.Polynom.Random(System.Int32,System.Double,System.Double,System.Random)">
            <summary>Случайный полином</summary>
            <param name="Power">Степень полинома</param>
            <param name="Ma">Математическое ожидание коэффициентов полинома</param>
            <param name="Da">Дисперсия коэффициентов полинома</param>
            <param name="rnd">Генератор случайных чисел</param>
            <returns>Случайный полином</returns>
        </member>
        <member name="M:MathCore.Polynom.FromCoefficients(System.Double[])">
            <summary>Создание нового полинома из массива его коэффициентов</summary>
            <param name="a">Массив коэффициентов полинома</param>
            <returns>Полином, созданный на основе массива его коэффициентов</returns>
        </member>
        <member name="M:MathCore.Polynom.FromRoots(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Создание нового полинома на основе его корней</summary>
            <param name="roots">Корни полинома</param>
            <returns>Полином, собранный из массива корней</returns>
        </member>
        <member name="M:MathCore.Polynom.FromRoots(System.Double[])">
            <summary>Получить полином из корней полинома</summary>
            <param name="Root">Корни полинома</param>
            <returns>Полином с указанными корнями</returns>
        </member>
        <member name="F:MathCore.Polynom._a">
            <summary>Коэффициенты при степенях</summary>
            <remarks>a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</remarks>
        </member>
        <member name="P:MathCore.Polynom.Coefficients">
            <summary>
            Коэффициенты при степенях
              a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)
            </summary>
        </member>
        <member name="P:MathCore.Polynom.Power">
            <summary>Степень полинома = число коэффициентов - 1</summary>
        </member>
        <member name="P:MathCore.Polynom.Length">
            <summary>Длина полинома - число коэффициентов</summary>
        </member>
        <member name="P:MathCore.Polynom.Item(System.Int32)">
            <summary>
             Коэффициент при степени <paramref name="n"/>, где <paramref name="n"/> принадлежит [0; <see cref="P:MathCore.Polynom.Power"/>]
             <see cref="P:MathCore.Polynom.Power"/> = <see cref="P:MathCore.Polynom.Length"/> - 1
             </summary>
            <param name="n">Степень a[0]+a[1]*x+a[2]*x^2+...<b>+a[<paramref name="n"/>]*x^<paramref name="n"/>+</b>...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</param>
        </member>
        <member name="M:MathCore.Polynom.#ctor(System.Double[])">
            <summary>Полином степени N, нулевой элемент массива a[0] при младшей степени x^0</summary>
            <param name="a">a[0]+a[1]*x+a[2]*x^2+...+a[N-1]*x^(N-1)+a[N-1]*x^(N-1)</param>
        </member>
        <member name="M:MathCore.Polynom.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.Value(System.Double)">
            <summary>Получить значение полинома</summary>
            <param name="x">Аргумент</param>
            <returns>Значение полинома в точке x</returns>
        </member>
        <member name="M:MathCore.Polynom.Value(MathCore.Complex)">
            <summary>Вычислить комплексное значение полинома</summary>
            <param name="z">Комплексный аргумент</param>
            <returns>Комплексное значение полинома в точке</returns>
        </member>
        <member name="M:MathCore.Polynom.GetFunction">
            <summary>Получить функцию полинома</summary>
            <returns>Функция полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.GetComplexFunction">
            <summary>Получить комплексную функцию полинома</summary>
            <returns>Комплексная функция полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.DivideTo(MathCore.Polynom,MathCore.Polynom@)">
            <summary>Выполнить операцию деления полинома на полином</summary>
            <param name="Divisor">Полином - делимое</param>
            <param name="Remainder">Полином - делитель</param>
            <returns>Полином - частное</returns>
        </member>
        <member name="M:MathCore.Polynom.ToMathString">
            <summary>Представить полином в виде математической записи в степенной форме</summary>
            <returns>Строковое представление полинома в степенной форме</returns>
        </member>
        <member name="M:MathCore.Polynom.GetDifferential(System.Int32)">
            <summary>Дифференцирование полинома</summary>
            <param name="Order">Порядок дифференциала</param>
            <returns>Полином - результат дифференцирования</returns>
        </member>
        <member name="M:MathCore.Polynom.GetIntegral(System.Double,System.Int32)">
            <summary>Интегрирование полинома</summary>
            <param name="C">Константа интегрирования</param>
            <param name="Order">Кратность интеграла</param>
            <returns>Полином - результат интегрирования полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.GetInversed">
            <summary>Вычислить обратный полином</summary>
            <returns>Полином, являющийся обратным к текущим</returns>
        </member>
        <member name="M:MathCore.Polynom.ScalePolynom(System.Double)">
            <summary>Масштабирование полинома Q(x) = P(x * c)</summary>
            <param name="c">Коэффициент масштабирования полинома</param>
            <returns>Отмасштабированный полином</returns>
        </member>
        <member name="M:MathCore.Polynom.Substitute(MathCore.Polynom)">
            <summary>Подстановка полинома x' = P(x) в полином Q(x')=Q(P(x))</summary>
            <param name="P">Полином - подстановка</param>
            <returns>Полином - результат подстановки</returns>
        </member>
        <member name="M:MathCore.Polynom.Equals(MathCore.Polynom)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.System#Collections#Generic#IEnumerable{System#Double}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Polynom.ToString(System.String)">
            <summary>Строковое представление полинома с форматированием</summary>
            <param name="Format">Строка форматирования</param>
            <returns>Форматированное представление полинома</returns>
        </member>
        <member name="T:MathCore.Polynom.Expression">
            <summary>Класс операций над полиномом, связанных с деревьями выражений</summary>
        </member>
        <member name="M:MathCore.Polynom.Expression.GetExpression(System.Double[])">
            <summary>Построение дерева выражения на основе коэффициентов полинома</summary>
            <param name="A">Коэффициенты полинома</param>
            <returns>Дерево выражения, представляющее собой метод вычисления значения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Expression.GetExpressionComplex(System.Double[])">
            <summary>Построение дерева комплексного выражения на основе коэффициентов полинома</summary>
            <param name="A">Коэффициенты полинома</param>
            <returns>Дерево выражения, представляющее собой метод вычисления комплексного значения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.Expression.GetExpression(MathCore.Complex[])">
            <summary>Построение дерева комплексного выражения на основе комплексных коэффициентов полинома</summary>
            <param name="A">Комплексные коэффициенты полинома</param>
            <returns>Дерево выражения, представляющее собой метод вычисления комплексного значения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.GetExpression">
            <summary>Получение дерева выражения полинома</summary>
            <returns>Дерево выражения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.GetExpressionComplex">
            <summary>Получение дерева выражения полинома</summary>
            <returns>Дерево выражения полинома</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(MathCore.Polynom)~System.Func{System.Double,System.Double}">
            <summary>Явное приведение типов полинома к делегату функции преобразования double->double</summary>
            <param name="P">Полином</param>
            <returns>Делегат функции преобразования</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(MathCore.Polynom)~System.Func{MathCore.Complex,MathCore.Complex}">
            <summary>Явное приведение типов полинома к делегату комплексной функции преобразования Complex->Complex</summary>
            <param name="P">Полином</param>
            <returns>Делегат комплексной функции преобразования</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Addition(MathCore.Polynom,MathCore.Polynom)">
            <summary>Оператор сложения двух полиномов</summary>
            <param name="P">Первое слагаемое</param>
            <param name="Q">Второе слагаемое</param>
            <returns>Сумма полиномов</returns>
        </member>
        <member name="M:MathCore.Polynom.op_UnaryNegation(MathCore.Polynom)">
            <summary>
            Оператор отрицания полинома (изменяет знак всех коэффициентов на обратной). Эквивалентно умножению полинома на -1
            </summary>
            <param name="P">Отрицаемый полином</param>
            <returns>Полином Q = -P</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Subtraction(MathCore.Polynom,MathCore.Polynom)">
            <summary>Оператор вычитания полинома Q из полинома P</summary>
            <param name="P">Уменьшаемое</param>
            <param name="Q">Вычитаемое</param>
            <returns>Разность</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Multiply(MathCore.Polynom,MathCore.Polynom)">
            <summary>Оператор произведения полинома Q и полинома P</summary>
            <param name="P">Первый сомножитель</param>
            <param name="Q">Второй сомножитель</param>
            <returns>Произведение полиномов</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Division(MathCore.Polynom,MathCore.Polynom)">
            <summary>Оператор деления двух полиномов</summary>
            <param name="p">Полином делимого</param>
            <param name="q">Полином делителя</param>
            <returns>Результат деления полиномов, включающий частное и остаток от деления</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Multiply(MathCore.Polynom,System.Double)">
            <summary>Умножение полинома на вещественное число</summary>
            <param name="P">Полином</param>
            <param name="q">Вещественное число</param>
            <returns>Полином - результат умножения исходного полинома на вещественное число</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Multiply(System.Double,MathCore.Polynom)">
            <summary>Умножение полинома на вещественное число</summary>
            <param name="p">Вещественное число</param>
            <param name="Q">Полином</param>
            <returns>Полином - результат умножения исходного полинома на вещественное число</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Division(MathCore.Polynom,System.Double)">
            <summary>Деление полинома на вещественное число</summary>
            <param name="P">Полином</param>
            <param name="q">Вещественное число</param>
            <returns>Полином - результат деления исходного полинома на вещественное число</returns>
        </member>
        <member name="M:MathCore.Polynom.op_RightShift(MathCore.Polynom,System.Int32)">
            <summary>Оператор дифференцирования</summary>
            <param name="p">Дифференцируемый полином</param>
            <param name="Order">Порядок дифференцирования</param>
            <returns>Полином - результат дифференцирования</returns>
        </member>
        <member name="M:MathCore.Polynom.op_LeftShift(MathCore.Polynom,System.Int32)">
            <summary>Оператор интегрирования</summary>
            <param name="p">Дифференцируемый полином</param>
            <param name="Order">Кратность интегрирования</param>
            <returns>Полином - результат интегрирования</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Explicit(MathCore.Polynom)~System.Double[]">
            <summary>Оператор неявного приведения типа полинома в массив вещественных значений коэффициентов</summary>
            <param name="p">Полином</param>
            <returns>Массив значений коэффициентов</returns>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(System.Double)~MathCore.Polynom">
            <summary>Оператор приведения типа вещественного числа к типу полинома</summary>
            <param name="a">Вещественное число</param>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(System.Single)~MathCore.Polynom">
            <summary>Оператор приведения типа вещественного числа к типу полинома</summary>
            <param name="a">Вещественное число</param>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(System.Int32)~MathCore.Polynom">
            <summary>Оператор приведения типа целого числа к типу полинома</summary>
            <param name="a">Целое число</param>
        </member>
        <member name="M:MathCore.Polynom.op_Implicit(System.Int16)~MathCore.Polynom">
            <summary>Оператор приведения типа целого числа к типу полинома</summary>
            <param name="a">Целое число</param>
        </member>
        <member name="M:MathCore.PrecisionTimer.#ctor">
            <exception cref="T:System.PlatformNotSupportedException">В случае если платформа не Win32NT</exception>
        </member>
        <member name="M:MathCore.PrecisionTimer.Dispose">
            <inheritdoc />
        </member>
        <member name="M:MathCore.PrecisionTimer.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов и остановка таймера</summary>
            <param name="disposing">Требуется выполнить освобождение управляемых ресурсов</param>
        </member>
        <member name="M:MathCore.PrecisionTimer.Initialize">
            <exception cref="T:System.PlatformNotSupportedException">В случае если платформа не Win32NT</exception>
        </member>
        <member name="T:MathCore.PrimeNumbers">
            <summary>Алгоритмы для Простых чисел</summary>
        </member>
        <member name="M:MathCore.PrimeNumbers.GetNumbersTo(System.Int32)">
            <summary>Поиск простых чисел с использованием алгоритма "Решето Эратосфен"</summary>
            <param name="n">Предельное значение до которого (включительно) осуществляется поиск</param>
            <returns>Перечисление найденных простых чисел</returns>
        </member>
        <member name="T:MathCore.PrimeNumbers.Wheel235">
            <remarks>
             <code>
                 long N = 100_000_000_000L;
                 var wheel = new Wheel235(N);
                 wheel.Save("./primes.dat");
            
                 ...
             
                 var start = DateTime.UtcNow;
                 var loaded = new Wheel235("./primes.dat");
                 var end = DateTime.UtcNow;
                 Console.WriteLine($"Database of prime numbers up to {loaded.Length:N0} loaded from file to memory  in {end - start}");
                 var number = 98_000_000_093L;
                 Console.WriteLine($"{number:N0} is {(loaded.IsPrime(number) ? "prime" : "not prime")}!");
             </code>
             </remarks>
        </member>
        <member name="T:MathCore.ProgressCallCountDecimator`1">
            <summary>Информатор прогресса операции, осуществляющий прореживание вызовов к информатору по числу вызовов</summary>
            <typeparam name="T">Тип данных информатора</typeparam>
        </member>
        <member name="P:MathCore.ProgressCallCountDecimator`1.CallCount">
            <summary>Число пропускаемых вызовов</summary>
        </member>
        <member name="T:MathCore.ProgressTimeoutDecimator`1">
            <summary>Информатор прогресса операции, осуществляющий прореживание вызовов по времени</summary>
            <typeparam name="T">Тип данных информатора</typeparam>
        </member>
        <member name="P:MathCore.ProgressTimeoutDecimator`1.Timeout">
            <summary>Таймаут между вызовами</summary>
        </member>
        <member name="T:MathCore.Queries.IPagedQueryable`1">
            <summary>Страница запроса</summary>
            <typeparam name="T">Тип элементов запроса</typeparam>
        </member>
        <member name="P:MathCore.Queries.IPagedQueryable`1.SourceQuery">
            <summary>Исходный запрос</summary>
        </member>
        <member name="P:MathCore.Queries.IPagedQueryable`1.Page">
            <summary>Номер страницы</summary>
        </member>
        <member name="P:MathCore.Queries.IPagedQueryable`1.PageSize">
            <summary>Число элементов на странице</summary>
        </member>
        <member name="P:MathCore.Queries.IPagedQueryable`1.PagesCount">
            <summary>Общее число страниц</summary>
        </member>
        <member name="T:MathCore.Queries.QueryOptions">
            <summary>Параметры запроса</summary>
        </member>
        <member name="F:MathCore.Queries.QueryOptions.__OrderBy">
            <summary>Метод упорядочивания запроса по возрастанию</summary>
        </member>
        <member name="F:MathCore.Queries.QueryOptions.__OrderByDescending">
            <summary>Метод упорядочивания запроса по убыванию</summary>
        </member>
        <member name="M:MathCore.Queries.QueryOptions.GetMethodInfo(System.Type,System.Type,System.Boolean)">
            <summary>Получить метод упорядочивания для заданного типа данных и типа ключа упорядочивания</summary>
            <param name="ItemsType">Тип упорядочиваемых элементов</param>
            <param name="SortingKeyType">Тип ключа, по которому должна выполняться сортировка значений</param>
            <param name="IsDescending">Упорядочивать ли по убыванию?</param>
            <returns>Информация о методе, выполняющем упорядочивание</returns>
        </member>
        <member name="F:MathCore.Queries.QueryOptions.__Selectors">
            <summary>Пулл методов упорядочивания элементов</summary>
        </member>
        <member name="M:MathCore.Queries.QueryOptions.GetMethod``1(System.Type,System.Boolean)">
            <summary>Получить метод, формирующий запрос с упорядочиванием элементов</summary>
            <typeparam name="TItems">Тип упорядочиваемых элементов</typeparam>
            <param name="SortingKeyType">Тип ключа, по которому должна выполняться сортировка значений</param>
            <param name="IsDescending">Упорядочивать ли по убыванию?</param>
            <returns>Метод, выполняющем упорядочивание</returns>
        </member>
        <member name="P:MathCore.Queries.QueryOptions.Page">
            <summary>Номер страницы (начиная с нуля)</summary>
        </member>
        <member name="P:MathCore.Queries.QueryOptions.Size">
            <summary>Число элементов на странице (по умолчанию 10)</summary>
        </member>
        <member name="P:MathCore.Queries.QueryOptions.OrderProperty">
            <summary>Свойство, по которому выполняется упорядочивание</summary>
        </member>
        <member name="P:MathCore.Queries.QueryOptions.OrderByDescending">
            <summary>Выполнять ли упорядочивание по убыванию?</summary>
        </member>
        <member name="P:MathCore.Queries.QueryOptions.SearchProperty">
            <summary>Свойство, используемое для поиска</summary>
        </member>
        <member name="P:MathCore.Queries.QueryOptions.SearchTerm">
            <summary>Искомое значение</summary>
        </member>
        <member name="M:MathCore.Queries.QueryOptions.Items``1(System.Linq.IQueryable{``0})">
            <summary>Сформировать отфильтрованный и упорядоченный запрос</summary>
            <typeparam name="T">Тип элементов запроса</typeparam>
            <param name="query">Исходный запрос</param>
            <returns>Кортеж, содержащий упорядоченный и отфильтрованный запрос, а также число элементов исходного запроса</returns>
        </member>
        <member name="M:MathCore.Queries.QueryOptions.GetProperty(System.Linq.Expressions.Expression,System.String)">
            <summary>Сформировать выражение <see cref="T:System.Linq.Expressions.Expression"/> для доступа к указанному свойству</summary>
            <param name="x">Объект, свойство которого требуется получить</param>
            <param name="PropertyQuery">Строка с определением свойства</param>
            <returns>Выражение, определяющее доступ указанному свойству</returns>
        </member>
        <member name="M:MathCore.Queries.QueryOptions.Order``1(System.Linq.IQueryable{``0})">
            <summary>Метод, осуществляющий упорядочивание элементов запроса</summary>
            <typeparam name="T">Тип элементов запроса</typeparam>
            <param name="query">Исходный запрос</param>
            <returns>Упорядоченный запрос</returns>
        </member>
        <member name="M:MathCore.Queries.QueryOptions.Search``1(System.Linq.IQueryable{``0})">
            <summary>Метод, осуществляющий фильтрацию элементов запроса</summary>
            <typeparam name="T">Тип элементов запроса</typeparam>
            <param name="query">Исходный запрос</param>
            <returns>Отфильрованный запрос</returns>
        </member>
        <member name="T:MathCore.Queries.QueryResult`1">
            <summary>Результат выполнения запроса с разбиением на страницы, упорядочиванием и фильтрацией</summary>
            <typeparam name="T">Тип элементов запроса</typeparam>
        </member>
        <member name="F:MathCore.Queries.QueryResult`1._Query">
            <summary>Сформированный запрос</summary>
        </member>
        <member name="F:MathCore.Queries.QueryResult`1._TotalItemsCount">
            <summary>Число элементов исходного запроса</summary>
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.Options">
            <summary>Параметры запроса</summary>
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.Page">
            <summary>Номер страницы (начиная с нуля)</summary>
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.PageSize">
            <summary>Размер страницы (по умолчанию 10)</summary>
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.PagesCount">
            <summary>Число страниц исходного запроса</summary>
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.HasPreviousPage">
            <summary>Существует ли предыдущая страница?</summary>
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.HasNextPage">
            <summary>Существует ли следующая страница?</summary>
        </member>
        <member name="M:MathCore.Queries.QueryResult`1.GetPreviousPage">
            <summary>Получить результат запроса для предыдущей страницы</summary>
            <returns>Результата запроса для предыдущей страницы</returns>
        </member>
        <member name="M:MathCore.Queries.QueryResult`1.GetNextPage">
            <summary>Получить результат запроса для следующей страницы</summary>
            <returns>Результата запроса для следующей страницы</returns>
        </member>
        <member name="M:MathCore.Queries.QueryResult`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Queries.QueryResult`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.System#Linq#IQueryable#ElementType">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.System#Linq#IQueryable#Expression">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Queries.QueryResult`1.System#Linq#IQueryable#Provider">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Randomizer`1">
            <summary>Генератор случайных элементов из списка</summary>
            <typeparam name="T">Тип элементов</typeparam>
        </member>
        <member name="T:MathCore.RandomNormal">
            <summary>Генератор случайных чисел с нормальным распределением</summary>
        </member>
        <member name="P:MathCore.RandomNormal.Sigma">
            <summary>Среднеквадратичное отклонение</summary>
        </member>
        <member name="P:MathCore.RandomNormal.Mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="T:MathCore.RationalFunction">
            <summary>Рациональная функция - отношение полиномов</summary>
        </member>
        <member name="F:MathCore.RationalFunction._P">
            <summary>Массив коэффициентов числителя</summary>
        </member>
        <member name="F:MathCore.RationalFunction._Q">
            <summary>Массив коэффициентов знаменателя</summary>
        </member>
        <member name="P:MathCore.RationalFunction.P">
            <summary>полином числителя</summary>
        </member>
        <member name="P:MathCore.RationalFunction.Q">
            <summary>Полином знаменателя</summary>
        </member>
        <member name="P:MathCore.RefArrayView`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.RefArrayView`1.System#Collections#ICollection#IsSynchronized">
            <inheritdoc />
        </member>
        <member name="P:MathCore.RefArrayView`1.System#Collections#ICollection#SyncRoot">
            <inheritdoc />
        </member>
        <member name="P:MathCore.RefArrayView`1.System#Collections#ICollection#Count">
            <inheritdoc />
        </member>
        <member name="M:MathCore.RefArrayView`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.RefArrayView`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.RefArrayView`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Reflection.AnimatedDoubleProperty`1">
            <summary>Анимация вещественного свойства</summary>
            <typeparam name="TObject">Тип объекта, анимацию свойства которого требуется выполнить</typeparam>
        </member>
        <member name="M:MathCore.Reflection.AnimatedDoubleProperty`1.#ctor(`0,System.String,System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Double},System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Reflection.AnimatedDoubleProperty`1"/></summary>
            <param name="o">Объект, свойство которого анимируется</param>
            <param name="Name">Имя анимируемого свойства</param>
            <param name="Samples">Число шагов анимации</param>
            <param name="Timeout">Временной интервал анимации</param>
            <param name="Translator">Функция, вычисляющая очередное значение свойства на основе номера шага анимации и числа шагов</param>
            <param name="Private">Искать приватное свойство?</param>
        </member>
        <member name="T:MathCore.Reflection.AnimatedIntProperty`1">
            <summary>Анимация целочисленного свойства</summary>
            <typeparam name="TObject">Тип объекта, анимацию свойства которого требуется выполнить</typeparam>
        </member>
        <member name="M:MathCore.Reflection.AnimatedIntProperty`1.#ctor(`0,System.String,System.Int32,System.Int32,System.Func{System.Int32,System.Int32,System.Int32},System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Reflection.AnimatedIntProperty`1"/></summary>
            <param name="o">Объект, свойство которого анимируется</param>
            <param name="Name">Имя анимируемого свойства</param>
            <param name="Samples">Число шагов анимации</param>
            <param name="Timeout">Временной интервал анимации</param>
            <param name="Translator">Функция, вычисляющая очередное значение свойства на основе номера шага анимации и числа шагов</param>
            <param name="Private">Искать приватное свойство?</param>
        </member>
        <member name="T:MathCore.Reflection.AnimatedProperty`2">
            <summary>Анимированное свойство</summary>
            <typeparam name="TObject">Тип объекта, свойство которого требуется анимировать</typeparam>
            <typeparam name="TValue">Тип значения анимируемого свойства</typeparam>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Samples">
            <summary>Число шагов анимации</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Timeout">
            <summary>Интервал времени анимации в секундах</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Translator">
            <summary>Функция, вычисляющая очередное значение свойства на основе номера шага анимации и числа шагов</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Enabled">
            <summary>Признак активности анимации</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Thread">
            <summary>поток в котором будет происходить изменение значений свойства</summary>
        </member>
        <member name="F:MathCore.Reflection.AnimatedProperty`2._Priority">
            <summary>Приоритет потока анимации</summary>
        </member>
        <member name="P:MathCore.Reflection.AnimatedProperty`2.Enable">
            <summary>Анимация включена</summary>
        </member>
        <member name="P:MathCore.Reflection.AnimatedProperty`2.Priority">
            <summary>Приоритет потока анимации</summary>
        </member>
        <member name="P:MathCore.Reflection.AnimatedProperty`2.Repeat">
            <summary>Повторять анимацию в цикле?</summary>
        </member>
        <member name="P:MathCore.Reflection.AnimatedProperty`2.AutoReverse">
            <summary>По завершении прямого хода анимации выполнять обратный</summary>
        </member>
        <member name="M:MathCore.Reflection.AnimatedProperty`2.#ctor(`0,System.String,System.Int32,System.Int32,System.Func{System.Int32,System.Int32,`1},System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Reflection.AnimatedIntProperty`1"/></summary>
            <param name="o">Объект, свойство которого анимируется</param>
            <param name="Name">Имя анимируемого свойства</param>
            <param name="Samples">Число шагов анимации</param>
            <param name="Timeout">Временной интервал анимации</param>
            <param name="Translator">Функция, вычисляющая очередное значение свойства на основе номера шага анимации и числа шагов</param>
            <param name="Private">Искать приватное свойство?</param>
        </member>
        <member name="M:MathCore.Reflection.AnimatedProperty`2.Start">
            <summary>Запуск анимации</summary>
        </member>
        <member name="M:MathCore.Reflection.AnimatedProperty`2.Stop">
            <summary>Остановка анимации</summary>
        </member>
        <member name="M:MathCore.Reflection.AnimatedProperty`2.Do">
            <summary>Метод, Выполняющий анимацию свойства</summary>
        </member>
        <member name="T:MathCore.SelectableCollection`1">
            <summary>Коллекция, поддерживающая указание выбранного элемента</summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
        </member>
        <member name="E:MathCore.SelectableCollection`1.PropertyChanged">
            <summary>Событие происходит при изменении значения свойства</summary>
        </member>
        <member name="M:MathCore.SelectableCollection`1.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения значения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="E:MathCore.SelectableCollection`1.CollectionChanged">
            <summary>Событие происходит при изменении коллекции</summary>
        </member>
        <member name="M:MathCore.SelectableCollection`1.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>Метод генерации события изменения коллекции</summary>
            <param name="e">Параметры события</param>
        </member>
        <member name="F:MathCore.SelectableCollection`1._SelectedItem">
            <summary>Выбранный элемент</summary>
        </member>
        <member name="P:MathCore.SelectableCollection`1.SelectedItem">
            <summary>Выбранный элемент</summary>
        </member>
        <member name="F:MathCore.SelectableCollection`1._Collection">
            <summary>Внутренняя коллекция</summary>
        </member>
        <member name="F:MathCore.SelectableCollection`1._IsNotifyCollection">
            <summary>Коллекция поддерживает уведомления об изменениях</summary>
        </member>
        <member name="M:MathCore.SelectableCollection`1.#ctor">
            <summary>Инициализация новой коллекции с возможностью выбора элемента</summary>
        </member>
        <member name="M:MathCore.SelectableCollection`1.#ctor(System.Int32)">
            <summary>Инициализация новой коллекции с возможностью выбора элемента</summary>
            <param name="Capacity">Ёмкость коллекции</param>
        </member>
        <member name="M:MathCore.SelectableCollection`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>Инициализация новой коллекции с возможностью выбора элемента</summary>
            <param name="Collection">Внутренняя коллекция</param>
        </member>
        <member name="M:MathCore.SelectableCollection`1.OnSourceCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>Обработчик события изменения внутренней коллекции</summary>
        </member>
        <member name="P:MathCore.SelectableCollection`1.Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.SelectableCollection`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SelectableCollection`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SelectableCollection`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SelectableCollection`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SelectableCollection`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SelectableCollection`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SelectableCollection`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SelectableCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.SequentialEnumerable`1">
            <summary>Итератор выбирает последовательно одно из значений нескольких перечислений в соответствии с указанным объектом сравнения</summary>
            <typeparam name="T">Тип элементов коллекций</typeparam>
        </member>
        <member name="T:MathCore.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.ItemNotNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
            <example><code>
            public void Foo([ItemNotNull]List&lt;string&gt; books)
            {
              foreach (var book in books) {
                if (book != null) // Warning: Expression is always true
                 Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
            <example><code>
            public void Foo([ItemCanBeNull]List&lt;string&gt; books)
            {
              foreach (var book in books)
              {
                // Warning: Possible 'System.NullReferenceException'
                Console.WriteLine(book.ToUpper());
              }
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:MathCore.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:MathCore.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param is null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <see cref="T:System.ComponentModel.INotifyPropertyChanged"/> interface
             and this method is used to notify that some property value changed
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               private string _name;
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:MathCore.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:MathCore.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            public class Foo {
              private string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute { }
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly
            (e.g. via reflection, in external library), so this symbol
            will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="T:MathCore.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper
            to not mark symbols marked with such attributes as unused
            (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used</summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member</summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type</summary>
        </member>
        <member name="T:MathCore.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly
            when marked with <see cref="T:MathCore.Annotations.MeansImplicitUseAttribute"/>
            or <see cref="T:MathCore.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used</summary>
        </member>
        <member name="F:MathCore.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used</summary>
        </member>
        <member name="T:MathCore.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used
            </summary>
        </member>
        <member name="T:MathCore.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:MathCore.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder
            within a web project. Path can be relative or absolute,
            starting from web root (~)
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcActionAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC action. If applied to a method, the MVC action name is calculated
            implicitly from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcAreaAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC area.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcControllerAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC controller. If applied to a method,
            the MVC controller name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.ChildActionExtensions.RenderAction(HtmlHelper, String, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcMasterAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC Master.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcModelTypeAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC model type.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(String, Object)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcPartialViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that
            the parameter is an MVC partial view. If applied to a method,
            the MVC partial view name is calculated implicitly from the context.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.RenderPartialExtensions.RenderPartial(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcPressuresViewErrorAttribute">
            <summary>
            ASP.NET MVC attribute. Allows disabling all inspections
            for MVC views within a class or a method.
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcDisplayTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC display template.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.Mvc.Html.DisplayExtensions.DisplayForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcEditorTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC editor template.
            Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Html.EditorExtensions.EditorForModel(HtmlHelper, String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcTemplateAttribute">
            <summary>
            ASP.NET MVC attribute. Indicates that a parameter is an MVC template.
            Use this attribute for custom wrappers similar to
            <c>System.ComponentModel.DataAnnotations.UIHintAttribute(System.String)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcViewAttribute">
            <summary>
            ASP.NET MVC attribute. If applied to a parameter, indicates that the parameter
            is an MVC view. If applied to a method, the MVC view name is calculated implicitly
            from the context. Use this attribute for custom wrappers similar to
            <c>System.Web.Mvc.Controller.View(Object)</c>
            </summary>
        </member>
        <member name="T:MathCore.Annotations.AspMvcActionSelectorAttribute">
            <summary>
            ASP.NET MVC attribute. When applied to a parameter of an attribute,
            indicates that this parameter is an MVC action name
            </summary>
            <example><code>
            [ActionName("Foo")]
            public ActionResult Login(string returnUrl) {
              ViewBag.ReturnUrl = Url.Action("Foo"); // OK
              return RedirectToAction("Bar"); // Error: Cannot resolve action
            }
            </code></example>
        </member>
        <member name="T:MathCore.Annotations.RazorSectionAttribute">
            <summary>
            Razor attribute. Indicates that a parameter or a method is a Razor section.
            Use this attribute for custom wrappers similar to 
            <c>System.Web.WebPages.WebPageBase.RenderSection(String)</c>
            </summary>
        </member>
        <member name="T:MathCore.SpecialFunctions.Bessel">
            <summary>Класс функций Бесселя</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.J0(System.Double)">
            <summary>Функция Бесселя 0 порядка</summary>
            <param name="x">Аргумент</param>
            <returns>Значение функции Бесселя нулевого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.J1(System.Double)">
            <summary>Функция Бесселя 1 порядка</summary>
            <param name="x">Аргумент функции</param>
            <returns>Значение функции Бесселя первого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Jn(System.Int32,System.Double)">
            <summary>Функция Бесселя n порядка</summary>
            <param name="n">Порядок функции Бесселя</param>
            <param name="x">Аргумент Функции Бесселя</param>
            <returns>Значение функции Бесселя n порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Y0(System.Double)">
            <summary>Функция Бесселя второго типа, нулевого порядка</summary>
            <param name="x">Аргумент функции Бесселя второго типа, нулевого порядка</param>
            <returns>Значение функции Бесселя второго типа, нулевого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Y1(System.Double)">
            <summary>Функция Бесселя второго типа, первого порядка</summary>
            <param name="x">Аргумент функции Бесселя второго типа, первого порядка</param>
            <returns>Значение функции Бесселя второго типа, первого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Yn(System.Int32,System.Double)">
            <summary>Функция Бесселя второго типа, n порядка</summary>
            <param name="n">Порядок функции Бесселя второго типа</param>
            <param name="x">Аргумент функции Бесселя второго типа, n порядка</param>
            <returns>Значение функции Бесселя второго типа, n порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.I0(System.Double)">
            <summary>Модифицированная функция Бесселя нулевого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя нулевого порядка</param>
            <returns>Значение модифицированной функции Бесселя нулевого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.I1(System.Double)">
            <summary>Модифицированная функция Бесселя первого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя первого порядка</param>
            <returns>Значение модифицированной функции Бесселя первого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.K0(System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, нулевого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, нулевого порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, нулевого порядка</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.K1(System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, первого порядка </summary>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, первого порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, первого порядка</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">x меньше 0</exception>
        </member>
        <member name="M:MathCore.SpecialFunctions.Bessel.Kn(System.Int32,System.Double)">
            <summary>Модифицированная функция Бесселя второго типа, n порядка </summary>
            <param name="n">Порядок модифицированной функции Бесселя второго типа</param>
            <param name="x">Аргумент модифицированной функции Бесселя второго типа, n порядка</param>
            <returns>Значение модифицированной функции Бесселя второго типа, n порядка</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">при x меньше, либо = 0</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">|n| больше 31</exception>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="F:MathCore.SpecialFunctions.Eps">
            <summary>Точность алгоритмов 5e-16</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.BCR(System.Int32,System.Int32)">
            <summary>Биномиальный коэффициент</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.BinomialCoefficient(System.Int32,System.Int32)">
            <summary>Биномиальный коэффициент</summary>
            <param name="n">Показатель степени бинома</param>
            <param name="k">Индекс коэффициента</param>
            <returns>Биномиальный коэффициент (n, k)</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.BinomialCoefficient(System.UInt64,System.UInt64)">
            <summary>Биномиальный коэффициент</summary>
            <param name="n">Показатель степени бинома (максимум 67)</param>
            <param name="k">Индекс коэффициента (максимум 76, 34)</param>
            <returns>Биномиальный коэффициент (n, k)</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.BinomialCoefficientBigInt(System.UInt64,System.UInt64)">
            <summary>Биномиальный коэффициент</summary>
            <param name="n">Показатель степени бинома (максимум 67)</param>
            <param name="k">Индекс коэффициента (максимум 76, 34)</param>
            <returns>Биномиальный коэффициент (n, k)</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.KroneckerDelta(System.Int32,System.Int32)">
            <summary>Символ Кронекера δ(i,j) = 1 - если i = j, и = 0 - если i ≠ j</summary>
            <param name="i">Индекс</param><param name="j">Индекс</param>
            <returns>1 - если i = j, и = 0 - если i ≠ j</returns>
        </member>
        <member name="T:MathCore.SpecialFunctions.Distribution.Normal">
            <summary>Нормальное распределение</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.Distribution.Normal.ErrorFunction(System.Double)">
            <summary>Интеграл от exp{-t^2} от нуля до x / .5 sqrt(pi)</summary>
            <param name="x">Аргумент функции нормального распределения</param>
            <returns>Значение нормального распределения</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Distribution.Student.QuantileHi2(System.Double,System.Int32)">
            <summary>Квантиль Хи-квадрат</summary>
             /// <param name="alpha">Квантиль [0..1]</param>
            <param name="n">Число степеней свободы</param>
            <returns>Квантиль</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.Distribution.Student.QuantileHi2Approximation(System.Double,System.Int32)">
            <summary>Квантиль Хи-квадрат (Аппроксимация Корниша-Фишера)</summary>
            <remarks>http://ru.wikipedia.org/wiki/Квантили_распределения_хи-квадрат</remarks>
            <remarks>https://projecteuclid.org/download/pdf_1/euclid.aoms/1177730982</remarks>
            <param name="alpha">Квантиль [0..1] (0.95 - 95% вероятности попадания значения в выбранный диапазон)</param>
            <param name="n">Число степеней свободы (число элементов гистограммы, минус число параметров распределения: [mu, sgm = 2])</param>
            <returns>Квантиль</returns>
        </member>
        <member name="T:MathCore.SpecialFunctions.EllipticJacobi">
            <summary>Эллиптические функции Якоби</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.FullEllipticIntegral(System.Double)">
            <summary>Полный эллиптический интеграл</summary>
            <param name="k">Параметр интегрирования от 0 до 1</param>
            <returns>Значение полного эллиптического интеграла</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.FullEllipticIntegralComplimentary(System.Double)">
            <summary>Полный комплиментарного эллиптический интеграл</summary>
            <param name="k">Параметр интегрирования от 0 до 1</param>
            <returns>Значение полного комплиментарного эллиптического интеграла</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.FullEllipticIntegral_Recursive(System.Double)">
            <summary>Полный эллиптический интеграл (рекурсивный алгоритм)</summary>
            <param name="k">Параметр интегрирования от 0 до 1</param>
            <returns>Значение полного эллиптического интеграла</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.FullEllipticIntegralComplimentary_Recursive(System.Double)">
            <summary>Полный комплиментарного эллиптический интеграл (рекурсивный алгоритм)</summary>
            <param name="k">Параметр интегрирования от 0 до 1</param>
            <returns>Значение полного комплиментарного эллиптического интеграла</returns>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.sn_uk(System.Double,System.Double)">
            <summary>Эллиптическая функция sn</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.sn_uk(MathCore.Complex,System.Double)">
            <summary>Эллиптическая функция sn комплексного аргумента</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.cd_uk(System.Double,System.Double)">
            <summary>Эллиптическая функция cd</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.cd_uk(MathCore.Complex,System.Double)">
            <summary>Эллиптическая функция cd комплексного аргумента</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.sn_iterative(System.Double,System.Double)">
            <summary>Эллиптическая функция sn (итерационный алгоритм)</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.sn_iterative(MathCore.Complex,System.Double)">
            <summary>Эллиптическая функция sn комплексного аргумента (итерационный алгоритм)</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.cd_iterative(System.Double,System.Double)">
            <summary>Эллиптическая функция cd (итерационный алгоритм)</summary>
        </member>
        <member name="M:MathCore.SpecialFunctions.EllipticJacobi.cd_iterative(MathCore.Complex,System.Double)">
            <summary>Эллиптическая функция cd комплексного аргумента (итерационный алгоритм)</summary>
        </member>
        <member name="T:MathCore.SpecialFunctions.Gamma">
            <summary>Гамма-функция</summary>
        </member>
        <member name="T:MathCore.Statistic.Distributions">
            <summary>Распределения</summary>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Hi2(System.Int32,System.Double)">
            <summary>Распределение Хи-квадрат</summary>
            <param name="k">Число степеней свободы</param>
            <param name="x">Аргумент</param>
            <returns>Значение плотности вероятности</returns>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Uniform(System.Double,System.Double)">
            <summary>Равномерное распределение</summary>
            <param name="a">Минимальное значение</param>
            <param name="b">Максимальное значение</param>
            <returns>Функция равномерного распределения в заданном интервале</returns>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Uniform(System.Double,System.Double,System.Double)">
            <summary>Равномерное распределение</summary>
            <param name="x">Аргумент</param>
            <param name="a">Минимальное значение</param>
            <param name="b">Максимальное значение</param>
            <returns>Значение равномерного распределения в заданной точке</returns>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Triangular(System.Double,System.Double,System.Double)">
            <summary>Триугольное распределение</summary>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Rayleigh(System.Double)">
            <summary>Распределение Рэлея http://ru.wikipedia.org/wiki/Распределение_Рэлея</summary>
            <param name="sigma">Параметр масштаба</param>
            <returns>Функция распределения для заданного масштаба</returns>
        </member>
        <member name="M:MathCore.Statistic.Distributions.Rayleigh(System.Double,System.Double)">
            <summary>Распределение Рэлея http://ru.wikipedia.org/wiki/Распределение_Рэлея</summary>
            <param name="x">Аргумент</param>
            <param name="sigma">Параметр масштаба</param>
            <returns>Значение распределения</returns>
        </member>
        <member name="T:MathCore.Statistic.Histogram">
            <summary>Гистограмма</summary>
        </member>
        <member name="T:MathCore.Statistic.Histogram.HistogramValue">
            <summary>Значение гистограммы</summary>
        </member>
        <member name="P:MathCore.Statistic.Histogram.HistogramValue.Interval">
            <summary>Интервал значений</summary>
        </member>
        <member name="P:MathCore.Statistic.Histogram.HistogramValue.Value">
            <summary>Частота</summary>
        </member>
        <member name="P:MathCore.Statistic.Histogram.HistogramValue.NormalValue">
            <summary>Нормированная частота</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.PolyformRandomGenerator.__Normal_A">
            <summary>area under rectangle</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.PolyformRandomGenerator.__A">
            <summary>area under rectangle</summary>
        </member>
        <member name="M:MathCore.Statistic.RandomNumbers.PolyformRandomGenerator.Cauchy(System.Double,System.Double)">
            <summary>Случайная величина с распределением Коши</summary>
            <param name="x0"></param>
            <param name="gamma"></param>
            <returns></returns>
        </member>
        <member name="T:MathCore.Statistic.RandomNumbers.RandomGenerator">
            <summary>Генератор случайных чисел</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.RandomGenerator._Sigma">
            <summary>Дисперсия</summary>
        </member>
        <member name="F:MathCore.Statistic.RandomNumbers.RandomGenerator._Mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="P:MathCore.Statistic.RandomNumbers.RandomGenerator.Sigma">
            <summary>Дисперсия</summary>
        </member>
        <member name="P:MathCore.Statistic.RandomNumbers.RandomGenerator.Mu">
            <summary>Математическое ожидание</summary>
        </member>
        <member name="P:MathCore.Statistic.RandomNumbers.RandomGenerator.Value">
            <summary>Случайное значение</summary>
        </member>
        <member name="M:MathCore.Statistic.RandomNumbers.RandomGenerator.GetValue">
            <summary>Новое случайное число</summary><returns>Случайное число</returns>
        </member>
        <member name="T:MathCore.Statistic.RandomNumbers.UniformRandomGenerator">
            <summary>Генератор случайных чисел с равномерным распределением</summary>
        </member>
        <member name="T:MathCore.StopWatchValue">
            <summary>Структура таймера, размещаемая на стеке. Служит для измерения времени.</summary>
        </member>
        <member name="P:MathCore.StopWatchValue.IsActive">
            <summary>Структура может быть использована для определения времени</summary>
        </member>
        <member name="M:MathCore.StopWatchValue.#ctor(System.Int64)">
            <summary>Инициализация структуры с захватом текущего времени</summary>
            <param name="StartTimestamp"></param>
        </member>
        <member name="M:MathCore.StopWatchValue.StartNew">
            <summary>Запуск измерения (захват текущего времени)</summary>
            <returns>Запущенный таймер</returns>
        </member>
        <member name="M:MathCore.StopWatchValue.GetElapsedTime">
            <summary>Прошедшее время</summary>
            <returns>Интервал времени, прошедший с момента создания структуры</returns>
        </member>
        <member name="T:MathCore.StringPtr">
            <summary>Указатель на позицию в строке</summary>
        </member>
        <member name="T:MathCore.StringPtr.CharEnumerator">
            <summary>Перечислитель символов подстроки, необходимый для использования в цикле <c>foreach</c></summary>
        </member>
        <member name="F:MathCore.StringPtr.CharEnumerator._Str">
            <summary>Исходная строка</summary>
        </member>
        <member name="F:MathCore.StringPtr.CharEnumerator._Pos">
            <summary>Начальное положение подстроки</summary>
        </member>
        <member name="F:MathCore.StringPtr.CharEnumerator._Length">
            <summary>Длина подстроки</summary>
        </member>
        <member name="F:MathCore.StringPtr.CharEnumerator._Index">
            <summary>Текущий индекс в подстроке</summary>
        </member>
        <member name="P:MathCore.StringPtr.CharEnumerator.Current">
            <summary>Текущий символ подстроки</summary>
        </member>
        <member name="M:MathCore.StringPtr.CharEnumerator.#ctor(System.String,System.Int32,System.Int32)">
            <summary>Инициализация нового перечислителя подстроки</summary>
            <param name="Str">Исходная строка</param>
            <param name="Pos">Начальное положение подстроки</param>
            <param name="Length">Длина подстроки</param>
        </member>
        <member name="M:MathCore.StringPtr.CharEnumerator.MoveNext">
            <summary>Смещение перечислителя к следующему символу</summary>
            <returns>Истина, если текущее положение символа находится в пределах подстроки</returns>
        </member>
        <member name="P:MathCore.StringPtr.Source">
            <summary>Исходная строка</summary>
        </member>
        <member name="P:MathCore.StringPtr.Pos">
            <summary>Положение начала в строке</summary>
        </member>
        <member name="P:MathCore.StringPtr.Length">
            <summary>Длина подстроки</summary>
        </member>
        <member name="P:MathCore.StringPtr.IsEmpty">
            <summary>Подстрока является пустой</summary>
        </member>
        <member name="P:MathCore.StringPtr.Item(System.Int32)">
            <summary>Индекс символа в подстроке</summary>
            <param name="index">Индекс в подстроке</param>
            <returns>Символ по указанному положению</returns>
        </member>
        <member name="P:MathCore.StringPtr.Item(System.Int32,System.Int32)">
            <summary>Новая подстрока</summary>
            <param name="index">Индекс начала</param>
            <param name="length">Длина</param>
            <returns>Указатель на новое положение</returns>
        </member>
        <member name="M:MathCore.StringPtr.#ctor(System.String)">
            <summary>Инициализация нового указателя на положение в строке</summary>
            <param name="Source">Исходная строка</param>
        </member>
        <member name="M:MathCore.StringPtr.#ctor(System.String,System.Int32,System.Int32)">
            <summary>Инициализация нового указателя на положение в строке</summary>
            <param name="Source">Исходная строка</param>
            <param name="Pos">Положение в исходной строке</param>
            <param name="Length">Длина подстроки</param>
        </member>
        <member name="M:MathCore.StringPtr.Substring(System.Int32)">
            <summary>Подстрока</summary>
            <param name="Offset">Смещение в текущей подстроке</param>
            <returns>Новый указатель на подстроку, смещённую на указанное значение символов относительно текущей подстроки</returns>
        </member>
        <member name="M:MathCore.StringPtr.Substring(System.Int32,System.Int32)">
            <summary>Подстрока</summary>
            <param name="Offset">Смещение в текущей подстроке</param>
            <param name="Count">Число символов в новой подстроке</param>
            <returns>Указатель на подстроку, смещённую на указанное значение символов относительно текущей подстроки</returns>
        </member>
        <member name="M:MathCore.StringPtr.StartWith(System.Char)">
            <summary>Начинается ли подстрока с указанного символа</summary>
            <param name="c">Символ, с которого должна начинаться текущая подстрока</param>
            <returns>Истина, если текущая подстрока начинается с указанного символа</returns>
        </member>
        <member name="M:MathCore.StringPtr.StartWith(System.String)">
            <summary>Начинается ли подстрока с указанной строки</summary>
            <param name="Str">Строка, с которой должна начинаться текущая подстрока</param>
            <returns>Истина, если текущая подстрока начинается с указанной строки</returns>
        </member>
        <member name="M:MathCore.StringPtr.StartWith(System.String,System.StringComparison)">
            <summary>Начинается ли подстрока с указанной строки</summary>
            <param name="Str">Строка, с которой должна начинаться текущая подстрока</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Истина, если текущая подстрока начинается с указанной строки</returns>
        </member>
        <member name="M:MathCore.StringPtr.StartWith(MathCore.StringPtr)">
            <summary>Начинается ли текущая подстрока с указанной подстроки</summary>
            <param name="Str">Подстрока, с которой должна начинаться текущая подстрока</param>
            <returns>Истина, если в начале текущей подстроки содержится указанная подстрока</returns>
        </member>
        <member name="M:MathCore.StringPtr.StartWith(MathCore.StringPtr,System.StringComparison)">
            <summary>Начинается ли текущая подстрока с указанной подстроки</summary>
            <param name="Str">Подстрока, с которой должна начинаться текущая подстрока</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Истина, если в начале текущей подстроки содержится указанная подстрока</returns>
        </member>
        <member name="M:MathCore.StringPtr.EndWith(System.Char)">
            <summary>Заканчивается ли подстрока с указанным символом</summary>
            <param name="c">Символ, на который должна заканчиваться текущая подстрока</param>
            <returns>Истина, если текущая подстрока заканчивается на указанный символ</returns>
        </member>
        <member name="M:MathCore.StringPtr.EndWith(System.String)">
            <summary>Заканчивается ли подстрока указанной строкой</summary>
            <param name="Str">Строка, на которую должна заканчиваться текущая подстрока</param>
            <returns>Истина, если текущая подстрока заканчивается на указанную строку</returns>
        </member>
        <member name="M:MathCore.StringPtr.EndWith(System.String,System.StringComparison)">
            <summary>Заканчивается ли подстрока указанной строкой</summary>
            <param name="Str">Строка, на которую должна заканчиваться текущая подстрока</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Истина, если текущая подстрока заканчивается на указанную строку</returns>
        </member>
        <member name="M:MathCore.StringPtr.EndWith(MathCore.StringPtr)">
            <summary>Начинается ли текущая подстрока указанной подстрокой</summary>
            <param name="Str">Подстрока, с которой должна начинаться текущая подстрока</param>
            <returns>Истина, если в начале текущей подстроки содержится указанная подстрока</returns>
        </member>
        <member name="M:MathCore.StringPtr.EndWith(MathCore.StringPtr,System.StringComparison)">
            <summary>Начинается ли текущая подстрока указанной подстрокой</summary>
            <param name="Str">Подстрока, с которой должна начинаться текущая подстрока</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Истина, если в начале текущей подстроки содержится указанная подстрока</returns>
        </member>
        <member name="M:MathCore.StringPtr.Contains(System.Char)">
            <summary>Содержит ли подстрока указанный символ</summary>
            <param name="c">Проверяемый символ</param>
            <returns>Истина, если в текущей подстроке есть указанный символ</returns>
        </member>
        <member name="M:MathCore.StringPtr.Contains(System.String)">
            <summary>Содержит ли подстрока указанную строку</summary>
            <param name="str">Проверяемая строка</param>
            <returns>Истина, если в текущей подстроке есть указанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Contains(System.String,System.StringComparison)">
            <summary>Содержит ли подстрока указанную строку</summary>
            <param name="str">Проверяемая строка</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Истина, если в текущей подстроке есть указанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.IndexOf(System.Char)">
            <summary>Индекс первого вхождения символа в подстроку</summary>
            <param name="c">Проверяемый символ</param>
            <returns>Индекс символа в подстроке, либо -1 в случае его отсутствия</returns>
        </member>
        <member name="M:MathCore.StringPtr.LastIndexOf(System.Char)">
            <summary>Индекс последнего вхождения символа в подстроку</summary>
            <param name="c">Проверяемый символ</param>
            <returns>Индекс символа в подстроке с конца, либо -1 в случае его отсутствия</returns>
        </member>
        <member name="M:MathCore.StringPtr.IndexOf(System.String)">
            <summary>Индекс первого вхождения строки в подстроку</summary>
            <param name="str">Искомая строка</param>
            <returns>Индекс первого вхождения указанной строки в подстроке, либо -1 в случае её отсутствия</returns>
        </member>
        <member name="M:MathCore.StringPtr.LastIndexOf(System.String)">
            <summary>Индекс последнего вхождения строки в подстроку</summary>
            <param name="str">Искомая строка</param>
            <returns>Индекс последнего вхождения указанной строки в подстроке, либо -1 в случае её отсутствия</returns>
        </member>
        <member name="M:MathCore.StringPtr.IndexOf(System.String,System.StringComparison)">
            <summary>Индекс первого вхождения строки в подстроку</summary>
            <param name="str">Искомая строка</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Индекс первого вхождения указанной строки в подстроке, либо -1 в случае её отсутствия</returns>
        </member>
        <member name="M:MathCore.StringPtr.LastIndexOf(System.String,System.StringComparison)">
            <summary>Индекс последнего вхождения строки в подстроку</summary>
            <param name="str">Искомая строка</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Индекс последнего вхождения указанной строки в подстроке, либо -1 в случае её отсутствия</returns>
        </member>
        <member name="M:MathCore.StringPtr.LastIndexOf(MathCore.StringPtr,System.StringComparison)">
            <summary>Индекс последнего вхождения строки в подстроку</summary>
            <param name="str">Искомая строка</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Индекс последнего вхождения указанной строки в подстроке, либо -1 в случае её отсутствия</returns>
        </member>
        <member name="M:MathCore.StringPtr.Equals(System.String)">
            <summary>Проверка соответствия текущей подстроки с указанной строкой</summary>
            <param name="str">Проверяемая на равенство строка</param>
            <returns>Истина, если текущая подстрока эквивалентна указанной строке</returns>
        </member>
        <member name="M:MathCore.StringPtr.Equals(System.String,System.StringComparison)">
            <summary>Проверка соответствия текущей подстроки с указанной строкой</summary>
            <param name="str">Проверяемая на равенство строка</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Истина, если текущая подстрока эквивалентна указанной строке</returns>
        </member>
        <member name="M:MathCore.StringPtr.Equals(MathCore.StringPtr)">
            <summary>Проверка соответствия текущей подстроки с указанной подстрокой</summary>
            <param name="str">Проверяемая на равенство подстрока</param>
            <returns>Истина, если текущая подстрока эквивалентна указанной подстроке</returns>
        </member>
        <member name="M:MathCore.StringPtr.Equals(MathCore.StringPtr,System.StringComparison)">
            <summary>Проверка соответствия текущей подстроки с указанной подстрокой</summary>
            <param name="str">Проверяемая на равенство подстрока</param>
            <param name="Comparison">Способ сравнения строк</param>
            <returns>Истина, если текущая подстрока эквивалентна указанной подстроке</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_Equality(MathCore.StringPtr,System.String)">
            <summary>Оператор проверки на равенство фрагмента строки со строкой</summary>
            <param name="ptr">Фрагмент строки</param>
            <param name="str">Строка</param>
            <returns>Истина, если фрагмент строки посимвольно равен указанной строке</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_Inequality(MathCore.StringPtr,System.String)">
            <summary>Оператор проверки на неравенство фрагмента строки со строкой</summary>
            <param name="ptr">Фрагмент строки</param>
            <param name="str">Строка</param>
            <returns>Истина, если фрагмент строки посимвольно неравен указанной строке</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_Equality(System.String,MathCore.StringPtr)">
            <summary>Оператор проверки на равенство фрагмента строки со строкой</summary>
            <param name="ptr">Фрагмент строки</param>
            <param name="str">Строка</param>
            <returns>Истина, если фрагмент строки посимвольно равен указанной строке</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_Inequality(System.String,MathCore.StringPtr)">
            <summary>Оператор проверки на неравенство фрагмента строки со строкой</summary>
            <param name="ptr">Фрагмент строки</param>
            <param name="str">Строка</param>
            <returns>Истина, если фрагмент строки посимвольно неравен указанной строке</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_GreaterThan(MathCore.StringPtr,System.String)">
            <summary>Оператор порядка "больше", сравнивающий фрагмент строки со строкой</summary>
            <param name="ptr">Фрагмент строки</param>
            <param name="str">Строка</param>
            <returns>Истина, если фрагмент строки больше, чем указанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_LessThan(MathCore.StringPtr,System.String)">
            <summary>Оператор порядка "меньше", сравнивающий фрагмент строки со строкой</summary>
            <param name="ptr">Фрагмент строки</param>
            <param name="str">Строка</param>
            <returns>Истина, если фрагмент строки меньше, чем указанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_GreaterThan(System.String,MathCore.StringPtr)">
            <summary>Оператор порядка "больше", сравнивающий строку с фрагментом строки</summary>
            <param name="ptr">Фрагмент строки</param>
            <param name="str">Строка</param>
            <returns>Истина, если строка больше, чем указанный фрагмент строки</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_LessThan(System.String,MathCore.StringPtr)">
            <summary>Оператор порядка "меньше", сравнивающий строку с фрагментом строки</summary>
            <param name="ptr">Фрагмент строки</param>
            <param name="str">Строка</param>
            <returns>Истина, если строка меньше, чем указанный фрагмент строки</returns>
        </member>
        <member name="M:MathCore.StringPtr.TryParseInt32(System.Int32@)">
            <summary>Попытка преобразования подстроки в <see cref="T:System.Int32"/></summary>
            <param name="value">Преобразованное значение</param>
            <returns>Истина, если преобразование выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.ParseInt32">
            <summary>Преобразование подстроки в <see cref="T:System.Int32"/></summary>
            <returns>Преобразованное значение</returns>
            <exception cref="T:System.FormatException">В случае если строка не является представлением <see cref="T:System.Int32"/></exception>
            <exception cref="T:System.OverflowException">Если длина строковой записи числа превышает <see cref="T:System.Int32"/>.<see cref="F:System.Int32.MaxValue"/></exception>
        </member>
        <member name="M:MathCore.StringPtr.TryParseDouble(System.Double@)">
            <summary>Попытка преобразования подстроки в <see cref="T:System.Double"/></summary>
            <param name="value">Преобразованное значение</param>
            <returns>Истина, если преобразование выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TryParseDouble(System.IFormatProvider,System.Double@)">
            <summary>Попытка преобразования подстроки в <see cref="T:System.Double"/></summary>
            <param name="Provider">Информация о формате</param>
            <param name="value">Преобразованное значение</param>
            <returns>Истина, если преобразование выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.ParseDouble">
            <summary>Попытка преобразования подстроки в <see cref="T:System.Double"/></summary>
            <returns>Преобразованное вещественное число</returns>
        </member>
        <member name="M:MathCore.StringPtr.ParseDouble(System.IFormatProvider)">
            <summary>Попытка преобразования подстроки в <see cref="T:System.Double"/></summary>
            <param name="Provider">Информация о формате</param>
            <returns>Преобразованное вещественное число</returns>
        </member>
        <member name="M:MathCore.StringPtr.GetName(System.Char)">
            <summary>Получить имя (ключ) из пары ключ=значение</summary>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Подстрока, содержащая имя (ключ) из пары ключ-значение</returns>
        </member>
        <member name="M:MathCore.StringPtr.GetValueString(System.Char)">
            <summary>Получить значение из пары ключ=значение</summary>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Подстрока, содержащая значение из пары ключ-значение</returns>
        </member>
        <member name="M:MathCore.StringPtr.GetValueDouble(System.Char)">
            <summary>Получить вещественное значение из пары ключ=значение</summary>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Вещественное значение из пары ключ-значение</returns>
        </member>
        <member name="M:MathCore.StringPtr.GetValueDouble(System.IFormatProvider,System.Char)">
            <summary>Получить вещественное значение из пары ключ=значение</summary>
            <param name="Provider">Провайдер формата значения</param>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Вещественное значение из пары ключ-значение</returns>
        </member>
        <member name="M:MathCore.StringPtr.GetValueInt32(System.Char)">
            <summary>Получить целочисленное значение из пары ключ=значение</summary>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Целочисленное значение из пары ключ-значение</returns>
        </member>
        <member name="M:MathCore.StringPtr.TryGetValueDouble(System.Double@,System.Char)">
            <summary>Попытаться получить вещественное значение из пары ключ=значение</summary>
            <param name="value">Вещественное значение из пары ключ-значение</param>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Истина, если преобразование подстроки значения в вещественное значение выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TryGetValueDouble(System.IFormatProvider,System.Double@,System.Char)">
            <summary>Попытаться получить вещественное значение из пары ключ=значение</summary>
            <param name="value">Вещественное значение из пары ключ-значение</param>
            <param name="Provider">Провайдер формата значения</param>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Истина, если преобразование подстроки значения в вещественное значение выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TryGetValueInt32(System.Int32@,System.Char)">
            <summary>Попытаться получить целочисленное значение из пары ключ=значение</summary>
            <param name="value">Целочисленное значение из пары ключ-значение</param>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Истина, если преобразование подстроки значения в целочисленное значение выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TryGetValueBool(System.Boolean@,System.Char)">
            <summary>Попытаться получить булево значение из пары ключ=значение</summary>
            <param name="value">Булево значение из пары ключ-значение</param>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Истина, если преобразование подстроки значения в булево значение выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.GetValueBool(System.Char)">
            <summary>Получить булево значение из пары ключ=значение</summary>
            <param name="Separator">Символ-разделитель пары ключ-значение</param>
            <returns>Булево значение из пары ключ-значение</returns>
        </member>
        <member name="F:MathCore.StringPtr.__DefaultTrimChars">
            <summary>Символы, обрезаемые в начале и конце строки по умолчанию</summary>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Boolean@)">
            <summary>Удаление технических символов в начале строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart">
            <summary>Удаление технических символов в начале строки</summary>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Boolean@)">
            <summary>Удаление технических символов в конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd">
            <summary>Удаление технических символов в конце строки</summary>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Char)">
            <summary>Удаление символа в начале строки</summary>
            <param name="c">Удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Boolean@,System.Char)">
            <summary>Удаление символа в начале строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c">Удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Char,System.Char)">
            <summary>Удаление символа в начале строки</summary>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Boolean@,System.Char,System.Char)">
            <summary>Удаление символа в начале строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Char,System.Char,System.Char)">
            <summary>Удаление символа в начале строки</summary>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <param name="c3">Третий удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Boolean@,System.Char,System.Char,System.Char)">
            <summary>Удаление символа в начале строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <param name="c3">Третий удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Char[])">
            <summary>Удаление символов в начале строки</summary>
            <param name="c">Удаляемые символы</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimStart(System.Boolean@,System.Char[])">
            <summary>Удаление символов в начале строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c">Удаляемые символы</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Char)">
            <summary>Удаление символа в конца строки</summary>
            <param name="c">Удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Boolean@,System.Char)">
            <summary>Удаление символа в конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c">Удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Char,System.Char)">
            <summary>Удаление символа в конце строки</summary>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Boolean@,System.Char,System.Char)">
            <summary>Удаление символа в конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Char,System.Char,System.Char)">
            <summary>Удаление символа в конце строки</summary>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <param name="c3">Третий удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Boolean@,System.Char,System.Char,System.Char)">
            <summary>Удаление символа в конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <param name="c3">Третий удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Char[])">
            <summary>Удаление символов в конце строки</summary>
            <param name="c">Удаляемые символы</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.TrimEnd(System.Boolean@,System.Char[])">
            <summary>Удаление символов в конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c">Удаляемые символы</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="c">Удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@,System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c">Удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@,System.Boolean@,System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="TrimmedStart">Обрезание строки в начале было выполнено</param>
            <param name="TrimmedEnd">Обрезание строки в конце было выполнено</param>
            <param name="c">Удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Char,System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@,System.Char,System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@,System.Boolean@,System.Char,System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="TrimmedStart">Обрезание строки в начале было выполнено</param>
            <param name="TrimmedEnd">Обрезание строки в конце было выполнено</param>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Char,System.Char,System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <param name="c3">Третий удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@,System.Char,System.Char,System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <param name="c3">Третий удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@,System.Boolean@,System.Char,System.Char,System.Char)">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="TrimmedStart">Обрезание строки в начале было выполнено</param>
            <param name="TrimmedEnd">Обрезание строки в конце было выполнено</param>
            <param name="c1">Первый удаляемый символ</param>
            <param name="c2">Второй удаляемый символ</param>
            <param name="c3">Третий удаляемый символ</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Char[])">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="c">Удаляемые символы</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@,System.Char[])">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="Trimmed">Обрезание строки было выполнено</param>
            <param name="c">Удаляемые символы</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Trim(System.Boolean@,System.Boolean@,System.Char[])">
            <summary>Удаление технических символов в начале и конце строки</summary>
            <param name="TrimmedStart">Обрезание строки в начале было выполнено</param>
            <param name="TrimmedEnd">Обрезание строки в конце было выполнено</param>
            <param name="c">Удаляемые символы</param>
            <returns>Обрезанная строка</returns>
        </member>
        <member name="M:MathCore.StringPtr.Split(System.Char[])">
            <summary>Разделить строку на подстроки по указанному символам-разделителям</summary>
            <param name="Separators">Символы-разделители</param>
            <returns>Разделитель строки на фрагменты</returns>
        </member>
        <member name="M:MathCore.StringPtr.Split(System.Boolean,System.Char[])">
            <summary>Разделить строку на подстроки по указанному символам-разделителям</summary>
            <param name="SkipEmpty">Пропускать пустые фрагменты</param>
            <param name="Separators">Символы-разделители</param>
            <returns>Разделитель строки на фрагменты</returns>
        </member>
        <member name="M:MathCore.StringPtr.Split(System.Char)">
            <summary>Разделить строку на подстроки по указанному символу-разделителю</summary>
            <param name="Separator">Символ-разделитель</param>
            <returns>Разделитель строки на фрагменты</returns>
        </member>
        <member name="M:MathCore.StringPtr.Split(System.Boolean,System.Char)">
            <summary>Разделить строку на подстроки по указанному символу-разделителю</summary>
            <param name="SkipEmpty">Пропускать пустые фрагменты</param>
            <param name="Separator">Символ-разделитель</param>
            <returns>Разделитель строки на фрагменты</returns>
        </member>
        <member name="M:MathCore.StringPtr.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.StringPtr.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.StringPtr.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.StringPtr.ToCharArray">
            <summary>Преобразование подстроки в массив символов</summary>
            <returns>Массив символов подстроки</returns>
        </member>
        <member name="M:MathCore.StringPtr.GetEnumerator">
            <summary>Получить перечислитель символов подстроки</summary>
            <returns>Структура перечислителя символов подстроки</returns>
        </member>
        <member name="M:MathCore.StringPtr.op_Implicit(System.String)~MathCore.StringPtr">
            <summary>Оператор неявного преобразования строки в фрагмент строки</summary>
            <param name="Source">Исходная строка</param>
        </member>
        <member name="M:MathCore.StringPtr.op_Implicit(MathCore.StringPtr)~System.String">
            <summary>Оператор неявного преобразования фрагмента строки в строку</summary>
            <param name="Ptr">Фрагмент строки</param>
        </member>
        <member name="M:MathCore.StringPtr.op_Explicit(MathCore.StringPtr)~System.Int32">
            <summary>Оператор явного преобразования фрагмента строки в целое число</summary>
            <param name="Ptr">Фрагмент строки</param>
        </member>
        <member name="M:MathCore.StringPtr.op_Explicit(MathCore.StringPtr)~System.Double">
            <summary>Оператор явного преобразования фрагмента строки в вещественное число</summary>
            <param name="Ptr">Фрагмент строки</param>
        </member>
        <member name="T:MathCore.StringPtr.Tokenizer">
            <summary>Разделитель строки на фрагменты по указанному символам-разделителям</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer._Buffer">
            <summary>Строковый буфер</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer._Separators">
            <summary>Символы-разделители</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer._StartIndex">
            <summary>Начальное положение в буфере</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer._Length">
            <summary>Длина подстроки для анализа</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer._SkipEmpty">
            <summary>Пропускать пустые фрагменты</summary>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.#ctor(MathCore.StringPtr,System.Char[])">
            <summary>Инициализация нового разделителя строки</summary>
            <param name="Str">Исходный фрагмент строки</param>
            <param name="Separators">Символы-разделители фрагментов строки</param>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.#ctor(System.String,System.Char[])">
            <summary>Инициализация нового разделителя строки</summary>
            <param name="Buffer">Исходный строковый буфер</param>
            <param name="Separators">Символы-разделители фрагментов строки</param>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.#ctor(System.String,System.Char[],System.Int32,System.Int32,System.Boolean)">
            <summary>Инициализация нового разделителя строки</summary>
            <param name="Buffer">Исходный строковый буфер</param>
            <param name="Separators">Символы-разделители фрагментов строки</param>
            <param name="StartIndex">Индекс начала анализируемой подстроки</param>
            <param name="Length">Длина анализируемой подстроки</param>
            <param name="SkipEmpty">Пропускать пустые строковые фрагменты</param>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.SkipEmpty(System.Boolean)">
            <summary>Пропускать пустые строковые фрагменты</summary>
            <param name="Skip">Пропускать, или нет</param>
            <returns>Перечислитель строковых фрагментов с изменённым режимом пропуска строковых фрагментов</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.GetEnumerator">
            <summary>Сформировать перечислитель строковых фрагментов</summary>
            <returns>Перечислитель строковых фрагментов</returns>
        </member>
        <member name="T:MathCore.StringPtr.Tokenizer.TokenEnumerator">
            <summary>Перечислитель строковых фрагментов</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer.TokenEnumerator._Buffer">
            <summary>Строковый буфер</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer.TokenEnumerator._Separators">
            <summary>Символы-разделители</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer.TokenEnumerator._StartIndex">
            <summary>Начальное положение в буфере</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer.TokenEnumerator._Length">
            <summary>Длина подстроки для анализа</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer.TokenEnumerator._SkipEmpty">
            <summary>Пропускать пустые фрагменты</summary>
        </member>
        <member name="F:MathCore.StringPtr.Tokenizer.TokenEnumerator._CurrentPos">
            <summary>Текущая позиция в исходной строке</summary>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.#ctor(System.String,System.Char[],System.Int32,System.Int32,System.Boolean)">
            <summary>Инициализация нового перечислителя строковых фрагментов</summary>
            <param name="Buffer">Исходный строковый буфер</param>
            <param name="Separators">Символы-разделители</param>
            <param name="StartIndex">Начальное положение в строковом буфере</param>
            <param name="Length">Длина подстроки для анализа</param>
            <param name="SkipEmpty">Пропускать пустые фрагменты</param>
        </member>
        <member name="P:MathCore.StringPtr.Tokenizer.TokenEnumerator.Current">
            <summary>Текущий фрагмент строки</summary>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.MoveNext">
            <summary>Перемещение к следующему фрагменту</summary>
            <returns>Истина, если перемещение выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.MoveNextOrThrow">
            <summary>Переместиться к следующему фрагменту, либо сгенерировать исключение в случае отсутствия такой возможности</summary>
            <returns>Следующий фрагмент строки</returns>
            <exception cref="T:System.InvalidOperationException">Возникает в случае отсутствия возможности выделить следующий фрагмент строки</exception>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.MoveNextOrThrow``1">
            <summary>Переместиться к следующему фрагменту, либо сгенерировать исключение в случае отсутствия такой возможности</summary>
            <typeparam name="TException">Генерируемое исключение в случае отсутствия возможности перемещения к следующей подстроке</typeparam>
            <returns>Следующий фрагмент строки</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.GetNext(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>Найти следующую подстроку</summary>
            <param name="Str">Исходный строковый буфер</param>
            <param name="Separators">Символы-разделители</param>
            <param name="StartIndex">Индекс символа, с которого начинается поиск</param>
            <param name="EndIndex">Индекс символа, на котором должен закончиться поиск</param>
            <returns>Найденная подстрока</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.NextIndex(System.String,System.Char[],System.Int32,System.Int32)">
            <summary>Индекс следующего разделителя в строке в заданном диапазоне</summary>
            <param name="Str">Исходный строковый буфер</param>
            <param name="Separators">Символы-разделители</param>
            <param name="StartIndex">Индекс символа, с которого начинается поиск</param>
            <param name="EndIndex">Индекс символа, на котором должен закончиться поиск</param>
            <returns>Индекс искомого символа в подстроке, либо -1, если его найдено не было</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.TryParseNextDouble(System.Double@)">
            <summary>Попытаться преобразовать следующую подстроку в вещественное число</summary>
            <param name="value">Результат преобразования, либо <see cref="F:System.Double.NaN"/>, если подстрока имеет неверный формат, лио отсутствует</param>
            <returns>Истина, если преобразование подстроки в вещественное число выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.TryParseNextDouble(System.IFormatProvider,System.Double@)">
            <summary>Попытаться преобразовать следующую подстроку в вещественное число</summary>
            <param name="provider">Формат представления вещественного числа</param>
            <param name="value">Результат преобразования, либо <see cref="F:System.Double.NaN"/>, если подстрока имеет неверный формат, лио отсутствует</param>
            <returns>Истина, если преобразование подстроки в вещественное число выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.TryParseNextAsInt32(System.Int32@)">
            <summary>Попытаться преобразовать следующую подстроку в целое число</summary>
            <param name="value">Результат преобразования, либо 0, если подстрока имеет неверный формат, лио отсутствует</param>
            <returns>Истина, если преобразование подстроки в целое число выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.TryParseNextAsBool(System.Boolean@)">
            <summary>Попытаться преобразовать следующую подстроку в <see cref="T:System.Boolean"/> значение</summary>
            <param name="value">Результат преобразования, либо <c>false</c>, если подстрока имеет неверный формат, лио отсутствует</param>
            <returns>Истина, если преобразование подстроки в <see cref="T:System.Boolean"/> значение выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.op_Implicit(MathCore.StringPtr.Tokenizer.TokenEnumerator)~System.Int32">
            <summary>Оператор неявного преобразования перечислителя фрагментов строки в целое число</summary>
            <param name="Enumerator">Перечислитель фрагментов строки</param>
        </member>
        <member name="M:MathCore.StringPtr.Tokenizer.TokenEnumerator.op_Implicit(MathCore.StringPtr.Tokenizer.TokenEnumerator)~System.Double">
            <summary>Оператор неявного преобразования перечислителя фрагментов строки в вещественное число</summary>
            <param name="Enumerator">Перечислитель фрагментов строки</param>
        </member>
        <member name="T:MathCore.StringPtr.TokenizerSingleChar">
            <summary>Разделитель строки на фрагменты по указанному символу-разделителю</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar._Buffer">
            <summary>Строковый буфер</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar._Separator">
            <summary>Символ-разделитель</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar._StartIndex">
            <summary>Начальное положение в буфере</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar._Length">
            <summary>Длина подстроки для анализа</summary>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.#ctor(MathCore.StringPtr,System.Char)">
            <summary>Инициализация нового разделителя строки</summary>
            <param name="Str">Исходный фрагмент строки</param>
            <param name="Separator">Символ-разделитель фрагментов строки</param>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.#ctor(System.String,System.Char)">
            <summary>Инициализация нового разделителя строки</summary>
            <param name="Buffer">Исходный строковый буфер</param>
            <param name="Separator">Символ-разделитель фрагментов строки</param>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.#ctor(System.String,System.Char,System.Int32,System.Int32,System.Boolean)">
            <summary>Инициализация нового разделителя строки</summary>
            <param name="Buffer">Исходный строковый буфер</param>
            <param name="Separator">Символ-разделитель фрагментов строки</param>
            <param name="StartIndex">Индекс начала анализируемой подстроки</param>
            <param name="Length">Длина анализируемой подстроки</param>
            <param name="SkipEmpty">Пропускать пустые строковые фрагменты</param>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.SkipEmpty(System.Boolean)">
            <summary>Пропускать пустые строковые фрагменты</summary>
            <param name="Skip">Пропускать, или нет</param>
            <returns>Перечислитель строковых фрагментов с изменённым режимом пропуска строковых фрагментов</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.GetEnumerator">
            <summary>Сформировать перечислитель строковых фрагментов</summary>
            <returns>Перечислитель строковых фрагментов</returns>
        </member>
        <member name="T:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator">
            <summary>Перечислитель строковых фрагментов</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator._Buffer">
            <summary>Строковый буфер</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator._Separator">
            <summary>Символ-разделитель</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator._StartIndex">
            <summary>Начальное положение в буфере</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator._Length">
            <summary>Длина подстроки для анализа</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator._SkipEmpty">
            <summary>Пропускать пустые фрагменты</summary>
        </member>
        <member name="F:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator._CurrentPos">
            <summary>Текущая позиция в исходной строке</summary>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.#ctor(System.String,System.Char,System.Int32,System.Int32,System.Boolean)">
            <summary>Инициализация нового перечислителя строковых фрагментов</summary>
            <param name="Buffer">Исходный строковый буфер</param>
            <param name="Separator">Символ-разделитель</param>
            <param name="StartIndex">Начальное положение в строковом буфере</param>
            <param name="Length">Длина подстроки для анализа</param>
            <param name="SkipEmpty">Пропускать пустые фрагменты</param>
        </member>
        <member name="P:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.Current">
            <summary>Текущий фрагмент строки</summary>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.MoveNext">
            <summary>Перемещение к следующему фрагменту</summary>
            <returns>Истина, если перемещение выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.MoveNextOrThrow">
            <summary>Переместиться к следующему фрагменту, либо сгенерировать исключение в случае отсутствия такой возможности</summary>
            <returns>Следующий фрагмент строки</returns>
            <exception cref="T:System.InvalidOperationException">Возникает в случае отсутствия возможности выделить следующий фрагмент строки</exception>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.MoveNextOrThrow``1">
            <summary>Переместиться к следующему фрагменту, либо сгенерировать исключение в случае отсутствия такой возможности</summary>
            <typeparam name="TException">Генерируемое исключение в случае отсутствия возможности перемещения к следующей подстроке</typeparam>
            <returns>Следующий фрагмент строки</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.GetNext(System.String,System.Char,System.Int32,System.Int32)">
            <summary>Найти следующую подстроку</summary>
            <param name="Str">Исходный строковый буфер</param>
            <param name="Separator">Символ-разделитель</param>
            <param name="StartIndex">Индекс символа, с которого начинается поиск</param>
            <param name="EndIndex">Индекс символа, на котором должен закончиться поиск</param>
            <returns>Найденная подстрока</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.NextIndex(System.String,System.Char,System.Int32,System.Int32)">
            <summary>Индекс следующего разделителя в строке в заданном диапазоне</summary>
            <param name="Str">Исходный строковый буфер</param>
            <param name="Separator">Символ-разделитель</param>
            <param name="StartIndex">Индекс символа, с которого начинается поиск</param>
            <param name="EndIndex">Индекс символа, на котором должен закончиться поиск</param>
            <returns>Индекс искомого символа в подстроке, либо -1, если его найдено не было</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.TryParseNextDouble(System.Double@)">
            <summary>Попытаться преобразовать следующую подстроку в вещественное число</summary>
            <param name="value">Результат преобразования, либо <see cref="F:System.Double.NaN"/>, если подстрока имеет неверный формат, лио отсутствует</param>
            <returns>Истина, если преобразование подстроки в вещественное число выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.TryParseNextDouble(System.IFormatProvider,System.Double@)">
            <summary>Попытаться преобразовать следующую подстроку в вещественное число</summary>
            <param name="provider">Формат представления вещественного числа</param>
            <param name="value">Результат преобразования, либо <see cref="F:System.Double.NaN"/>, если подстрока имеет неверный формат, лио отсутствует</param>
            <returns>Истина, если преобразование подстроки в вещественное число выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.TryParseNextInt32(System.Int32@)">
            <summary>Попытаться преобразовать следующую подстроку в целое число</summary>
            <param name="value">Результат преобразования, либо 0, если подстрока имеет неверный формат, лио отсутствует</param>
            <returns>Истина, если преобразование подстроки в целое число выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.TryParseNextAsBool(System.Boolean@)">
            <summary>Попытаться преобразовать следующую подстроку в <see cref="T:System.Boolean"/> значение</summary>
            <param name="value">Результат преобразования, либо <c>false</c>, если подстрока имеет неверный формат, лио отсутствует</param>
            <returns>Истина, если преобразование подстроки в <see cref="T:System.Boolean"/> значение выполнено успешно</returns>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.op_Implicit(MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator)~System.Int32">
            <summary>Оператор неявного преобразования перечислителя фрагментов строки в целое число</summary>
            <param name="Enumerator">Перечислитель фрагментов строки</param>
        </member>
        <member name="M:MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator.op_Implicit(MathCore.StringPtr.TokenizerSingleChar.TokenEnumerator)~System.Double">
            <summary>Оператор неявного преобразования перечислителя фрагментов строки в вещественное число</summary>
            <param name="Enumerator">Перечислитель фрагментов строки</param>
        </member>
        <member name="M:MathCore.SynchronizedQueue`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SynchronizedQueue`1.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="disposing">Требуется выполнить освобождение управляемых ресурсов</param>
        </member>
        <member name="M:MathCore.SynchronizedItemsProcessor`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:MathCore.SynchronizedItemsProcessor`1.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="disposing">Требуется выполнить освобождение управляемых ресурсов</param>
        </member>
        <member name="T:MathCore.Text.JaroWinkler">
            <summary>
            Сходство строк по метрике Джаро — Винклера<br/>
            Расстояние между двумя строками, определяемаое как число односимвольных
            преобразований, которое необходимо для того, чтобы изменить одно слово в другое.
            </summary>
            <remarks>
                <seealso href="https://ru.wikipedia.org/wiki/Сходство_Джаро_—_Винклера"/>
            </remarks>
        </member>
        <member name="M:MathCore.Text.JaroWinkler.Distance(System.String,System.String,System.Double,System.Int32,System.Collections.Generic.IEqualityComparer{System.Char})">
            <summary>Метрика в пространстве строк на основе сходства Джаро — Винклера</summary>
            <param name="Str1">Сравниваемая строка</param>
            <param name="Str2">Сравниваемая строка</param>
            <param name="WeightThreshold">Порог применения модификации Winkler</param>
            <param name="PrefixLength">Размер префикса</param>
            <param name="CharComparer">Объект сравнения символов строки</param>
            <returns>Расстояние между в пространстве строк (0 - строки совпадают, 1 - строки не совпадают)</returns>
        </member>
        <member name="M:MathCore.Text.JaroWinkler.Proximity(System.String,System.String,System.Double,System.Int32,System.Collections.Generic.IEqualityComparer{System.Char})">
            <summary>Вычисление сходства двух строк на основе метрики Джаро — Винклера</summary>
            <param name="Str1">Сравниваемая строка</param>
            <param name="Str2">Сравниваемая строка</param>
            <param name="WeightThreshold">Порог применения модификации Winkler</param>
            <param name="PrefixLength">Размер префикса</param>
            <param name="CharComparer">Объект сравнения символов строки</param>
            <returns>Значение от 0 до 1: 0 - строки не совпадают, 1 - строки совпадают</returns>
        </member>
        <member name="T:MathCore.Text.Levenshtein">
            <summary>
            Расстояние Левенштейна (редакционное расстояние)<br/>
            Метрика, измеряющая по модулю разность между двумя последовательностями символов,
            определяемая как минимальное количество односимвольных операций (а именно вставки,
            удаления, замены), необходимых для превращения одной последовательности символов в другую
            </summary>
            <remarks>
                <seealso href="https://ru.wikibooks.org/wiki/Реализации_алгоритмов/Расстояние_Левенштейна#C#"/>
            </remarks>
        </member>
        <member name="T:MathCore.Threading.MaxConcurrencySynchronizationContext">
            <summary>Контекст синхронизации с максимально допустимой степенью параллелизма</summary>
        </member>
        <member name="F:MathCore.Threading.MaxConcurrencySynchronizationContext._Semaphore">
            <summary>Семафор, ограничивающий число выполняемых задач</summary>
        </member>
        <member name="M:MathCore.Threading.MaxConcurrencySynchronizationContext.#ctor(System.Int32)">
            <summary>Инициализация нового контекста синхронизации с ограничением числа параллельно выполняемых задач</summary>
            <param name="MaxConcurrencyLevel">Максимальное число выполняемых в контексте задач</param>
        </member>
        <member name="M:MathCore.Threading.MaxConcurrencySynchronizationContext.OnSemaphoreReleased(System.Threading.Tasks.Task,System.Object)">
            <summary>Метод, вызываемый при освобождении семафора</summary>
            <param name="SemaphoreWaitTask">Задача ожидания освобождения семафора</param>
            <param name="CallState">Массив с параметрами продолжения, хранящий в первом параметре делегат, который надо вызвать, а во втором - параметр вызова делегата</param>
        </member>
        <member name="M:MathCore.Threading.MaxConcurrencySynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Threading.MaxConcurrencySynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave">
            <summary>Provides concurrent and exclusive task schedulers that coordinate.</summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveInterleaveDebugView">
            <summary>Provides a debug view for ConcurrentExclusiveInterleave.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveInterleaveDebugView._Interleave">
            <summary>The interleave being debugged.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveInterleaveDebugView.#ctor(MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave)">
            <summary>Initializes the debug view.</summary>
            <param name="Interleave">The interleave being debugged.</param>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveInterleaveDebugView.ConcurrentTasksWaiting">
            <summary>Gets the number of tasks waiting to run concurrently.</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveInterleaveDebugView.InterleaveTask">
            <summary>Gets a description of the processing task for debugging purposes.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave._InternalLock">
            <summary>Synchronizes all activity in this type and its generated schedulers.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave._ParallelOptions">
            <summary>The parallel options used by the asynchronous task and parallel loops.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave._ConcurrentTaskScheduler">
            <summary>The scheduler used to queue and execute "reader" tasks that may run concurrently with other readers.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave._ExclusiveTaskScheduler">
            <summary>The scheduler used to queue and execute "writer" tasks that must run exclusively while no other tasks for this interleave are running.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave._TaskExecuting">
            <summary>Whether this interleave has queued its processing task.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave._ExclusiveProcessingIncludesChildren">
            <summary>Whether the exclusive processing of a task should include all of its children as well.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.#ctor">
            <summary>Initialies the ConcurrentExclusiveInterleave.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.#ctor(System.Boolean)">
            <summary>Initialies the ConcurrentExclusiveInterleave.</summary>
            <param name="ExclusiveProcessingIncludesChildren">Whether the exclusive processing of a task should include all of its children as well.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.#ctor(System.Threading.Tasks.TaskScheduler,System.Boolean)">
            <summary>Initialies the ConcurrentExclusiveInterleave.</summary>
            <param name="TargetScheduler">The target scheduler on which this interleave should execute.</param>
            <param name="ExclusiveProcessingIncludesChildren">Whether the exclusive processing of a task should include all of its children as well.</param>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentTaskScheduler">
            <summary>
            Gets a TaskScheduler that can be used to schedule tasks to this interleave
            that may run concurrently with other tasks on this interleave.
            </summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ExclusiveTaskScheduler">
            <summary>
            Gets a TaskScheduler that can be used to schedule tasks to this interleave
            that must run exclusively with regards to other tasks on this interleave.
            </summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ExclusiveTaskCount">
            <summary>Gets the number of tasks waiting to run exclusively.</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentTaskCount">
            <summary>Gets the number of tasks waiting to run concurrently.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.NotifyOfNewWork">
            <summary>Notifies the interleave that new work has arrived to be processed.</summary>
            <remarks>Must only be called while holding the lock.</remarks>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveInterleaveProcessor">
            <summary>The body of the async processor to be run in a Task.  Only one should be running at a time.</summary>
            <remarks>This has been separated out into its own method to improve the Parallel Tasks window experience.</remarks>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ExecuteConcurrentTask(System.Threading.Tasks.Task)">
            <summary>Runs a concurrent task.</summary>
            <param name="task">The task to execute.</param>
            <remarks>This has been separated out into its own method to improve the Parallel Tasks window experience.</remarks>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.GetConcurrentTasksUntilExclusiveExists">
            <summary>
            Gets an enumerable that yields waiting concurrent tasks one at a time until
            either there are no more concurrent tasks or there are any exclusive tasks.
            </summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.GetExclusiveTasks">
            <summary>
            Gets an enumerable that yields all of the exclusive tasks one at a time.
            </summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler">
            <summary>
            A scheduler shim used to queue tasks to the interleave and execute those tasks on request of the interleave.
            </summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler._Interleave">
            <summary>The parent interleave.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler._MaximumConcurrencyLevel">
            <summary>The maximum concurrency level for the scheduler.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler._ProcessingTaskOnCurrentThread">
            <summary>Whether a Task is currently being processed on this thread.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler.#ctor(MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave,System.Collections.Generic.Queue{System.Threading.Tasks.Task},System.Int32)">
            <summary>Initializes the scheduler.</summary>
            <param name="interleave">The parent interleave.</param>
            <param name="tasks">The queue to store queued tasks into.</param>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level this scheduler is able to support.</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler.Tasks">
            <summary>Gets the queue of tasks for this scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler.ExecuteTask(System.Threading.Tasks.Task)">
            <summary>Executes a task on this scheduler.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute the task synchronously on this scheduler.</summary>
            <param name="task">The task to execute.</param>
            <param name="TaskWasPreviouslyQueued">Whether the task was previously queued to the scheduler.</param>
            <returns>true if the task could be executed; otherwise, false.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ConcurrentExclusiveInterleave.ConcurrentExclusiveTaskScheduler.GetScheduledTasks">
            <summary>Gets for debugging purposes the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of the tasks queued.</returns>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.CurrentThreadTaskScheduler">
            <summary>Планировщик выполняет задачи синхронно в текущем потоке</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.CurrentThreadTaskScheduler.MaximumConcurrencyLevel">
            <summary>Максимальное число параллельно выполняемых задач в данном планировщике всегда равно 1</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.CurrentThreadTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Планирует выполнение задачи в текущем потоке</summary>
            <param name="task">Задача, которую необходимо выполнить</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.CurrentThreadTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Выполняет задачу синхронно в текущем потоке</summary>
            <param name="task">Задача, которую необходимо выполнить</param>
            <param name="TaskWasPreviouslyQueued">Задача была изначально в очереди данного планировщике</param>
            <returns>Задача была успешно выполнена</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.CurrentThreadTaskScheduler.GetScheduledTasks">
            <summary>Перечень задач, которые должны запланированы на выполнение в текущем планировщике</summary>
            <returns>Всегда возвращает пустое перечисление - задачи выполняются немедленно без планирования</returns>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler">
            <summary>Provides a TaskScheduler that uses an I/O completion port for concurrency control.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler._Tasks">
            <summary>The queue of tasks to be scheduled.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler._IOcp">
            <summary>The I/O completion port to use for concurrency control.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler._SchedulerThread">
            <summary>Whether the current thread is a scheduler thread.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler._RemainingThreadsToShutdown">
            <summary>Event used to wait for all threads to shutdown.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.#ctor(System.Int32,System.Int32)">
            <summary>Initializes the IOCompletionPortTaskScheduler.</summary>
            <param name="MaxConcurrencyLevel">The maximum number of threads in the scheduler to be executing concurrently.</param>
            <param name="NumAvailableThreads">The number of threads to have available in the scheduler for executing tasks.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.Dispose">
            <summary>Dispose of the scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.GetScheduledTasks">
            <summary>Gets a list of all tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of all scheduled tasks.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to this scheduler for execution.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Try to execute a task on the current thread.</summary>
            <param name="task">The task to execute.</param>
            <param name="TaskWasPreviouslyQueued">Whether the task was previously queued to this scheduler.</param>
            <returns>Whether the task was executed.</returns>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort">
            <summary>Provides a simple managed wrapper for an I/O completion port.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort.__InfiniteTimeout">
            <summary>Infinite timeout value to use for GetQueuedCompletedStatus.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort._InvalidFileHandle">
            <summary>An invalid file handle value.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort._InvalidIocpHandle">
            <summary>An invalid I/O completion port handle value.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort._Handle">
            <summary>The I/O completion porth handle.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort.#ctor(System.Int32)">
            <summary>Initializes the I/O completion port.</summary>
            <param name="MaxConcurrencyLevel">The maximum concurrency level allowed by the I/O completion port.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort.Dispose">
            <summary>Clean up.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort.NotifyOne">
            <summary>Notify that I/O completion port that new work is available.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort.WaitOne">
            <summary>Waits for an item on the I/O completion port.</summary>
            <returns>true if an item was available; false if the completion port closed before an item could be retrieved.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort.CreateIoCompletionPort(System.IntPtr,System.IntPtr,System.UIntPtr,System.UInt32)">
            <summary>
            Creates an input/output (I/O) completion port and associates it with a specified file handle, 
            or creates an I/O completion port that is not yet associated with a file handle, allowing association at a later time.
            </summary>
            <param name="FileHandle">An open file handle or INVALID_HANDLE_VALUE.</param>
            <param name="ExistingCompletionPort">A handle to an existing I/O completion port or NULL.</param>
            <param name="CompletionKey">The per-handle user-defined completion key that is included in every I/O completion packet for the specified file handle.</param>
            <param name="NumberOfConcurrentThreads">The maximum number of threads that the operating system can allow to concurrently process I/O completion packets for the I/O completion port.</param>
            <returns>If the function succeeds, the return value is the handle to an I/O completion port.  If the function fails, the return value is NULL.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort.GetQueuedCompletionStatus(System.IntPtr,System.UInt32@,System.IntPtr@,System.IntPtr@,System.UInt32)">
            <summary>Attempts to dequeue an I/O completion packet from the specified I/O completion port.</summary>
            <param name="CompletionPort">A handle to the completion port.</param>
            <param name="LpNumberOfBytes">A pointer to a variable that receives the number of bytes transferred during an I/O operation that has completed.</param>
            <param name="LpCompletionKey">A pointer to a variable that receives the completion key value associated with the file handle whose I/O operation has completed.</param>
            <param name="LpOverlapped">A pointer to a variable that receives the address of the OVERLAPPED structure that was specified when the completed I/O operation was started.</param>
            <param name="DwMilliseconds">The number of milliseconds that the caller is willing to wait for a completion packet to appear at the completion port. </param>
            <returns>Returns nonzero (TRUE) if successful or zero (FALSE) otherwise.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.IOCompletionPortTaskScheduler.IOCompletionPort.PostQueuedCompletionStatus(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>Posts an I/O completion packet to an I/O completion port.</summary>
            <param name="CompletionPort">A handle to the completion port.</param>
            <param name="DwNumberOfBytesTransferred">The value to be returned through the lpNumberOfBytesTransferred parameter of the GetQueuedCompletionStatus function.</param>
            <param name="DwCompletionKey">The value to be returned through the lpCompletionKey parameter of the GetQueuedCompletionStatus function.</param>
            <param name="LpOverlapped">The value to be returned through the lpOverlapped parameter of the GetQueuedCompletionStatus function.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</returns>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler">
            <summary>Планировщик, способный выполнять не более указанного числа задач параллельно</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler.__CurrentThreadIsProcessingItems">
            <summary>Флаг, определяющий что текущий поток осуществляет выполнение задачи</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler._Tasks">
            <summary>Список задач, требующих исполнения</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler._MaximumConcurrencyLevel">
            <summary>Максимальный уровень параллелизма, определённый для данного планировщика</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler._DelegatesQueuedOrRunning">
            <summary>Определяет число задач, выполняемых в текущий момент планировщиком</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler.MaximumConcurrencyLevel">
            <summary>Максимальный уровень параллелизма, поддерживаемый планировщиком</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра планировщика</summary>
            <param name="MaximumConcurrencyLevel">Максимальное число одновременно выполняемых задач</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Добавление задачи в очередь на исполнение</summary>
            <param name="task">Задача, требующая выполнения в планировщиком</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler.NotifyThreadPoolOfPendingWork">
            <summary>Информирование пула потоков о том, что поступила новая задача на исполнение</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Запуск обработки очередной задачи в текущем потоке</summary>
            <param name="task">Задача, требующая выполнения</param>
            <param name="TaskWasPreviouslyQueued">
            Значение, указывающее, была ли задача ранее поставлена в очередь.
            Если этот параметр True, то задача, возможно, ранее была в очереди (по расписанию);
            Если False, то задача, не стояла в очереди, и её требуется выполнить без постановки в очередь.
            </param>
            <returns>Ы</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
            <summary>Попытка удалить задачу из очереди</summary>
            <param name="task">Удаляемая задача</param>
            <returns>Истина, если задача была успешно удалена из очереди</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.LimitedConcurrencyLevelTaskScheduler.GetScheduledTasks">
            <summary>Получить перечисление запланированных задач в планировщике</summary>
            <returns>Перечисление запланированных на текущий момент задач</returns>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.OrderedTaskScheduler">
            <summary>Планировщик, обеспечивающий одновременное выполнение только одной задачи</summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler">
            <summary>Планировщик обеспечивает постановку задач в очередь с приоритетами</summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerDebugView">
            <summary>Отладочное представление</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerDebugView._Scheduler">
            <summary>The scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.#ctor(MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler)">
            <summary>Инициализация отладочного представления для планировщика</summary>
            <param name="scheduler">Рассматриваемый планировщик</param>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.ScheduledTasks">
            <summary>Извлечение всех задач, запланированных непосредственно в планировщике</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerDebugView.Queues">
            <summary>Все очереди задач</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler._QueueGroups">
            <summary>
            Отсортированный список циклических списков.
            Задачи с малыми приоритетами являются предпочтительными.
            Группы приоритетов являются циклическими в пределах одного уровня приоритета.
            </summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler._DisposeCancellation">
            <summary>Система отмены задач в случае вызова метода <see cref="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.Dispose"/></summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler._ConcurrencyLevel">
            <summary>
            Максимально допустимый уровень конкурентности для текущего планировщика.
            Если используются вручную создаваемые потоки, то данное поле отображает число создаваемых потоков.
            </summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.__TaskProcessingThread">
            <summary>Whether we're processing tasks on the current thread.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler._TargetScheduler">
            <summary>The scheduler onto which actual work is scheduled.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler._NonThreadSafeTaskQueue">
            <summary>The queue of tasks to process when using an underlying target scheduler.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler._DelegatesQueuedOrRunning">
            <summary>The number of Tasks that have been queued or that are running whiel using an underlying scheduler.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler._BlockingTaskQueue">
            <summary>The collection of tasks to be executed on our custom threads.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.#ctor">
            <summary>Initializes the scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.#ctor(System.Threading.Tasks.TaskScheduler,System.Int32)">
            <summary>Initializes the scheduler.</summary>
            <param name="TargetScheduler">The target underlying scheduler onto which this sceduler's work is queued.</param>
            <param name="MaxConcurrencyLevel">The maximum degree of concurrency allowed for this scheduler's work.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.#ctor(System.Int32)">
            <summary>Initializes the scheduler.</summary>
            <param name="ThreadCount">The number of threads to create and use for processing work items.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.#ctor(System.Int32,System.String,System.Boolean,System.Threading.ThreadPriority,System.Threading.ApartmentState,System.Int32,System.Action,System.Action)">
            <summary>Initializes the scheduler.</summary>
            <param name="ThreadCount">The number of threads to create and use for processing work items.</param>
            <param name="ThreadName">The name to use for each of the created threads.</param>
            <param name="UseForegroundThreads">A Boolean value that indicates whether to use foreground threads instead of background.</param>
            <param name="ThreadPriority">The priority to assign to each thread.</param>
            <param name="ThreadApartmentState">The apartment state to use for each thread.</param>
            <param name="ThreadMaxStackSize">The stack size to use for each thread.</param>
            <param name="ThreadInit">An initialization routine to run on each thread.</param>
            <param name="ThreadFinally">A finalization routine to run on each thread.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.ThreadBasedDispatchLoop(System.Action,System.Action)">
            <summary>The dispatch loop run by all threads in this scheduler.</summary>
            <param name="ThreadInit">An initialization routine to run when the thread begins.</param>
            <param name="ThreadFinally">A finalization routine to run before the thread ends.</param>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.DebugQueueCount">
            <summary>Gets the number of queues currently activated.</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.DebugTaskCount">
            <summary>Gets the number of tasks currently scheduled.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.FindNextTask_NeedsLock(System.Threading.Tasks.Task@,MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue@)">
            <summary>Find the next task that should be executed, based on priorities and fairness and the like.</summary>
            <param name="TargetTask">The found task, or null if none was found.</param>
            <param name="QueueForTargetTask">
            The scheduler associated with the found task.  Due to security checks inside of TPL,  
            this scheduler needs to be used to execute that task.
            </param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.ProcessPrioritizedAndBatchedTasks">
            <summary>
            Process tasks one at a time in the best order.  
            This should be run in a Task generated by QueueTask.
            It's been separated out into its own method to show up better in Parallel Tasks.
            </summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.NotifyNewWorkItem">
            <summary>Notifies the pool that there's a new item to be executed in one of the round-robin queues.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute a task synchronously on the current thread.</summary>
            <param name="task">The task to execute.</param>
            <param name="TaskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was executed; otherwise, false.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.GetScheduledTasks">
            <summary>Gets the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of all tasks queued to this scheduler.</returns>
            <remarks>This does not include the tasks on sub-schedulers.  Those will be retrieved by the debugger separately.</remarks>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level to use when processing tasks.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.Dispose">
            <summary>Initiates shutdown of the scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.ActivateNewQueue">
            <summary>Creates and activates a new scheduling queue for this scheduler.</summary>
            <returns>The newly created and activated queue at priority 0.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.ActivateNewQueue(System.Int32)">
            <summary>Creates and activates a new scheduling queue for this scheduler.</summary>
            <param name="priority">The priority level for the new queue.</param>
            <returns>The newly created and activated queue at the specified priority.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.RemoveQueue_NeedsLock(MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue)">
            <summary>Removes a scheduler from the group.</summary>
            <param name="queue">The scheduler to be removed.</param>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueueGroup">
            <summary>A group of queues a the same priority level.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueueGroup.NextQueueIndex">
            <summary>The starting index for the next round-robin traversal.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueueGroup.CreateSearchOrder">
            <summary>Creates a search order through this group.</summary>
            <returns>An enumerable of indices for this group.</returns>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue">
            <summary>Provides a scheduling queue associatd with a QueuedTaskScheduler.</summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView">
            <summary>A debug view for the queue.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView._Queue">
            <summary>The queue.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.#ctor(MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue)">
            <summary>Initializes the debug view.</summary>
            <param name="queue">The queue to be debugged.</param>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.Priority">
            <summary>Gets the priority of this queue in its associated scheduler.</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.Id">
            <summary>Gets the ID of this scheduler.</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.ScheduledTasks">
            <summary>Gets all of the tasks scheduled to this queue.</summary>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueuedTaskSchedulerQueueDebugView.AssociatedScheduler">
            <summary>Gets the QueuedTaskScheduler with which this queue is associated.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue._Pool">
            <summary>The scheduler with which this pool is associated.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.WorkItems">
            <summary>The work items stored in this queue.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.Disposed">
            <summary>Whether this queue has been disposed.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.Priority">
            <summary>Gets the priority for this queue.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.#ctor(System.Int32,MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler)">
            <summary>Initializes the queue.</summary>
            <param name="priority">The priority associated with this queue.</param>
            <param name="pool">The scheduler with which this queue is associated.</param>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.WaitingTasks">
            <summary>Gets the number of tasks waiting in this scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.GetScheduledTasks">
            <summary>Gets the tasks scheduled to this scheduler.</summary>
            <returns>An enumerable of all tasks queued to this scheduler.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute a task synchronously on the current thread.</summary>
            <param name="task">The task to execute.</param>
            <param name="TaskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was executed; otherwise, false.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.ExecuteTask(System.Threading.Tasks.Task)">
            <summary>Runs the specified ask.</summary>
            <param name="task">The task to execute.</param>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level to use when processing tasks.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.QueuedTaskScheduler.QueuedTaskSchedulerQueue.Dispose">
            <summary>Signals that the queue should be removed from the scheduler as soon as the queue is empty.</summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.ReprioritizableTaskScheduler">
            <summary>Provides a task scheduler that supports reprioritizing previously queued tasks.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ReprioritizableTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler.</summary>
            <param name="task">The task to be queued.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ReprioritizableTaskScheduler.Prioritize(System.Threading.Tasks.Task)">
            <summary>Reprioritizes a previously queued task to the front of the queue.</summary>
            <param name="task">The task to be reprioritized.</param>
            <returns>Whether the task could be found and moved to the front of the queue.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ReprioritizableTaskScheduler.Deprioritize(System.Threading.Tasks.Task)">
            <summary>Reprioritizes a previously queued task to the back of the queue.</summary>
            <param name="task">The task to be reprioritized.</param>
            <returns>Whether the task could be found and moved to the back of the queue.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ReprioritizableTaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
            <summary>Removes a previously queued item from the scheduler.</summary>
            <param name="task">The task to be removed.</param>
            <returns>Whether the task could be removed from the scheduler.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ReprioritizableTaskScheduler.ProcessNextQueuedItem(System.Object)">
            <summary>Picks up and executes the next item in the queue.</summary>
            <param name="Ignored">Ignored.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ReprioritizableTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Executes the specified task inline.</summary>
            <param name="task">The task to be executed.</param>
            <param name="TaskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>Whether the task could be executed inline.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ReprioritizableTaskScheduler.GetScheduledTasks">
            <summary>Gets all of the tasks currently queued to the scheduler.</summary>
            <returns>An enumerable of the tasks currently queued to the scheduler.</returns>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.RoundRobinSchedulerGroup">
            <summary>Enables the creation of a group of schedulers that support round-robin scheduling for fairness.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.RoundRobinSchedulerGroup.CreateScheduler">
            <summary>Creates a new scheduler as part of this group.</summary>
            <returns>The new scheduler.</returns>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.RoundRobinSchedulerGroup.Schedulers">
            <summary>Gets a collection of all schedulers in this group.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.RoundRobinSchedulerGroup.RemoveQueue_NeedsLock(MathCore.Threading.Tasks.Schedulers.RoundRobinSchedulerGroup.RoundRobinTaskSchedulerQueue)">
            <summary>Removes a scheduler from the group.</summary>
            <param name="queue">The scheduler to be removed.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.RoundRobinSchedulerGroup.NotifyNewWorkItem">
            <summary>Notifies the ThreadPool that there's a new item to be executed.</summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.RoundRobinSchedulerGroup.RoundRobinTaskSchedulerQueue">
            <summary>A scheduler that participates in round-robin scheduling.</summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler">
            <summary>Provides a scheduler that uses STA threads.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler._Tasks">
            <summary>Stores the queued tasks to be executed by our pool of STA threads.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler._Threads">
            <summary>The STA threads used by the scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler.#ctor(System.Int32)">
            <summary>Initializes a new instance of the StaTaskScheduler class with the specified concurrency level.</summary>
            <param name="NumberOfThreads">The number of threads that should be created and used by this scheduler.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a Task to be executed by this scheduler.</summary>
            <param name="task">The task to be executed.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler.GetScheduledTasks">
            <summary>Provides a list of the scheduled tasks for the debugger to consume.</summary>
            <returns>An enumerable of all tasks currently scheduled.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Determines whether a Task may be inlined.</summary>
            <param name="task">The task to be executed.</param>
            <param name="TaskWasPreviouslyQueued">Whether the task was previously queued.</param>
            <returns>true if the task was successfully inlined; otherwise, false.</returns>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level supported by this scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.StaTaskScheduler.Dispose">
            <summary>
            Cleans up the scheduler by indicating that no more tasks will be queued.
            This method blocks until all threads successfully shutdown.
            </summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler">
            <summary>Provides a task scheduler that targets a specific SynchronizationContext.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler._Tasks">
            <summary>The queue of tasks to execute, maintained for debugging purposes.</summary>
        </member>
        <member name="F:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler._Context">
            <summary>The target context under which to execute the queued tasks.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler.#ctor">
            <summary>Initializes an instance of the SynchronizationContextTaskScheduler class.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler.#ctor(System.Threading.SynchronizationContext)">
            <summary>
            Initializes an instance of the SynchronizationContextTaskScheduler class
            with the specified SynchronizationContext.
            </summary>
            <param name="context">The SynchronizationContext under which to execute tasks.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Queues a task to the scheduler for execution on the I/O ThreadPool.</summary>
            <param name="task">The Task to queue.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Tries to execute a task on the current thread.</summary>
            <param name="task">The task to be executed.</param>
            <param name="TaskWasPreviouslyQueued">Ignored.</param>
            <returns>Whether the task could be executed.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler.GetScheduledTasks">
            <summary>Gets an enumerable of tasks queued to the scheduler.</summary>
            <returns>An enumerable of tasks queued to the scheduler.</returns>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.SynchronizationContextTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level supported by this scheduler.</summary>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.ThreadPerTaskScheduler">
            <summary>Планировщик обеспечивает создание отдельного потока на каждую выполняемою задачу</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ThreadPerTaskScheduler.GetScheduledTasks">
            <summary>Получить перечень запланированных задач в данном планировщике (всегда возвращает пустое перечисление)</summary>
            <remarks>Данный планировщик не задерживает задачи, а исполняет их по мере поступления</remarks>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ThreadPerTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Запускает новый поток для выполнения задачи</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.ThreadPerTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Выполняет задачу в текущем потоке</summary>
            <param name="task">Выполняемая задача</param>
            <param name="TaskWasPreviouslyQueued">Параметр игнорируется</param>
            <returns>Истина, если задача выполнена успешно</returns>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.WorkStealingQueue`1">
            <summary>A work-stealing queue.</summary>
            <typeparam name="T">Specifies the type of data stored in the queue.</typeparam>
        </member>
        <member name="T:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler">
            <summary>Планировщик с собственным пулом потоков</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.#ctor">
            <summary>Инициализация нового планировщика с числом потоков, равным удвоенному числу процессоров в системе</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.#ctor(System.Int32)">
            <summary>Инициализация нового планировщика с указанным числом потоков</summary>
            <param name="ConcurrencyLevel">Число потоков, доступных планировщику</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>Добавление задачи в очередь к планировщику</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>Executes a task on the current thread.</summary>
            <param name="task">The task to be executed.</param>
            <param name="TaskWasPreviouslyQueued">Ignored.</param>
            <returns>Whether the task could be executed.</returns>
        </member>
        <member name="P:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.MaximumConcurrencyLevel">
            <summary>Gets the maximum concurrency level supported by this scheduler.</summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.GetScheduledTasks">
            <summary>Gets all of the tasks currently scheduled to this scheduler.</summary>
            <returns>An enumerable containing all of the scheduled tasks.</returns>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.AddQueue(MathCore.Threading.Tasks.Schedulers.WorkStealingQueue{System.Threading.Tasks.Task})">
            <summary>Adds a work-stealing queue to the set of queues.</summary>
            <param name="queue">The queue to be added.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.RemoveWsq(MathCore.Threading.Tasks.Schedulers.WorkStealingQueue{System.Threading.Tasks.Task})">
            <summary>Remove a work-stealing queue from the set of queues.</summary>
            <param name="wsq">The work-stealing queue to remove.</param>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.DispatchLoop">
            <summary>
            The dispatch loop run by each thread in the scheduler.
            </summary>
        </member>
        <member name="M:MathCore.Threading.Tasks.Schedulers.WorkStealingTaskScheduler.Dispose">
            <summary>Signal the scheduler to shutdown and wait for all threads to finish.</summary>
        </member>
        <member name="T:MathCore.Time.TimeCounter">
            <summary>Измеритель времени</summary>
        </member>
        <member name="F:MathCore.Time.TimeCounter._Started">
            <summary>Флаг состояния</summary>
        </member>
        <member name="F:MathCore.Time.TimeCounter._LockObject">
            <summary>Объект межпотоковой синхронизации</summary>
        </member>
        <member name="P:MathCore.Time.TimeCounter.IsStarted">
            <summary>Состояние измерителя</summary>
        </member>
        <member name="P:MathCore.Time.TimeCounter.TotalTime">
            <summary>Прошло времени</summary>
        </member>
        <member name="M:MathCore.Time.TimeCounter.Start">
            <summary>Запуск</summary>
        </member>
        <member name="M:MathCore.Time.TimeCounter.Stop">
            <summary>Остановка</summary>
        </member>
        <member name="M:MathCore.Time.TimeCounter.Reset">
            <summary>Сброс измерителя</summary>
        </member>
        <member name="T:MathCore.TimeInterval">
            <summary>Интервальный предикат</summary>
        </member>
        <member name="F:MathCore.TimeInterval._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.TimeInterval._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.TimeInterval._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.TimeInterval._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.TimeInterval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.TimeInterval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.TimeInterval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.TimeInterval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.TimeInterval.Length">
            <summary>Протяжённость интервала</summary>
        </member>
        <member name="M:MathCore.TimeInterval.#ctor(System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.TimeInterval.#ctor(System.TimeSpan,System.TimeSpan)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.TimeInterval.#ctor(System.TimeSpan,System.TimeSpan,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathCore.TimeInterval.#ctor(System.TimeSpan,System.Boolean,System.TimeSpan,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.TimeInterval.Check(System.TimeSpan)">
            <summary>Проверка на вхождение в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <returns>Истина, если величина входит в интервал</returns>
        </member>
        <member name="M:MathCore.TimeInterval.IsInclude(MathCore.TimeInterval)">
            <summary>Проверка вхождения интервала в интервал</summary>
            <param name="I">Проверяемый интервал</param>
            <returns>Истина, если проверяемый интервал входит</returns>
        </member>
        <member name="M:MathCore.TimeInterval.op_Implicit(MathCore.TimeInterval)~System.Predicate{System.TimeSpan}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathCore.TimeInterval.op_ExclusiveOr(System.TimeSpan,MathCore.TimeInterval)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="x">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathCore.TimeInterval.op_ExclusiveOr(MathCore.TimeInterval,System.TimeSpan)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathCore.DateTimeInterval">
            <summary>Интервальный предикат</summary>
        </member>
        <member name="F:MathCore.DateTimeInterval._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.DateTimeInterval._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.DateTimeInterval._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.DateTimeInterval._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.DateTimeInterval.Length">
            <summary>Протяжённость интервала</summary>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime)">
            <summary>Интервал</summary>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime,System.DateTime)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime,System.DateTime,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime,System.Boolean,System.DateTime)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.#ctor(System.DateTime,System.Boolean,System.DateTime,System.Boolean)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
        </member>
        <member name="M:MathCore.DateTimeInterval.Check(System.DateTime)">
            <summary>Проверка на вхождение в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <returns></returns>
        </member>
        <member name="M:MathCore.DateTimeInterval.op_Implicit(MathCore.DateTimeInterval)~System.Predicate{System.DateTime}">
            <summary>Оператор неявного приведения типа к предикату</summary>
            <param name="I">Интервал</param>
            <returns>Предикат от вещественного типа двойной точности</returns>
        </member>
        <member name="M:MathCore.DateTimeInterval.op_ExclusiveOr(System.DateTime,MathCore.DateTimeInterval)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="x">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="M:MathCore.DateTimeInterval.op_ExclusiveOr(MathCore.DateTimeInterval,System.DateTime)">
            <summary>Оператор проверки на вхождение величины в интервал</summary>
            <param name="X">Проверяемая величина</param>
            <param name="I">Интервал</param>
            <returns>Истина, если величина внутри интервала</returns>
        </member>
        <member name="T:MathCore.TimeoutEvent`1">
            <summary>Класс задержки реакции на событие</summary>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.Subscribe(System.Int32,System.EventHandler{`0},System.EventHandler{`0})">
            <summary>Метод подписки на событие</summary>
            <param name="Timeout">Таймаут</param>
            <param name="OnTimeout">Метод обработки первичного вызова события</param>
            <param name="OnInvoke">Метод обработки вторичного события</param>
            <returns>Обработчик исходного события</returns>
        </member>
        <member name="F:MathCore.TimeoutEvent`1.__Infinite">
            <summary>Константа бесконечного периода ожидания</summary>
        </member>
        <member name="T:MathCore.TimeoutEvent`1.Info">
            <summary>Аргумент события</summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.Info.EventSender">
            <summary>Источник сходного события</summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.Info.E">
            <summary>Аргумент исходного события</summary>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.Info.#ctor(System.Object,`0)">
            <summary>Аргумент события</summary>
            <param name="EventSender">Источник исходного события</param>
            <param name="e">Аргумент исходного события</param>
        </member>
        <member name="E:MathCore.TimeoutEvent`1.Invoked">
            <summary>Первичная генерация события</summary>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.OnInvoked(MathCore.TimeoutEvent{`0}.Info)">
            <summary>Метод первичной генерации события <see cref="E:MathCore.TimeoutEvent`1.Invoked"/></summary>
            <param name="e">Аргумент первичного вызова события</param>
        </member>
        <member name="E:MathCore.TimeoutEvent`1.AfterTimeout">
            <summary>Событие, возникающее после последнего вызова метода <see cref="M:MathCore.TimeoutEvent`1.Invoke(System.Object,`0)"/> через период времени <see cref="P:MathCore.TimeoutEvent`1.Timeout"/></summary>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.OnAfterTimeout(MathCore.TimeoutEvent{`0}.Info)">
            <summary>Метод генерации события <see cref="E:MathCore.TimeoutEvent`1.AfterTimeout"/></summary>
            <param name="e">Аргумент события</param>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._Timer">
            <summary>Таймер</summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._Timeout">
            <summary>Период времени таймаута</summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._LastCallTime">
            <summary>Время последнего вызова</summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._InProcess">
            <summary>Признак ожидания таймаута события</summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._LastEventArgs">
            <summary>Аргумент последнего вызова метода <see cref="M:MathCore.TimeoutEvent`1.Invoke(System.Object,`0)"/></summary>
        </member>
        <member name="F:MathCore.TimeoutEvent`1._NeedAbort">
            <summary>Признак ожидания отмены генерации события <see cref="E:MathCore.TimeoutEvent`1.AfterTimeout"/></summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.Timeout">
            <summary>Задержка во времени генерации события <see cref="E:MathCore.TimeoutEvent`1.AfterTimeout"/> в миллисекундах</summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.LastCallTime">
            <summary>Время последнего вызова метода <see cref="M:MathCore.TimeoutEvent`1.Invoke(System.Object,`0)"/></summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.InProcess">
            <summary>Признак ожидания генерации события <see cref="E:MathCore.TimeoutEvent`1.Invoked"/></summary>
        </member>
        <member name="P:MathCore.TimeoutEvent`1.NeedAbort">
            <summary>Признак отмены генерации соития <see cref="E:MathCore.TimeoutEvent`1.AfterTimeout"/></summary>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.#ctor(System.Int32)">
            <summary>Инициализация нового объекта задержки генерации события</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.#ctor(System.Int32,System.EventHandler{`0})">
            <summary>Инициализация нового объекта задержки генерации события</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
            <param name="OnTimeout">Метод вторичной обработки события</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.#ctor(System.Int32,System.EventHandler{`0},System.EventHandler{`0})">
            <summary>Инициализация нового объекта задержки генерации события</summary>
            <param name="Timeout">Временная задержка в миллисекундах</param>
            <param name="OnTimeout">Метод вторичной обработки события</param>
            <param name="OnInvoke">Метод первичной обработки события</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.OnTimer(System.Object)">
            <summary>Метод обработки события таймера</summary>
            <param name="State">Состояние таймера</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.Invoke(System.Object,`0)">
            <summary>Метод генерации события</summary>
            <param name="EventSender">Источник события</param>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:MathCore.TimeoutEvent`1.Abort">
            <summary>Отмена реакции на событие</summary>
        </member>
        <member name="T:MathCore.Trees.ITreeLeveledNode`1">
            <summary>Узел дерева, для которого уопределён его уровень</summary>
            <typeparam name="T">Тип узла дерева</typeparam>
        </member>
        <member name="P:MathCore.Trees.ITreeLeveledNode`1.Level">
            <summary>Уровень узла дерева</summary>
        </member>
        <member name="T:MathCore.Trees.ITreeNode`1">
            <summary>Элемент двусвязного дерева</summary>
            <typeparam name="T">Тип узла дерева</typeparam>
        </member>
        <member name="P:MathCore.Trees.ITreeNode`1.Parent">
            <summary>Родительский узел</summary>
        </member>
        <member name="P:MathCore.Trees.ITreeNode`1.Childs">
            <summary>Дочерние узлы</summary>
        </member>
        <member name="T:MathCore.Trees.ITreeNode`2">
            <summary>Элемент двусвязного дерева</summary>
            <typeparam name="T">Тип узла дерева</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
        </member>
        <member name="P:MathCore.Trees.ITreeNode`2.Value">
            <summary>Значение узла</summary>
        </member>
        <member name="T:MathCore.Trees.ITreeNodeEx">
            <summary>Методы-расширения интерфейса элемента двусвязного дерева</summary>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.AsTreeNode``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,``0})">
            <summary>Представить значение как узел дерева</summary>
            <typeparam name="T">Тип значения дерева</typeparam>
            <param name="Value">Значение узла дерева</param>
            <param name="ChildsSelector">Метод извлечения дочерних значений текущего узла</param>
            <param name="ParentSelector">Метод извлечения значения родительского узла</param>
            <returns>Текущий узел дерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.GetRootNode``1(``0)">
            <summary>Определение корня дерева</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Node">Объект с интерфейсом элемента дерева</param>
            <returns>Корневой объект дерева объектов</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.GetParents``1(``0)">
            <summary>Получить все родительские элементы</summary>
            <typeparam name="T">Тип элемента, являющегося классом и определяющего интерфейс элемента дерева</typeparam>
            <param name="Node">Объект с интерфейсом элемента дерева</param>
            <returns>Массив элементов родительских узлов дерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.EnumerateParents``1(``0)">
            <summary>Перечислить всех предков текущего узла</summary>
            <typeparam name="T">Тип узла дерева</typeparam>
            <param name="Node">Текущий узел</param>
            <returns>Перечисление предков</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.EnumerateParentValues``2(MathCore.Trees.ITreeNode{``0,``1})">
            <summary>Перечислить значения всех узлов-предков текущего узла</summary>
            <typeparam name="T">Тип узла дерева</typeparam>
            <typeparam name="TValue">Тип значения узла</typeparam>
            <param name="Node">Текущий узел дерева</param>
            <returns>Перечисление значений родительских узлов текущего узла дерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.GetParentValues``2(MathCore.Trees.ITreeNode{``0,``1})">
            <summary>Получить массив значений всех узлов-предков текущего узла</summary>
            <typeparam name="T">Тип узла дерева</typeparam>
            <typeparam name="TValue">Тип значения узла</typeparam>
            <param name="Node">Текущий узел дерева</param>
            <returns>Массив значений родительских узлов текущего узла дерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.EnumerateChilds``1(``0,System.Func{``0,System.Boolean},System.Boolean)">
            <summary>Перечисление всех дочерних узлов дерева</summary>
            <typeparam name="T">Тип узла дерева</typeparam>
            <param name="Node">Текущий узел дерева</param>
            <param name="ProcessChilds">Метод, определяющий необходимость обработки дочерних узлов</param>
            <param name="ParentFirst">Формировать в перечислении родительский узел первым</param>
            <returns>Перечисление дочерних узлов поддерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.EnumerateChildsWithRoot``1(``0,System.Func{``0,System.Boolean},System.Boolean)">
            <summary>Перечисление всех дочерних узлов дерева вместе с текущим узлом</summary>
            <typeparam name="T">Тип узла дерева</typeparam>
            <param name="Node">Текущий узел дерева</param>
            <param name="ProcessChilds">Метод, определяющий необходимость обработки дочерних узлов</param>
            <param name="CurrentFirst">Формировать в перечислении родительский узел первым</param>
            <returns>Перечисление дочерних узлов поддерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.EnumerateChildValues``1(MathCore.Trees.ITreeValuedNode{``0},System.Func{MathCore.Trees.ITreeValuedNode{``0},System.Boolean},System.Boolean)">
            <summary>Перечисление значений всех дочерних узлов дерева</summary>
            <typeparam name="T">Тип значения узла</typeparam>
            <param name="Node">Текущий узел дерева</param>
            <param name="ProcessChilds">Метод, определяющий необходимость обработки дочерних узлов</param>
            <param name="ParentFirst">Формировать в перечислении родительский узел первым</param>
            <returns>Перечисление значений дочерних узлов поддерева</returns>
        </member>
        <member name="M:MathCore.Trees.ITreeNodeEx.EnumerateChildValuesWithRoot``1(MathCore.Trees.ITreeValuedNode{``0},System.Func{MathCore.Trees.ITreeValuedNode{``0},System.Boolean},System.Boolean)">
            <summary>Перечисление значений всех дочерних узлов дерева вместе с текущим узлом</summary>
            <typeparam name="T">Тип значения узла</typeparam>
            <param name="Node">Текущий узел дерева</param>
            <param name="ProcessChilds">Метод, определяющий необходимость обработки дочерних узлов</param>
            <param name="CurrentFirst">Формировать в перечислении родительский узел первым</param>
            <returns>Перечисление значений дочерних узлов поддерева</returns>
        </member>
        <member name="T:MathCore.Trees.ITreeValuedNode`1">
            <summary>Узел дерева со значением</summary>
            <typeparam name="T">Тип значения узла</typeparam>
        </member>
        <member name="M:MathCore.TypeConverter`2.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.UsingDisposableObject`1">
            <summary>Класс-обёртка для inline-доступа к свойствам созданного объекта, наследующего интерфейс IDisposable</summary>
            <typeparam name="T">Тип используемого объекта, наследующего интерфейс IDisposable</typeparam>
        </member>
        <member name="M:MathCore.UsingDisposableObject`1.#ctor(`0)">
            <summary>Новая обёртка для используемого объекта</summary>
            <param name="Obj">Используемый объект</param>
        </member>
        <member name="M:MathCore.UsingDisposableObject`1.GetValue``1(System.Func{`0,``0})">
            <summary>Получить значение от объекта</summary>
            <typeparam name="TValue">Тип значения, получаемого от объекта</typeparam>
            <param name="f">Метод получения значения</param>
            <returns>Значение, полученное от объекта указанным методом</returns>
        </member>
        <member name="T:MathCore.UsingObject`1">
            <summary>Оболочка, обеспечивающая освобождение ресурсов указанным методом для указанного объекта</summary>
            <typeparam name="T">Тип объекта, с которым работает оболочка</typeparam>
        </member>
        <member name="F:MathCore.UsingObject`1._Obj">
            <summary>Используемый объект</summary>
        </member>
        <member name="F:MathCore.UsingObject`1._Disposer">
            <summary>Метод освобождения ресурсов</summary>
        </member>
        <member name="P:MathCore.UsingObject`1.Object">
            <summary>Используемый объект</summary>
        </member>
        <member name="M:MathCore.UsingObject`1.#ctor(`0,System.Action{`0})">
            <summary>Упаковка объекта в оболочку с указанием метода освобождения ресурсов, занимаемых указанным объектом</summary>
            <param name="obj">Уничтожаемый объект</param>
            <param name="Disposer">Метод освобождения ресурсов</param>
        </member>
        <member name="M:MathCore.UsingObject`1.Dispose">
            <summary>Разрушение обёртки, влекущее разрушение используемого объекта</summary>
        </member>
        <member name="F:MathCore.UsingObject`1._Disposed">
            <summary>Объект разрушен</summary>
        </member>
        <member name="M:MathCore.UsingObject`1.Dispose(System.Boolean)">
            <summary>Разрушение обёртки, влекущее разрушение используемого объекта</summary>
        </member>
        <member name="M:MathCore.UsingObject`1.op_Implicit(MathCore.UsingObject{`0})~`0">
            <summary>Оператор неявного приведения типов</summary>
            <param name="obj">Объект-оболочка</param>
            <returns>Внутренний объект</returns>
        </member>
        <member name="T:MathCore.ValuedInterval`1">
            <summary>Интервал вещественных значений двойной точности</summary>
        </member>
        <member name="M:MathCore.ValuedInterval`1.Comparer_Length(MathCore.ValuedInterval{`0},MathCore.ValuedInterval{`0})">
            <summary>Метод сравнения двух интервалов</summary>
            <param name="a">Первый сравниваемый интервал</param>
            <param name="b">Второй сравниваемый интервал</param>
            <returns>1 - если первый интервал больше второго, -1 - если первый интервал меньше второго, 0 - если интервалы равны</returns>
        </member>
        <member name="F:MathCore.ValuedInterval`1._MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.ValuedInterval`1._MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="F:MathCore.ValuedInterval`1._Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="F:MathCore.ValuedInterval`1._Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.MinInclude">
            <summary>Включена ли нижняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.MaxInclude">
            <summary>Включена ли верхняя граница интервала?</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.Min">
            <summary>Нижняя граница интервала</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.Max">
            <summary>Верхняя граница интервала</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.Length">
            <summary>Длина интервала</summary>
        </member>
        <member name="P:MathCore.ValuedInterval`1.Middle">
            <summary>Середина интервала</summary>
        </member>
        <member name="M:MathCore.ValuedInterval`1.#ctor(System.Double,System.Double,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="Value">Значение</param>
        </member>
        <member name="M:MathCore.ValuedInterval`1.#ctor(System.Double,System.Double,System.Boolean,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="IncludeLimits">Включать пределы?</param>
            <param name="Value">Значение</param>
        </member>
        <member name="M:MathCore.ValuedInterval`1.#ctor(System.Double,System.Boolean,System.Double,System.Boolean,`0)">
            <summary>Интервал</summary>
            <param name="Min">Нижняя граница интервала</param>
            <param name="MinInclude">Включена ли нижняя граница интервала?</param>
            <param name="Max">Верхняя граница интервала</param>
            <param name="MaxInclude">Включена ли верхняя граница интервала</param>
            <param name="Value">Значение</param>
        </member>
        <member name="M:MathCore.ValuedInterval`1.Check(System.Double)">
            <summary>Проверка на вхождение значения в интервал</summary>
            <param name="value">Проверяемое значение</param>
            <returns>Истина, если значение входит в интервал</returns>
        </member>
        <member name="M:MathCore.ValuedInterval`1.CompareTo(System.Double)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ValuedInterval`1.ToString(System.String,System.IFormatProvider)">
            <summary>Форматирует значение текущего экземпляра с использованием заданного формата.</summary>
            <returns>Объект <see cref="T:System.String"/> содержит значение текущего экземпляра в заданном формате.</returns>
            <param name="Format">
            Объект <see cref="T:System.String"/>, задающий используемый формат.— или — 
            Значение null для использования формата по умолчанию, определенного для типа реализации 
            <see cref="T:System.IFormattable"/>. 
            </param>
            <param name="FormatProvider">
            Объект <see cref="T:System.IFormatProvider"/>, используемый для форматирования значения.— или — 
            Значение null для получения сведений о форматировании чисел на основе текущего значения параметра языкового 
            стандарта операционной системы. 
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:MathCore.Values.AbstractSetOf`1">
            <summary>Абстрактное множество элементов</summary>
            <typeparam name="T">Тип элементов множества</typeparam>
        </member>
        <member name="P:MathCore.Values.AbstractSetOf`1.Power">
            <summary>Мощность множества</summary>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.Add(`0)">
            <summary>Добавить элемент в множество</summary>
            <param name="Value">Добавляемый элемент</param>
            <returns>Истина, если элемент был добавлен в множество и ложь, если элемент уже присутствует в множестве</returns>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.Contains(`0)">
            <summary>Признак вхождения элемента в множество</summary>
            <param name="value">Проверяемый элемент</param>
            <returns>Истина, если элемент принадлежит множеству</returns>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.NotContains(`0)">
            <summary>Признак того, что элемент не входит в множество</summary>
            <param name="value">Проверяемый элемент</param>
            <returns>Истина, если элемент не принадлежит множеству</returns>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.GetEnumerator">
            <summary>Получить перечислитель множества</summary>
            <returns>Перечислитель множества</returns>
        </member>
        <member name="M:MathCore.Values.AbstractSetOf`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель множества</summary>
            <returns>Перечислитель множества</returns>
        </member>
        <member name="T:MathCore.Values.AverageExpValue">
            <summary>Экспоненциальное скользящее среднее y = (a * x) + (1-a) * y</summary>
        </member>
        <member name="F:MathCore.Values.AverageExpValue._N">
            <summary>Номер итерации усреднения</summary>
        </member>
        <member name="F:MathCore.Values.AverageExpValue._Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="F:MathCore.Values.AverageExpValue._StartValue">
            <summary>Начальное значение</summary>
        </member>
        <member name="F:MathCore.Values.AverageExpValue._Factor">
            <summary>Сглаживающий фактор</summary>
        </member>
        <member name="P:MathCore.Values.AverageExpValue.StartValue">
            <summary>Начальное значение</summary>
        </member>
        <member name="P:MathCore.Values.AverageExpValue.Factor">
            <summary>Сглаживающий фактор</summary>
        </member>
        <member name="P:MathCore.Values.AverageExpValue.Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="P:MathCore.Values.AverageExpValue.Dispersion">
            <summary>Дисперсия значений</summary>
        </member>
        <member name="P:MathCore.Values.AverageExpValue.ValuesCount">
            <summary>Количество точек усреднения</summary>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.#ctor(System.Double)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="Factor">Сглаживающий фактор</param>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового скользящего среднего</summary>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.AddValue(System.Double)">
            <summary>Добавить значение к усреднению</summary>
            <param name="value">Добавляемое значение</param>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.Reset">
            <summary>Сбросить состояние</summary>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.ToString(System.String)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Формат</param>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.op_Implicit(MathCore.Values.AverageExpValue)~System.Double">
            <summary>Оператор неявного приведения к типу вещественного числа</summary>
            <param name="Value">Усредняемое значение</param>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.op_Implicit(System.Double)~MathCore.Values.AverageExpValue">
            <summary>Оператор неявного приведения вещественного числа к скользящему среднему</summary>
            <param name="Data">Вещественное число</param>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Новая усредняемая величина</summary>
            <param name="info">Сериализационная информация</param>
            <param name="context">Контекст сериализации</param>
        </member>
        <member name="M:MathCore.Values.AverageExpValue.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.AverageExpValue.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Получить состояние объекта</summary>
            <param name="info">Объект сериализации</param>
            <param name="context">Контекст операции сериализации</param>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="info"/> is null</exception>
        </member>
        <member name="T:MathCore.Values.AverageValue">
            <summary>Скользящее среднее</summary>
        </member>
        <member name="F:MathCore.Values.AverageValue._N">
            <summary>Номер итерации усреднения</summary>
        </member>
        <member name="F:MathCore.Values.AverageValue._Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="F:MathCore.Values.AverageValue._StartValue">
            <summary>Начальное значение</summary>
        </member>
        <member name="F:MathCore.Values.AverageValue._Length">
            <summary>Размер окна усреднения</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.StartValue">
            <summary>Начальное значение</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.Length">
            <summary>Размер окна усреднения</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.Value">
            <summary>Текущее значение усредняемой величины</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.Dispersion">
            <summary>Дисперсия значений</summary>
        </member>
        <member name="P:MathCore.Values.AverageValue.ValuesCount">
            <summary>Количество точек усреднения</summary>
        </member>
        <member name="M:MathCore.Values.AverageValue.#ctor(System.Int32)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="Length">Размер окна усреднения</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.#ctor(System.Double)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="StartValue">Начальное значение для усреднения</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.#ctor(System.Double,System.Int32)">
            <summary>Инициализация нового скользящего среднего</summary>
            <param name="StartValue">Начальное значение</param>
            <param name="Length">Размер окна усреднения</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.AddValue(System.Double)">
            <summary>Добавить значение к усреднению</summary>
            <param name="value">Добавляемое значение</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.Reset">
            <summary>Сбросить состояние</summary>
        </member>
        <member name="M:MathCore.Values.AverageValue.ToString">
            <summary>Преобразование в строку</summary>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathCore.Values.AverageValue.ToString(System.String)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Формат</param>
            <returns>Текстовое представление</returns>
        </member>
        <member name="M:MathCore.Values.AverageValue.op_Implicit(MathCore.Values.AverageValue)~System.Double">
            <summary>Оператор неявного приведения к типу вещественного числа</summary>
            <param name="Value">Усредняемое значение</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.op_Implicit(System.Double)~MathCore.Values.AverageValue">
            <summary>Оператор неявного приведения вещественного числа к скользящему среднему</summary>
            <param name="Data">Вещественное число</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Новая усредняемая величина</summary>
            <param name="info">Сериализационная информация</param>
            <param name="context">Контекст сериализации</param>
        </member>
        <member name="M:MathCore.Values.AverageValue.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.AverageValue.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Получить состояние объекта</summary>
            <param name="info">Объект сериализации</param>
            <param name="context">Контекст операции сериализации</param>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="info"/> is null</exception>
        </member>
        <member name="T:MathCore.Values.CSV">
            <summary>Файл текстовых данных, разделённых запятой</summary>
        </member>
        <member name="T:MathCore.Values.CSV.Item">
            <summary>Элемент данных</summary>
        </member>
        <member name="P:MathCore.Values.CSV.Item.FileStartPos">
            <summary>Начальное положение</summary>
        </member>
        <member name="P:MathCore.Values.CSV.Item.FileEndPos">
            <summary>Конечное положение в файле</summary>
        </member>
        <member name="F:MathCore.Values.CSV.Item._Header">
            <summary>Элементы заголовка</summary>
        </member>
        <member name="F:MathCore.Values.CSV.Item._Items">
            <summary>Элементы данных</summary>
        </member>
        <member name="P:MathCore.Values.CSV.Item.Item(System.Int32)">
            <summary>Требуемый элемент данных по указанному индексу</summary>
            <param name="index">Индекс элемента данных</param>
            <returns>Элемент данных по указанному индексу</returns>
        </member>
        <member name="P:MathCore.Values.CSV.Item.Item(System.String)">
            <summary>Требуемый элемент данных по указанному имени заголовка столбца</summary>
            <param name="key">Имя столбца заголовка</param>
            <returns>Требуемый элемент данных</returns>
        </member>
        <member name="P:MathCore.Values.CSV.Item.ItemsCount">
            <summary>Количество элементов данных</summary>
        </member>
        <member name="M:MathCore.Values.CSV.Item.#ctor(System.String[],System.String[],System.Int64,System.Int64)">
            <summary>Новый элемент данных</summary>
            <param name="Header">Названия столбцов</param>
            <param name="Items">Элементы данных</param>
            <param name="FileStartPos">Начальное положение</param>
            <param name="FileEndPos">Конечное положение в файле</param>
        </member>
        <member name="M:MathCore.Values.CSV.Item.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.CSV.Item.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.CSV.Item.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="F:MathCore.Values.CSV._FileName">
            <summary>Имя файла</summary>
        </member>
        <member name="F:MathCore.Values.CSV._Separator">
            <summary>Символ-разделитель</summary>
        </member>
        <member name="F:MathCore.Values.CSV._SkipFirstLines">
            <summary>Количество пропускаемых первых строк файла</summary>
        </member>
        <member name="F:MathCore.Values.CSV._HeaderLine">
            <summary>Считывать строку заголовков</summary>
        </member>
        <member name="F:MathCore.Values.CSV._SkipEmptyLines">
            <summary>Пропускать пустые строки</summary>
        </member>
        <member name="F:MathCore.Values.CSV._Encoding">
            <summary>Кодировка файла</summary>
        </member>
        <member name="M:MathCore.Values.CSV.#ctor(System.String,System.Char,System.Int32,System.Boolean,System.Boolean,System.Text.Encoding)">
            <summary>Новый файл данных, разделённых запятой</summary>
            <param name="FileName">Имя файла данных</param>
            <param name="Separator">Символ-разделитель</param>
            <param name="SkipFirstLines">Количество пропускаемых строк в начале файла</param>
            <param name="HeaderLine">Считывать ли заголовок</param>
            <param name="SkipEmptyLines">Пропускать пустые строки</param>
            <param name="Encoding">Кодировка файла (если не указана, используется <see cref="P:System.Text.Encoding.UTF8"/>)</param>
        </member>
        <member name="M:MathCore.Values.CSV.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.CSV.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.Goertzel">
            <summary>Алгоритм Гёрцеля расчёта частотной компоненты спектра</summary>
        </member>
        <member name="F:MathCore.Values.Goertzel._W">
            <summary>Поворачивающий множитель</summary>
        </member>
        <member name="F:MathCore.Values.Goertzel._s1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="F:MathCore.Values.Goertzel._s2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.Goertzel.State1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="P:MathCore.Values.Goertzel.State2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.Goertzel.State">
            <summary>Текущее значение частотной компоненты спектра</summary>
        </member>
        <member name="M:MathCore.Values.Goertzel.Reset">
            <summary>Сброс состояния фильтра</summary>
        </member>
        <member name="M:MathCore.Values.Goertzel.Add(System.Double)">
            <summary>Добавление нового значения</summary>
            <param name="x">Добавляемое значение</param>
            <returns>Текущее значение частотной компоненты</returns>
        </member>
        <member name="T:MathCore.Values.GoertzelComplex">
            <summary>Комплексный Алгоритм Гёрцеля расчёта частотной компоненты спектра</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelComplex._W">
            <summary>Поворачивающий множитель</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelComplex._s1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelComplex._s2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelComplex.State1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelComplex.State2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelComplex.State">
            <summary>Текущее значение частотной компоненты спектра</summary>
        </member>
        <member name="M:MathCore.Values.GoertzelComplex.Reset">
            <summary>Сброс состояния фильтра</summary>
        </member>
        <member name="M:MathCore.Values.GoertzelComplex.Add(MathCore.Complex)">
            <summary>Добавление нового значения</summary>
            <param name="x">Добавляемое значение</param>
            <returns>Текущее значение частотной компоненты</returns>
        </member>
        <member name="T:MathCore.Values.GoertzelStruct">
            <summary>Алгоритм Гёрцеля расчёта частотной компоненты спектра</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelStruct._W">
            <summary>Поворачивающий множитель</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelStruct._s1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelStruct._s2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelStruct.State1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelStruct.State2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelStruct.State">
            <summary>Текущее значение частотной компоненты спектра</summary>
        </member>
        <member name="M:MathCore.Values.GoertzelStruct.Add(System.Double)">
            <summary>Добавление нового значения</summary>
            <param name="x">Добавляемое значение</param>
            <returns>Текущее значение частотной компоненты</returns>
        </member>
        <member name="T:MathCore.Values.GoertzelComplexStruct">
            <summary>Алгоритм Гёрцеля расчёта частотной компоненты спектра</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelComplexStruct._W">
            <summary>Поворачивающий множитель</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelComplexStruct._s1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelComplexStruct._s2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelComplexStruct.State1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelComplexStruct.State2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelComplexStruct.State">
            <summary>Текущее значение частотной компоненты спектра</summary>
        </member>
        <member name="M:MathCore.Values.GoertzelComplexStruct.Add(MathCore.Complex)">
            <summary>Добавление нового значения</summary>
            <param name="x">Добавляемое значение</param>
            <returns>Текущее значение частотной компоненты</returns>
        </member>
        <member name="F:MathCore.Values.GoertzelVector._W">
            <summary>Поворачивающий множитель</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelVector._s1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="F:MathCore.Values.GoertzelVector._s2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelVector.State1">
            <summary>Предыдущее состояние алгоритма</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelVector.State2">
            <summary>Состояние алгоритма два шага назад</summary>
        </member>
        <member name="P:MathCore.Values.GoertzelVector.State">
            <summary>Текущее значение частотной компоненты спектра</summary>
        </member>
        <member name="M:MathCore.Values.GoertzelVector.Reset">
            <summary>Сброс состояния фильтра</summary>
        </member>
        <member name="M:MathCore.Values.GoertzelVector.Add(System.Double)">
            <summary>Добавление нового значения</summary>
            <param name="x">Добавляемое значение</param>
            <returns>Текущее значение частотной компоненты</returns>
        </member>
        <member name="T:MathCore.Values.IResettable">
            <summary>Объект, позволяющий осуществлять сброс своего состояния</summary>
        </member>
        <member name="M:MathCore.Values.IResettable.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="T:MathCore.Values.IValue`1">
            <summary>Объект, позволяющий читать и устанавливать значение</summary>
            <typeparam name="T">Тип значения объекта</typeparam>
        </member>
        <member name="P:MathCore.Values.IValue`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathCore.Values.IValueRead`1">
            <summary>Объект, обладающий значением</summary>
            <typeparam name="T">Тип значения объекта</typeparam>
        </member>
        <member name="P:MathCore.Values.IValueRead`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathCore.Values.IValueWrite`1">
            <summary>Объект, позволяющий определять значение</summary>
            <typeparam name="T">Тип значений объекта</typeparam>
        </member>
        <member name="P:MathCore.Values.IValueWrite`1.Value">
            <summary>Значение объекта</summary>
        </member>
        <member name="T:MathCore.Values.LazyValue`1">
            <summary>"Ленивое" значение</summary>
            <typeparam name="T">Тип значения</typeparam>
        </member>
        <member name="F:MathCore.Values.LazyValue`1._Initializator">
            <summary>Инициализатор значения</summary>
        </member>
        <member name="F:MathCore.Values.LazyValue`1._Value">
            <summary>Значение</summary>
        </member>
        <member name="F:MathCore.Values.LazyValue`1._LockObject">
            <summary>Объект кросспоточной блокировки</summary>
        </member>
        <member name="F:MathCore.Values.LazyValue`1._Initialized">
            <summary>Флаг инициализации</summary>
        </member>
        <member name="P:MathCore.Values.LazyValue`1.Initialized">
            <summary>Признак инициализации</summary>
        </member>
        <member name="P:MathCore.Values.LazyValue`1.Value">
            <summary>Значение</summary>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.#ctor(System.Func{`0})">
            <summary>Создание нового "ленивого" значения</summary>
            <param name="Initializer">Инициализатор значения</param>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.Initialize(System.Func{`0})">
            <summary>Инициализация "ленивого" значения</summary>
            <param name="Initializer">Инициализатор</param>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.System#IInitializable#Initialize">
            <summary>Вызов метода инициализации для интерфейса <see cref="T:System.IInitializable"/></summary>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.op_Implicit(MathCore.Values.LazyValue{`0})~`0">
            <summary>Оператор неявного преобразования "ленивого" значения в обычное</summary>
            <param name="value">"Ленивое" значение</param>
            <returns>Обычное значение, получаемое при вычислении "ленивого" значения</returns>
        </member>
        <member name="M:MathCore.Values.LazyValue`1.op_Implicit(System.Func{`0})~MathCore.Values.LazyValue{`0}">
            <summary>Оператор неявного преобразования метода инициализации в "ленивое значение"</summary>
            <param name="Initializer">Метод инициализации "ленивого" значения</param>
            <returns>"Ленивое" значение с указанным методом инициализации</returns>
        </member>
        <member name="T:MathCore.Values.LinearQueue`1">
            <summary>Очередь с линейным доступом</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
        </member>
        <member name="T:MathCore.Values.MaxValue">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MaxValue.Value">
            <summary>Минимальное значение</summary>
        </member>
        <member name="M:MathCore.Values.MaxValue.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.MaxValue"/></summary>
        </member>
        <member name="M:MathCore.Values.MaxValue.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.MaxValue"/></summary>
            <param name="StartValue">Начальное значение</param>
        </member>
        <member name="M:MathCore.Values.MaxValue.Add(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Максимальное значение из всех добавленных</returns>
        </member>
        <member name="M:MathCore.Values.MaxValue.AddValue(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Истина, если добавляемое значение является максимальным</returns>
        </member>
        <member name="M:MathCore.Values.MaxValue.Reset">
            <summary>Сбросить состояние минимального значения</summary>
        </member>
        <member name="M:MathCore.Values.MaxValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MaxValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MaxValue.ToString(System.String)">
            <summary>Возвращает форматированную строку значения </summary>
            <param name="FormatString">Формат значения</param>
            <returns>Форматированная строка значения</returns>
        </member>
        <member name="M:MathCore.Values.MaxValue.op_Implicit(MathCore.Values.MaxValue)~System.Double">
            <summary>Оператор неявного приведения типа <see cref="T:MathCore.Values.MaxValue"/> к <see cref="T:System.Double"/></summary>
            <param name="MaxValue">Максимальное значение значение</param>
        </member>
        <member name="T:MathCore.Values.MinMaxValue">
            <summary>Объект, отслеживающий минимальное и максимальное значение входящей величины</summary>
        </member>
        <member name="F:MathCore.Values.MinMaxValue._Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="F:MathCore.Values.MinMaxValue._Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MinMaxValue.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MinMaxValue.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MinMaxValue.Interval">
            <summary>Интервал значений</summary>
        </member>
        <member name="M:MathCore.Values.MinMaxValue.Reset">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MinMaxValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MinMaxValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.MinValue">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:MathCore.Values.MinValue.Value">
            <summary>Минимальное значение</summary>
        </member>
        <member name="M:MathCore.Values.MinValue.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.MinValue"/></summary>
        </member>
        <member name="M:MathCore.Values.MinValue.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.MinValue"/></summary>
            <param name="StartValue">Начальное значение</param>
        </member>
        <member name="M:MathCore.Values.MinValue.Add(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Минимальный элемент из всех добавленных</returns>
        </member>
        <member name="M:MathCore.Values.MinValue.AddValue(System.Double)">
            <summary>Добавить новое значение</summary>
            <param name="value">Добавляемое значение</param>
            <returns>Истина, если добавляемое значение является минимальным</returns>
        </member>
        <member name="M:MathCore.Values.MinValue.Reset">
            <summary>Сбросить состояние минимального значения</summary>
        </member>
        <member name="M:MathCore.Values.MinValue.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MinValue.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.MinValue.ToString(System.String)">
            <summary>Возвращает форматированную строку значения </summary>
            <param name="FormatString">Формат значения</param>
            <returns>Форматированная строка значения</returns>
        </member>
        <member name="M:MathCore.Values.MinValue.op_Implicit(MathCore.Values.MinValue)~System.Double">
            <summary>Оператор неявного приведения типа <see cref="T:MathCore.Values.MinValue"/> к <see cref="T:System.Double"/></summary>
            <param name="MinValue">Минимальное значение</param>
        </member>
        <member name="M:MathCore.Values.NumberedValues`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.ObjectSelector`1">
            <summary>Система псевдопараллельного потокового доступа к значению ряда источников объектов</summary>
            <typeparam name="T">Тип объектов в источниках</typeparam>
            <example>
            Примером использования может быть способ последовательного выбора данных из ряда потоков чтения 
            с выбором последовательности данных, выводимых в общий поток.
            void Test()
            {
               //Используем уничтожаемую группу объектов
              using(var readers = new DisposableGroup&lt;StreamReader&gt;(//Объекты чтения из потока
                      Directory.GetFiles(@"c:\", "*.txt").Select(f => new StreamReader(f))))  //для всех файлов C:\*.txt
              {
                var rnd = new Random();                                         //Генератор случайных чисел
                var o_selector = new ObjectSelector&lt;string&gt;(                     //Создаём объект выбора строк
                            SS => rnd.Next(readers.Count),                      //Очередная строка из случайного файла
                            () => readers.All(r => !r.EndOfStream),             //Признак возможности чтения - ни один из потоков не закончен
                            readers.Select(r => (Func&lt;string&gt;)(r.ReadLine)));   //Инициализатор - метод, возвращающий строку из файла
                while(o_selector.CanRead) Console.Write(o_selector.Value);        //Читаем всё построчно в консоль
              }
            }
            </example>
        </member>
        <member name="F:MathCore.Values.ObjectSelector`1._Selector">
            <summary>Метод выбора одного из значений ряда источников объектов</summary>
        </member>
        <member name="F:MathCore.Values.ObjectSelector`1._Values">
            <summary>Массив "ленивых" значений, используемых в качестве генераторов объектов </summary>
        </member>
        <member name="F:MathCore.Values.ObjectSelector`1._CanRead">
            <summary>Метод, определяющий возможность чтения данных из источников</summary>
        </member>
        <member name="P:MathCore.Values.ObjectSelector`1.Value">
            <summary>Очередное значение из вектора генераторов значений</summary>
        </member>
        <member name="P:MathCore.Values.ObjectSelector`1.CanRead">
            <summary>Признак возможности чтения объекта</summary>
        </member>
        <member name="M:MathCore.Values.ObjectSelector`1.#ctor(System.Func{`0[],System.Int32},System.Func{System.Boolean},System.Func{`0}[])">
            <summary>Новый генератор последовательности объектов из источника параллельных значений</summary>
            <param name="Selector">Метод выбора значения</param>
            <param name="CanRead">Метод определения возможности чтения значения</param>
            <param name="Generator">Массив генераторов объектов "ленивых" значений</param>
        </member>
        <member name="M:MathCore.Values.ObjectSelector`1.#ctor(System.Func{`0[],System.Int32},System.Func{System.Boolean},System.Collections.Generic.IEnumerable{System.Func{`0}})">
            <summary>Новый генератор последовательности объектов из источника параллельных значений</summary>
            <param name="Selector">Метод выбора значения</param>
            <param name="CanRead">Метод определения возможности чтения значения</param>
            <param name="GeneratorsEnum">Массив генераторов объектов "ленивых" значений</param>
        </member>
        <member name="T:MathCore.Values.Set`1">
            <summary>Множество элементов</summary>
            <typeparam name="T">Тип данных множества</typeparam>
        </member>
        <member name="P:MathCore.Values.Set`1.Power">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.Set`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.Set`1"/></summary>
        </member>
        <member name="M:MathCore.Values.Set`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.Set`1"/></summary>
            <param name="comparer">Объект, осуществляющий сравнение элементов множества</param>
        </member>
        <member name="M:MathCore.Values.Set`1.Add(`0)">
            <summary>Добавить элемент в множество</summary>
            <param name="Value">Добавляемый элемент</param>
            <returns>Истина, если элемент был успешно добавлен и ложь, если элемент уже присутствует в множестве</returns>
        </member>
        <member name="M:MathCore.Values.Set`1.Contains(`0)">
            <summary>Проверка на вхождение элемента в множество</summary>
            <param name="Value">Проверяемый элемент</param>
            <returns>Истина, если элемент входит в множество</returns>
        </member>
        <member name="M:MathCore.Values.Set`1.Add(`0,System.Int32)">
            <summary>Добавить элемент в множество</summary>
            <param name="Value">Добавляемый элемент</param>
            <param name="Hash">Хеш-код элемента</param>
        </member>
        <member name="M:MathCore.Values.Set`1.Remove(`0)">
            <summary>Удаление элемента из множества</summary>
            <param name="Value">Удаляемый элемент</param>
            <returns>Истина, если элемент присутствовал в множестве и был оттуда удалён</returns>
        </member>
        <member name="M:MathCore.Values.Set`1.Resize">
            <summary>Подгон размера хранилища</summary>
        </member>
        <member name="M:MathCore.Values.Set`1.GetHashCodeOf(`0)">
            <summary>Получить хещ-код элемента</summary>
            <param name="Value">Элемент, хеш-код которого требуется получить</param>
            <returns>Рассчитанный хеш-код элемента</returns>
        </member>
        <member name="M:MathCore.Values.Set`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.SetOf`1">
            <summary>Множество объектов типа <typeparamref name="T"/></summary>
            <typeparam name="T">Тип элементов множества</typeparam>
            <summary>Множество</summary>
            <typeparam name="T">Тип элементов множества</typeparam>
        </member>
        <member name="P:MathCore.Values.SetOf`1.Mixed">
            <summary>Перемешивать содержимое при выдаче массива элементов</summary>
        </member>
        <member name="F:MathCore.Values.SetOf`1._List">
            <summary>Список элементов</summary>
        </member>
        <member name="P:MathCore.Values.SetOf`1.Power">
            <summary>Мощность множества</summary>
        </member>
        <member name="M:MathCore.Values.SetOf`1.#ctor">
            <summary>Новое множество элементов</summary>
        </member>
        <member name="M:MathCore.Values.SetOf`1.#ctor(System.Int32)">
            <summary>Новое множество элементов</summary>
            <param name="Capacity">Ёмкость множества</param>
        </member>
        <member name="M:MathCore.Values.SetOf`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Новое множество элементов</summary>
            <param name="collection">Коллекция элементов</param>
        </member>
        <member name="M:MathCore.Values.SetOf`1.#ctor(`0[])">
            <summary>Новое множество элементов</summary>
            <param name="element">Элементы множества</param>
        </member>
        <member name="M:MathCore.Values.SetOf`1.ToList">
            <summary>Преобразование в список</summary>
            <returns>Список элементов</returns>
        </member>
        <member name="M:MathCore.Values.SetOf`1.ToArray">
            <summary>Преобразование множества элементов в массив</summary>
            <returns>Массив элементов</returns>
        </member>
        <member name="M:MathCore.Values.SetOf`1.Clone">
            <summary>Клонирование множества элементов</summary>
            <returns></returns>
        </member>
        <member name="M:MathCore.Values.SetOf`1.Equals(MathCore.Values.SetOf{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.GetEnumerator">
            <summary>Возвращает перечислитель, выполняющий перебор элементов в коллекции.</summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MathCore.Values.SetOf`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Возвращает перечислитель, который осуществляет перебор элементов коллекции.</summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MathCore.Values.SetOf`1.Add(`0)">
            <summary>Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:MathCore.Values.SetOf`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.Contains(`0)">
            <inheritdoc cref="T:System.Collections.Generic.ICollection`1" />
        </member>
        <member name="M:MathCore.Values.SetOf`1.System#Collections#Generic#ICollection{T}#CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Values.SetOf`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Values.SetOf`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc />
        </member>
        <member name="P:MathCore.Values.SetOf`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.StatisticValue">
            <summary>Статистическая информация о значении</summary>
        </member>
        <member name="F:MathCore.Values.StatisticValue._Average">
            <summary>Среднее значение</summary>
        </member>
        <member name="F:MathCore.Values.StatisticValue._Average2">
            <summary>Среднее значение квадрата величины</summary>
        </member>
        <member name="F:MathCore.Values.StatisticValue._MinMax">
            <summary>Диапазон значений</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.M">
            <summary>Математическое ожидание величины</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.D">
            <summary>Дисперсия</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.Sigma">
            <summary>Среднеквадратичное отклонение</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.MinMax">
            <summary>Интервал значений, в который попадает величина</summary>
        </member>
        <member name="P:MathCore.Values.StatisticValue.Count">
            <summary>Размер выборки</summary>
        </member>
        <member name="M:MathCore.Values.StatisticValue.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Values.StatisticValue"/></summary>
            <param name="Length">Требуемый размер выборки</param>
        </member>
        <member name="M:MathCore.Values.StatisticValue.AddValue(System.Double)">
            <summary>Добавить значение к оценке статистики</summary>
            <param name="x">Добавляемое значение</param>
        </member>
        <member name="M:MathCore.Values.StatisticValue.AddEnumerable(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Добавить перечисление объектов к оценке статистики</summary>
            <param name="collection">Добавляемая последовательность значений</param>
        </member>
        <member name="M:MathCore.Values.StatisticValue.Reset">
            <summary>Сбросить состояние оценки</summary>
        </member>
        <member name="M:MathCore.Values.StatisticValue.ToString">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Values.StreamDataSpeedValue">
            <summary>Измеритель скорости потока данных</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue.__DataNames">
            <summary>Названия скоростей</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.Now">
            <summary>Текущее время</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._AverageValue">
            <summary>Значение, усреднённое во времени</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._DataStream">
            <summary>Поток данных</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._LastPosition">
            <summary>Последнее положение в потоке денных</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._LastTime">
            <summary>Последнее время</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._Round">
            <summary>Количество знаков после запятой в строковом представлении</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._LastSpeedValue">
            <summary>Последнее зафиксированное значение скорости</summary>
        </member>
        <member name="F:MathCore.Values.StreamDataSpeedValue._SpeedCheckTimeout">
            <summary>Минимально допустимый интервал времени в секундах для проверки значения скорости</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.Round">
            <summary>Количество знаков после запятой в строковом представлении</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.Value">
            <summary>Мгновенное значение скорости</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.AverageValue">
            <summary>Усреднённое значение скорости</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.SpeedStr">
            <summary>Строковое представление скорости</summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.AverageTau">
            <summary>Постоянная времени усреднения </summary>
        </member>
        <member name="P:MathCore.Values.StreamDataSpeedValue.SpeedCheckTimeout">
            <summary>Минимально допустимый интервал времени проверки скорости</summary>
        </member>
        <member name="M:MathCore.Values.StreamDataSpeedValue.#ctor(System.IO.Stream)">
            <summary>Новый измеритель скорости потока данных</summary>
            <param name="DataStream">Поток данных для измерения</param>
            <exception cref="T:System.ArgumentNullException">Исключение возникает при нулевой ссылке на поток данных</exception>
        </member>
        <member name="M:MathCore.Values.StreamDataSpeedValue.Reset">
            <summary>Сброс измерителя: установка стартового значения положения в потоке, сброс усреднителя</summary>
        </member>
        <member name="M:MathCore.Values.StreamDataSpeedValue.CheckSpeed">
            <summary>Получить измерение скорости</summary>
            <returns>Мгновенная измеренная скорость перемещения в потоке</returns>
        </member>
        <member name="M:MathCore.Values.StreamDataSpeedValue.op_Implicit(MathCore.Values.StreamDataSpeedValue)~System.Double">
            <summary>Неявное преобразование измерителя скорости к значению скорости (усреднённому)</summary>
            <param name="speed">Измеритель скорости</param>
            <returns>Значение скорости</returns>
        </member>
        <member name="M:MathCore.Values.TimeAverage2Value.Add(System.Double)">
            <summary>Добавить значение</summary><param name="value">Значение</param>
        </member>
        <member name="T:MathCore.Values.TimeAverageValue">
            <summary>Усредняемая по времени величина</summary>
        </member>
        <member name="F:MathCore.Values.TimeAverageValue._LastTime">
            <summary>Последнее время доступа</summary>
        </member>
        <member name="F:MathCore.Values.TimeAverageValue._Tau">
            <summary>Постоянная времени усреднения</summary>
        </member>
        <member name="P:MathCore.Values.TimeAverageValue.Tau">
            <summary>Постоянная времени</summary>
        </member>
        <member name="P:MathCore.Values.TimeAverageValue.Value">
            <summary>Значение</summary>
        </member>
        <member name="P:MathCore.Values.TimeAverageValue.Initialized">
            <summary>Признак инициализации</summary>
        </member>
        <member name="M:MathCore.Values.TimeAverageValue.#ctor(System.Double)">
            <summary>Усредняемая по времени величина</summary>
            <param name="tau">Постоянная времени усреднения >= 0</param>
        </member>
        <member name="M:MathCore.Values.TimeAverageValue.#ctor(System.Double,System.Double)">
            <summary>Усредняемая по времени величина</summary>
            <param name="Value">Начальное значение</param><param name="tau">постоянная времени >= 0</param>
        </member>
        <member name="M:MathCore.Values.TimeAverageValue.Add(System.Double)">
            <summary>Добавить значение</summary>
            <param name="value">Значение</param>
        </member>
        <member name="M:MathCore.Values.TimeAverageValue.Reset">
            <summary>Сброс состояния</summary>
        </member>
        <member name="T:MathCore.Vectors.Basis2D">
            <summary>Двумерный базис</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis2D.Euclid">
            <summary>Базис Евклидова пространства</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.Rotate(System.Double,System.Boolean)">
            <summary>Базис поворота вектора на заданный угол</summary>
            <param name="Angle">Угол поворота пространства</param>
            <param name="Positive">Направление поворота по часовой стрелке</param>
            <returns>Базис, осуществляющий поворот вектора в пространстве на указанный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.Scale(System.Double,System.Double)">
            <summary>Базис масштабирования вектора по осям</summary>
            <param name="kx">Коэффициент масштабирования вдоль оси OX</param>
            <param name="ky">Коэффициент масштабирования вдоль оси OY</param>
            <returns>Базис, осуществляющий масштабирования вектора по осям</returns>
        </member>
        <member name="F:MathCore.Vectors.Basis2D._xx">
            <summary>Элемент X[0,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis2D.xx">
            <summary>Элемент X[0,0]</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis2D._xy">
            <summary>Элемент X[0,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis2D.xy">
            <summary>Элемент X[0,1]</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis2D._yx">
            <summary>Элемент X[1,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis2D.yx">
            <summary>Элемент X[1,0]</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis2D._yy">
            <summary>Элемент X[1,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis2D.yy">
            <summary>Элемент X[1,1]</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.Basis2D"/></summary>
            <param name="xx">Элемент X[0,0]</param>
            <param name="xy">Элемент X[0,1]</param>
            <param name="yx">Элемент X[1,0]</param>
            <param name="yy">Элемент X[1,1]</param>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.op_Implicit(MathCore.Vectors.Basis2D@)~MathCore.Matrix">
            <summary>Оператор неявного преобразования базиса в матрицу 2х2</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.op_Explicit(MathCore.Matrix@)~MathCore.Vectors.Basis2D">
            <summary>Оператор явного преобразования матрицы 2х2 в двумерный базис</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.Equals(MathCore.Vectors.Basis2D)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis2D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis2D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis2D.op_Equality(MathCore.Vectors.Basis2D,MathCore.Vectors.Basis2D)">
            <summary>Оператор равенства двух базисов</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis2D.op_Inequality(MathCore.Vectors.Basis2D,MathCore.Vectors.Basis2D)">
            <summary>Оператор неравенства двух базисов</summary>
        </member>
        <member name="T:MathCore.Vectors.Basis3D">
            <summary>Базис трёхмерного пространства</summary>
        </member>
        <member name="F:MathCore.Vectors.Basis3D.Euclid">
            <summary>Базис Евклидова пространства</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Scale(System.Double,System.Double,System.Double)">
            <summary>Базис масштабирования по осям</summary>
            <param name="kx">Коэффициент масштабирования вдоль оси OX</param>
            <param name="ky">Коэффициент масштабирования вдоль оси OY</param>
            <param name="kz">Коэффициент масштабирования вдоль оси OZ</param>
            <returns>Базис масштабирования вдоль основных осей</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.RotateOX(System.Double,System.Boolean)">
            <summary>Базис поворота вокруг оси OX</summary>
            <param name="Angle">Угол поворота</param>
            <param name="Positive">Направление - по часовой стрелке</param>
            <returns>Базис поворота вокруг оси OX</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.RotateOY(System.Double,System.Boolean)">
            <summary>Базис поворота вокруг оси OY</summary>
            <param name="Angle">Угол поворота</param>
            <param name="Positive">Направление - по часовой стрелке</param>
            <returns>Базис поворота вокруг оси OY</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.RotateOZ(System.Double,System.Boolean)">
            <summary>Базис поворота вокруг оси OZ</summary>
            <param name="Angle">Угол поворота</param>
            <param name="Positive">Направление - по часовой стрелке</param>
            <returns>Базис поворота вокруг оси OZ</returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Rotate(System.Double,System.Double,System.Double)">
            <summary>Базис поворота на углы Эйлера</summary>
            <param name="alpha">Угол поворота вокруг оси OX</param>
            <param name="beta">Угол поворота вокруг оси OY</param>
            <param name="gamma">Угол поворота вокруг оси OZ</param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Rotate(MathCore.Vectors.Vector3D@,System.Double)">
            <summary>Базис сдвига и поворота на заданный угол</summary>
            <param name="v">Вектор сдвига</param>
            <param name="theta">Угол места поворота</param>
            <returns>Базис сдвига и поворота</returns>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.xx">
            <summary>Элемент [0,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.xy">
            <summary>Элемент [0,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.xz">
            <summary>Элемент [0,2]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.yx">
            <summary>Элемент [1,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.yy">
            <summary>Элемент [1,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.yz">
            <summary>Элемент [1,2]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.zx">
            <summary>Элемент [2,0]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.zy">
            <summary>Элемент [2,1]</summary>
        </member>
        <member name="P:MathCore.Vectors.Basis3D.zz">
            <summary>Элемент [2,2]</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.Basis3D"/></summary>
            <param name="xx">Элемент X[0,0]</param>
            <param name="xy">Элемент X[0,1]</param>
            <param name="xz">Элемент X[0,2]</param>
            <param name="yx">Элемент X[1,0]</param>
            <param name="yy">Элемент X[1,1]</param>
            <param name="yz">Элемент X[1,2]</param>
            <param name="zx">Элемент X[2,0]</param>
            <param name="zy">Элемент X[2,1]</param>
            <param name="zz">Элемент X[2,2]</param>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.op_Implicit(MathCore.Vectors.Basis3D@)~MathCore.Matrix">
            <summary>Оператор неявного преобразования базиса в матрицу 3х3</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.op_Explicit(MathCore.Matrix)~MathCore.Vectors.Basis3D">
            <summary>Оператор явного преобразования матрицы 2х2 в двумерный базис</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Equals(MathCore.Vectors.Basis3D)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis3D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis3D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Basis3D.op_Equality(MathCore.Vectors.Basis3D,MathCore.Vectors.Basis3D)">
            <summary>Оператор равенства двух базисов</summary>
        </member>
        <member name="M:MathCore.Vectors.Basis3D.op_Inequality(MathCore.Vectors.Basis3D,MathCore.Vectors.Basis3D)">
            <summary>Оператор неравенства двух базисов</summary>
        </member>
        <member name="T:MathCore.Vectors.Fields.VectorField3D">
            <summary>Трёхмерное векторное поле</summary>
            <param name="r">Координата в пространстве</param>
            <returns>Значение вектора в точке с указанными координатами</returns>
        </member>
        <member name="T:MathCore.Vectors.Fields.VectorField3DExtensions">
            <summary>Методы-расширения над <see cref="T:MathCore.Vectors.Fields.VectorField3D"/></summary>
        </member>
        <member name="T:MathCore.Vectors.SpaceAngle">
            <summary>Пространственный угол</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.__ToDeg">
            <summary>Константа преобразования угла в радианах в градусы</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.__ToRad">
            <summary>Константа преобразования угла в градусах в радианы</summary>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.NormalizeAngle(System.Double,MathCore.AngleType@)">
            <summary>Нормализация угла</summary>
            <param name="angle">Номализуемый угол</param>
            <param name="type">Тип значения угла (градусы/радианы)</param>
            <returns>Угол, представленный в интервале от 0 до 360° (0 до 2π)</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Random(System.Double,System.Double)">
            <summary>Случайный пространственный угол</summary>
            <param name="Min">Минимальное значение угла</param>
            <param name="Max">Максимальное значение угла</param>
            <returns>Случайный пространственный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Value(System.Double,System.Double,MathCore.AngleType@)">
            <summary>Создать новый пространственный угол на основе значений углов места и азимута</summary>
            <param name="theta">Угол места</param>
            <param name="phi">Угол азимута</param>
            <param name="type">Тип значения угла</param>
            <returns>Пространственный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Direction(MathCore.Vectors.Vector3D)">
            <summary>Создать угол на основе направляющего вектора</summary>
            <param name="r">Вектор направления</param>
            <returns>Угол вектора направления</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Direction(System.Double,System.Double,System.Double)">
            <summary>Создать пространственный угол по заданным координатам вектора направления</summary>
            <returns>Угол вектора направления</returns>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.i">
            <summary>Орта оси OX</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.i_negative">
            <summary>Отрицательная орта оси OX</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.j">
            <summary>Орта оси OY</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.j_negative">
            <summary>Отрицательная орта оси OY</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.k">
            <summary>Орта оси OZ</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle.k_negative">
            <summary>Отрицательная орта оси OZ</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle._AngleType">
            <summary>Тип угла</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle._Theta">
            <summary>Угол места</summary>
        </member>
        <member name="F:MathCore.Vectors.SpaceAngle._Phi">
            <summary>Угол азимута</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.Theta">
            <summary>Угол места</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.Phi">
            <summary>Азимутальный угол в плоскости XOY</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.AngleType">
            <summary>Тип угла</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ThetaRad">
            <summary>Угол места в радианах</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ThetaDeg">
            <summary>Угол места в градусах</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.PhiRad">
            <summary>Угол азимута в радианах</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.PhiDeg">
            <summary>Угол азимута в градусах</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.IsZero">
            <summary>Являются ли значения угла места и азимута = 0?</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ComplexCosTheta">
            <summary>Комплексное число, характеризующее действительной частью направляющий косинус <see cref="P:MathCore.Vectors.SpaceAngle.Theta"/>, мнимой частью - направляющий синус</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ComplexCosPhi">
            <summary>Комплексное число, характеризующее действительной частью направляющий косинус <see cref="P:MathCore.Vectors.SpaceAngle.Phi"/>, мнимой частью - направляющий синус</summary>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.InDeg">
            <summary>Представление угла в градусах</summary>
            <exception cref="T:System.NotSupportedException" accessor="get">Неизвестный тип угла</exception>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.InRad">
            <summary>Представление угла в радианах</summary>
            <exception cref="T:System.NotSupportedException" accessor="get">Неизвестный тип угла</exception>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.DirectionalVector">
            <summary>Направляющий вектор</summary>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="Phi">Угол азимута</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(System.Double,MathCore.AngleType@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="Phi">Угол азимута</param>
            <param name="AngleType">Тип значения угла</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(System.Double,System.Double)">
            <summary>Пространственный угол в радианах</summary>
            <param name="Theta">Угол места [рад]</param>
            <param name="Phi">Азимутальный угол [рад]</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(System.Double,System.Double,MathCore.AngleType@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="Theta">Угол места</param>
            <param name="Phi">Угол азимута</param>
            <param name="AngleType">Тип значения угла</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(MathCore.Vectors.SpaceAngle)">
            <summary>Копирование нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/> из прототипа</summary>
            <param name="Angle">Исходное значение угла</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.#ctor(MathCore.Vectors.SpaceAngle,MathCore.AngleType@)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="Angle">Исходное значение угла</param>
            <param name="AngleType">Тип желаемого значения угла</param>
            <exception cref="T:System.NotSupportedException">Если AngleType != Deg || Rad - Неизвестный тип угла</exception>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.RotatePhiTheta(System.Double,System.Double,MathCore.AngleType@)">
            <summary>Повернуть угол в сферической системе координат</summary>
            <param name="theta">Угол места поворота локальной системы координат</param>
            <param name="phi">Угол азимута поворота локальной системы координат</param>
            <param name="type">Тип значений угловых величин</param>
            <returns>Угол в повёрнутой локальной системе координат</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.RotatePhiTheta(MathCore.Vectors.SpaceAngle)">
            <summary>Повернуть угол в сферической системе координат</summary>
            <param name="angle">Пространственный угол поворота локальной системы координат</param>
            <returns>Угол в повёрнутой локальной системе координат</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.GetRotatorPhiTheta">
            <summary>Получить функцию, осуществляющую поворот пространственного угла на текущий пространственный угол</summary>
            <returns>Функция, осуществляющая поворот пространственного угла на заданный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.GetRotatorPhiTheta(MathCore.Vectors.SpaceAngle)">
            <summary>Получить функцию, осуществляющую поворот пространственного угла на заданный пространственный угол</summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.GetRotatorPhiThetaExpression(System.Linq.Expressions.Expression)">
            <summary>Получить выражение, осуществляющее поворот угла на текущий пространственный угол</summary>
            <param name="r">Выражение, предоставляющее пространственный угол, который требуется повернуть</param>
            <returns>Выражение, обеспечивающее поворот пространственного угла на текущий угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.RotatePhiTheta``1(System.Func{MathCore.Vectors.SpaceAngle,``0})">
            <summary>Повернуть функцию от пространственного угла на текущий угол</summary>
            <param name="f">Поворачиваемая функция</param>
            <typeparam name="T">Тип значения функции</typeparam>
            <returns>Функция, аргумент которой повёрнут на текущий угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.In(MathCore.AngleType)">
            <summary>Представить угол в указанном типе значения</summary>
            <param name="type">Тип требуемого значения угла</param>
            <returns></returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Deconstruct(System.Double@,System.Double@)">
            <summary>Деконструктор значений угла</summary>
            <param name="theta">Угол места</param>
            <param name="phi">Угол азимута</param>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.op_UnaryNegation(MathCore.Vectors.SpaceAngle)">
            <summary>Оператор отрицания значения пространственного угла</summary>
            <param name="a">Исходный пространственный угол</param>
            <returns>Пространственный угол у которого значения угла места и азимута имеют обратный знак по отношению к исходному значению</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.op_ExclusiveOr(System.Func{MathCore.Vectors.SpaceAngle,System.Double},MathCore.Vectors.SpaceAngle)">
            <summary>Оператор поворота функции на пространственный угол</summary>
            <param name="f">Вещественная пространственная функция</param>
            <param name="a">Пространственный угол поворота</param>
            <returns>Вещественная функция, аргумент которой повёрнут на указанный пространственный угол</returns>
        </member>
        <member name="M:MathCore.Vectors.SpaceAngle.op_ExclusiveOr(System.Func{MathCore.Vectors.SpaceAngle,MathCore.Complex},MathCore.Vectors.SpaceAngle)">
            <summary>Оператор поворота функции на пространственный угол</summary>
            <param name="f">Комплексная пространственная функция</param>
            <param name="a">Пространственный угол поворота</param>
            <returns>Комплексная функция, аргумент которой повёрнут на указанный пространственный угол</returns>
        </member>
        <member name="P:MathCore.Vectors.SpaceAngle.ComparisonsAccuracy">
            <summary>Точность сравнения (по умолчанию 10^-13)</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.Equals(MathCore.Vectors.Vector{`0})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Vectors.Vector2DConverter">
            <summary>Конвертер для <see cref="T:MathCore.Vectors.Vector2D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2DConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Vectors.Vector2D">
            <summary>Двумерный вектор</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector2D._X">
            <summary>Координата X</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector2D._Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector2D.X">
            <summary>Координата X</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector2D.Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector2D.R">
            <summary>Радиус (длина) вектора</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector2D.Angle">
            <summary>Угол к оси X в радианах</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.#ctor(System.Double,System.Double)">
            <summary>Инициализация двумерного вектора</summary>
            <param name="X">Координата X</param>
            <param name="Y">Координата Y</param>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.#ctor(MathCore.Complex)">
            <summary>Инициализация вектора по по комплексному числу</summary>
            <param name="Z">Комплексное число X + iY</param>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.InBasis(MathCore.Vectors.Basis2D)">
            <summary>Представление вектора в базисе</summary>
            <param name="b">Базис</param>
            <returns>Вектор в базисе</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.System#ICloneable#Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Equals(MathCore.Vectors.Vector2D)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Equals(System.ValueTuple{System.Double,System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Equals(System.ValueTuple{System.Int32,System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Equals(System.ValueTuple{System.Double,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Equals(System.ValueTuple{System.Int32,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector2D.Deconstruct(System.Double@,System.Double@)">
            <summary>Деконструктор вектора на его составляющие</summary>
            <param name="x">Координата X</param><param name="y">Координата Y</param>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Equality(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор равенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Inequality(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор неравенства</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(MathCore.Vectors.Vector2D)~MathCore.Complex">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Vectors.Vector2D"/> в <see cref="T:MathCore.Complex"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(MathCore.Vectors.Vector2D)~System.ValueTuple{System.Double,System.Double}">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Vectors.Vector2D"/> в <see cref="T:MathCore.Complex"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(MathCore.Vectors.Vector2D)~System.ValueTuple{System.Int32,System.Double}">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Vectors.Vector2D"/> в <see cref="T:MathCore.Complex"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(MathCore.Vectors.Vector2D)~System.ValueTuple{System.Double,System.Int32}">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Vectors.Vector2D"/> в <see cref="T:MathCore.Complex"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(MathCore.Vectors.Vector2D)~System.ValueTuple{System.Int32,System.Int32}">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Vectors.Vector2D"/> в <see cref="T:MathCore.Complex"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(MathCore.Complex)~MathCore.Vectors.Vector2D">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Complex"/> в <see cref="T:MathCore.Vectors.Vector2D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(System.ValueTuple{System.Double,System.Double})~MathCore.Vectors.Vector2D">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Complex"/> в <see cref="T:MathCore.Vectors.Vector2D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(System.ValueTuple{System.Int32,System.Double})~MathCore.Vectors.Vector2D">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Complex"/> в <see cref="T:MathCore.Vectors.Vector2D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(System.ValueTuple{System.Double,System.Int32})~MathCore.Vectors.Vector2D">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Complex"/> в <see cref="T:MathCore.Vectors.Vector2D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Explicit(System.ValueTuple{System.Int32,System.Int32})~MathCore.Vectors.Vector2D">
            <summary>Оператор явного преобразования типа <see cref="T:MathCore.Complex"/> в <see cref="T:MathCore.Vectors.Vector2D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Implicit(System.Double)~MathCore.Vectors.Vector2D">
            <summary>Оператор неявного преобразования типа <see cref="T:System.Double"/> в <see cref="T:MathCore.Vectors.Vector2D"/> (вектор вдоль оси OX)</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_UnaryPlus(MathCore.Vectors.Vector2D)">
            <summary>Унарный оператор +</summary>
            <returns>Вектор без изменения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_UnaryNegation(MathCore.Vectors.Vector2D)">
            <summary>Унарный оператор отрицания</summary>
            <returns>Вектор, координаты которого имеют противоположенный знак</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор вычисления суммы двух векторов</summary>
            <returns>Вектор, координаты которого составлены из суммы координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор вычисления разности двух векторов</summary>
            <returns>Вектор, координаты которого составлены из разности координат слагаемых</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор вычисления скалярного произведения двух векторов</summary>
            <returns>Вещественное число, равное суме попарных произведений координат векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D,System.Double)">
            <summary>Оператор вычисления суммы вектора и вещественного числа</summary>
            <returns>Вектор, координаты которого увеличены на значение скалярного слагаемого</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.Double,MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления суммы вектора и вещественного числа</summary>
            <returns>Вектор, координаты которого увеличены на значение скалярного слагаемого</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D,System.Double)">
            <summary>Оператор вычитания скалярного значения из вектора</summary>
            <param name="a">Уменьшаемое - вектор</param>
            <param name="b">Вычитаемое - скаляр</param>
            <returns>Вектор, координаты которого уменьшены на значение скаляра</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.Double,MathCore.Vectors.Vector2D)">
            <summary>Оператор вычитания вектора из скалярного значения</summary>
            <param name="b">Уменьшаемое - скаляр</param>
            <param name="a">вычитаемое - вектор</param>
            <returns>Вектор, координаты которого вычтены из скалярного значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D,System.Double)">
            <summary>Оператор умножения вектора на число</summary>
            <returns>Вектор, координаты которого умножены на скалярное значение</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.Double,MathCore.Vectors.Vector2D)">
            <summary>Оператор умножения вектора на число</summary>
            <returns>Вектор, координаты которого умножены на скалярное значение</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(MathCore.Vectors.Vector2D,System.Double)">
            <summary>Оператор деления вектора на число</summary>
            <returns>Вектор, координаты которого разделены на скалярное значение</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(System.Double,MathCore.Vectors.Vector2D)">
            <summary>Оператор деления числа на вектор</summary>
            <returns>Вектор, координаты которого образованы делением координат числа на координаты исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_ExclusiveOr(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор проекции в вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param><param name="b">Вектор проекции</param>
            <returns>Проекция первого вектора на второй</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseOr(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор проверки на параллельность двух векторов</summary>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_BitwiseAnd(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор проверки на перпендикулярность двух векторов</summary>
            <returns>Истина, если вектора перпендикулярны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(MathCore.Vectors.Vector2D,MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(System.ValueTuple{System.Double,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(System.ValueTuple{System.Int32,System.Double},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(System.ValueTuple{System.Double,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(System.ValueTuple{System.Int32,System.Int32},MathCore.Vectors.Vector2D)">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Double})">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Double})">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(MathCore.Vectors.Vector2D,System.ValueTuple{System.Double,System.Int32})">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(MathCore.Vectors.Vector2D,System.ValueTuple{System.Int32,System.Int32})">
            <summary>Оператор вычисления проекции вектора на вектор</summary>
            <param name="a">Проецируемый вектор</param>
            <param name="b">Вектор, на который осуществляется проекция</param>
            <returns>Длина проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Modulus(MathCore.Vectors.Vector2D,MathCore.Vectors.Basis2D)">
            <summary>Оператор представление вектора в базисе</summary>
            <param name="a">Вектор, представляемый в базисе</param>
            <param name="b">Базис, в котором надо представить вектор</param>
            <returns>Вектор, представленный в базисе</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D,System.Single)">
            <summary>Оператор суммы вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого увеличены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D,System.Single)">
            <summary>Оператор разности вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого уменьшены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D,System.Single)">
            <summary>Оператор произведения вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого умножены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(MathCore.Vectors.Vector2D,System.Single)">
            <summary>Оператор деления вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого поделены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.Single,MathCore.Vectors.Vector2D)">
            <summary>Оператор суммы вектора и вещественного числа одинарной точности</summary>
            <returns>Вектор, координаты которого увеличены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.Single,MathCore.Vectors.Vector2D)">
            <summary>Оператор вещественного числа одинарной точности и разности вектора</summary>
            <returns>Вектор, координаты которого равны разности числа одинарной точности и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.Single,MathCore.Vectors.Vector2D)">
            <returns>Вектор, координаты которого умножены на значение числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(System.Single,MathCore.Vectors.Vector2D)">
            <summary>Оператор деления вещественного числа одинарной точности и вектора</summary>
            <returns>Вектор, координаты которого равны отношению числа одинарной точности и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(MathCore.Vectors.Vector2D,System.Int32)">
            <summary>Оператор суммы вектора и вещественного целого числа</summary>
            <returns>Вектор, координаты которого увеличены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(MathCore.Vectors.Vector2D,System.Int32)">
            <summary>Оператор разности вектора и вещественного целого числа</summary>
            <returns>Вектор, координаты которого уменьшены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(MathCore.Vectors.Vector2D,System.Int32)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(MathCore.Vectors.Vector2D,System.Int32)">
            <summary>Оператор деления вектора и целого числа</summary>
            <returns>Вектор, координаты которого поделены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Addition(System.Int32,MathCore.Vectors.Vector2D)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Subtraction(System.Int32,MathCore.Vectors.Vector2D)">
            <summary>Оператор целого числа и разности вектора</summary>
            <returns>Вектор, координаты которого равны разности целого числа и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Multiply(System.Int32,MathCore.Vectors.Vector2D)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значение целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector2D.op_Division(System.Int32,MathCore.Vectors.Vector2D)">
            <summary>Оператор деления целого числа и вектора</summary>
            <returns>Вектор, координаты которого равны отношению целого числа и координат исходного вектора</returns>
        </member>
        <member name="T:MathCore.Vectors.Vector3DConverter">
            <summary>Конвертер для <see cref="T:MathCore.Vectors.Vector3D"/></summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3DConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:MathCore.Vectors.Vector3D">
            <summary>Трёхмерный вектор</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ThetaPhiRadius(System.Double,System.Double,System.Double)">
            <summary>Создать вектор по сферической системе координат</summary>
            <param name="Theta">Угол места</param>
            <param name="Phi">Азимут</param>
            <param name="R">Длина вектора</param>
            <returns>Трёхмерный вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.XYZ(System.Double,System.Double,System.Double)">
            <summary>Преобразовать координаты декартовой системы в вектор</summary>
            <param name="X">Координата X</param>
            <param name="Y">Координата Y</param>
            <param name="Z">Координата Z</param>
            <returns>Вектор с заданными координатами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Random(System.Double,System.Double,System.Random)">
            <summary>Вектор со случайными координатами (с равномерным распределением)</summary>
            <param name="min">Минимальное значение</param>
            <param name="max">Максимальное значение</param>
            <param name="rnd">Генератор случайных чисел (если не задан, то будет создан новый)</param>
            <returns>Вектор со случайными значениями координат из указанного диапазона</returns>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.k">
            <summary>Базисный вектор k</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.Empty">
            <summary>Вектор нулевой длины в начале координат</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.BasisUnitVector">
            <summary>Единичный базисный вектор</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.i">
            <summary>Базисный вектор i</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D.j">
            <summary>Базисный вектор j</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D._X">
            <summary>Длина по оси X</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D._Y">
            <summary>Длина по оси Y</summary>
        </member>
        <member name="F:MathCore.Vectors.Vector3D._Z">
            <summary>Длина по оси Z</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.X">
            <summary>Длина по оси X</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Y">
            <summary>Длина по оси Y</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Z">
            <summary>Длина по оси Z</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.R">
            <summary>Длина вектора</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.AngleXOY">
            <summary>Угол проекции в плоскости XOY</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.AngleXOZ">
            <summary>Угол проекции в плоскости XOZ</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.AngleYOZ">
            <summary>Угол проекции в плоскости YOZ</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Phi">
            <summary>Азимутальный угол</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Theta">
            <summary>Угол места</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Angle">
            <summary>Пространственный угол</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.VectorXOY">
            <summary>Двумерный вектор - проекция в плоскости XOY</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.VectorXOZ">
            <summary>Двумерный вектор - проекция в плоскости XOZ (X->X; Z->Y)</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.VectorYOZ">
            <summary>Двумерный вектор - проекция в плоскости YOZ (Y->X; Z->Y)</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.R_XOY">
            <summary>Длина в плоскости XOY</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.R_XOZ">
            <summary>Длина в плоскости XOZ</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.R_YOZ">
            <summary>Длина в плоскости YOZ</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Abs">
            <summary>Длина вектора</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.Sign">
            <summary>Вектор знаков координат текущего вектора</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(System.Double)">
            <summary>Инициализация нового вектора, расположенного вдоль оси OX</summary>
            <param name="X">Координата вдоль оси OX</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового вектора, расположенного в плоскости XOY</summary>
            <param name="X">Координата вдоль оси OX</param>
            <param name="Y">Координата вдоль оси OY</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(System.Double,System.Double,System.Double)">
            <summary>Инициализация нового вектора, заданного своими координатами</summary>
            <param name="X">Координата вдоль оси OX</param>
            <param name="Y">Координата вдоль оси OY</param>
            <param name="Z">Координата вдоль оси OZ</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(MathCore.Vectors.SpaceAngle)">
            <summary>Единичный вектор, заданный двумя углами в сферической системе координат</summary>
            <param name="Angle">Пространственный угол сферической системы координат</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(System.Double,MathCore.Vectors.SpaceAngle)">
            <summary>Вектор, заданный двумя углами и радиусом в сферической системе координат</summary>
            <param name="R">Радиус вектора</param>
            <param name="Angle">Пространственный угол сферической системы координат</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.#ctor(MathCore.Vectors.Vector3D)">
            <summary>Конструктор копирования</summary>
            <param name="V">Вектор-прототип</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.InBasis(MathCore.Vectors.Basis3D)">
            <summary>Представление вектора в базисе</summary>
            <param name="b">Новый базис вектора</param>
            <returns>Вектор в указанном базисе</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Inc(System.Double,System.Double,System.Double)">
            <summary>Инкрементация координат вектора</summary>
            <param name="dx">Величина приращения координаты X</param>
            <param name="dy">Величина приращения координаты Y</param>
            <param name="dz">Величина приращения координаты Z</param>
            <returns>Вектор с новыми координатами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.IncX(System.Double)">
            <summary>Инкрементировать координату X</summary>
            <param name="dx">Величина приращения координаты X</param>
            <returns>Вектор с обновлённой координатой X</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.IncY(System.Double)">
            <summary>Инкрементировать координату Y</summary>
            <param name="dy">Величина приращения координаты Y</param>
            <returns>Вектор с обновлённой координатой Y</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.IncZ(System.Double)">
            <summary>Инкрементировать координату Z</summary>
            <param name="dz">Величина приращения координаты Z</param>
            <returns>Вектор с обновлённой координатой Z</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Dec(System.Double,System.Double,System.Double)">
            <summary>Декрементация координат вектора</summary>
            <param name="dx">Величина приращения координаты X</param>
            <param name="dy">Величина приращения координаты Y</param>
            <param name="dz">Величина приращения координаты Z</param>
            <returns>Вектор с новыми координатами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.DecX(System.Double)">
            <summary>Декрементировать координату X</summary>
            <param name="dx">Величина приращения координаты X</param>
            <returns>Вектор с обновлённой координатой X</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.DecY(System.Double)">
            <summary>Декрементировать координату Y</summary>
            <param name="dy">Величина приращения координаты Y</param>
            <returns>Вектор с обновлённой координатой Y</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.DecZ(System.Double)">
            <summary>Декрементировать координату Z</summary>
            <param name="dz">Величина приращения координаты Z</param>
            <returns>Вектор с обновлённой координатой Z</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Scale(System.Double,System.Double,System.Double)">
            <summary>Выполнить масштабирование вектора по координатам</summary>
            <param name="kx">Коэффициент масштабирования координаты X</param>
            <param name="ky">Коэффициент масштабирования координаты Y</param>
            <param name="kz">Коэффициент масштабирования координаты Z</param>
            <returns>Вектор, координаты которого умножены на соответствующие значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ScaleX(System.Double)">
            <summary>Выполнить масштабирование вектора по оси OX</summary>
            <param name="kx">Коэффициент масштабирования координаты X</param>
            <returns>Вектор, координаты которого умножены на соответствующие значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ScaleY(System.Double)">
            <summary>Выполнить масштабирование вектора по оси OY</summary>
            <param name="ky">Коэффициент масштабирования координаты Y</param>
            <returns>Вектор, координаты которого умножены на соответствующие значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ScaleZ(System.Double)">
            <summary>Выполнить масштабирование вектора по оси OZ</summary>
            <param name="kz">Коэффициент масштабирования координаты Z</param>
            <returns>Вектор, координаты которого умножены на соответствующие значения</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ToString">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.System#ICloneable#Clone">
            <summary>Создает новый объект, который является копией текущего экземпляра</summary>
            <returns>Новый объект, являющийся копией этого экземпляра</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Clone">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ToString(System.String)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Строка формата</param>
            <returns>Форматированное строковое представление</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.ToString(System.String,System.IFormatProvider)">
            <summary>Преобразование в строку с форматированием</summary>
            <param name="Format">Строка формата</param>
            <param name="Provider">Провайдер форматирования данных</param>
            <returns>Форматированное строковое представление</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Deconstruct(System.Double@,System.Double@,System.Double@)">
            <summary>Деконструктор вектора на значения его координат</summary>
        </member>
        <member name="P:MathCore.Vectors.Vector3D.ComparisonsAccuracy">
            <summary>Точность сравнения (по умолчанию 10^-16)</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Equals(MathCore.Vectors.Vector3D)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Equals(System.ValueTuple{System.Double,System.Double,System.Double})">
            <inheritdoc />
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetInverse">
            <summary>Получить вектор, координаты которого являются обратными к координатам текущего вектора</summary>
            <returns>Вектор с обратными координатами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Scalar(MathCore.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="Vector">Вектор, на который умножается текущий вектор</param>
            <returns>Число, равное скалярному произведению векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Scalar(System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Скалярное произведение векторов</summary>
            <param name="Vector">Вектор, на который умножается текущий вектор</param>
            <returns>Число, равное скалярному произведению векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Mixed(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Смешанное произведение трёх векторов</summary>
            <param name="A">Первый вектор произведения</param>
            <param name="B">Второй вектор произведения</param>
            <param name="C">Третий вектор произведения</param>
            <returns>Число, равное смешанному произведения векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Vector(MathCore.Vectors.Vector3D)">
            <summary>Векторное произведение векторов</summary>
            <param name="Vector">Вектор, на который умножается исходный вектор</param>
            <returns>Вектор, равный векторному произведению векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Vector(System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Векторное произведение векторов</summary>
            <param name="Vector">Вектор, на который умножается исходный вектор</param>
            <returns>Вектор, равный векторному произведению векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_VectorInv(System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Векторное произведение векторов</summary>
            <param name="Vector">Вектор, на который умножается исходный вектор</param>
            <returns>Вектор, равный векторному произведению векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Component(MathCore.Vectors.Vector3D)">
            <summary>Покомпонентное умножение на вектор</summary>
            <param name="Vector">Векторный сомножитель</param>
            <returns>Вектор, компоненты которого являются произведениями компоненты векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.Product_Component(System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Покомпонентное умножение на вектор</summary>
            <param name="Vector">Векторный сомножитель</param>
            <returns>Вектор, компоненты которого являются произведениями компоненты векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetAngle(MathCore.Vectors.Vector3D)">
            <summary>Угол между векторами</summary>
            <param name="Vector">Вектор, к которому вычисляется угол</param>
            <returns>Пространственный угол между векторами</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectionTo(MathCore.Vectors.Vector3D)">
            <summary>Проекция на вектор</summary>
            <param name="Vector">Вектор, НА который производится проекции</param>
            <returns>Проекция на вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectionTo(System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Проекция на вектор</summary>
            <param name="Vector">Вектор, НА который производится проекции</param>
            <returns>Проекция на вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectionInverseTo(MathCore.Vectors.Vector3D)">
            <summary>Проекция на вектор</summary>
            <param name="Vector">Вектор, НА который производится проекции</param>
            <returns>Проекция на вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectionInverseTo(System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Проекция на вектор</summary>
            <param name="Vector">Вектор, НА который производится проекции</param>
            <returns>Проекция на вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorV">
            <summary>Проекцию текущего вектора на вектор</summary>
            <returns>Функция, вычисляющая проекцию текущего вектора на вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorV(MathCore.Vectors.Vector3D)">
            <summary>Проекцию текущего вектора на вектор</summary>
            <returns>Функция, вычисляющая проекцию текущего вектора на вектор</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorV_Expression(System.Linq.Expressions.Expression)">
            <summary>Проекция текущего вектора на вектор, передаваемый в качестве параметра</summary>
            <param name="v">Выражение, результатом вычисления которого является <see cref="T:MathCore.Vectors.Vector3D"/></param>
            <returns>Выражение, вычисляющее проекцию текущего вектора на вектор, передаваемый в параметре функции</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка</exception>
            <exception cref="T:System.ArgumentException">Если тип результата <paramref name="v"/> не является <see cref="T:MathCore.Vectors.Vector3D"/></exception>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectionTo(MathCore.Vectors.SpaceAngle)">
            <summary>Проекция на направление</summary>
            <param name="Direction">Направление, на которое проектируется вектор</param>
            <returns>Проекция вектора на направление</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorA">
            <summary>Проекцию текущего вектора на угол</summary>
            <returns>Функция, вычисляющая проекцию текущего вектора на угол</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorA(MathCore.Vectors.Vector3D)">
            <summary>Проекцию текущего вектора на угол</summary>
            <returns>Функция, вычисляющая проекцию текущего вектора на угол</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.GetProjectorA_Expression(System.Linq.Expressions.Expression)">
            <summary>Создать выражение проекции вектора на пространственный угол</summary>
            <param name="d">Выражение, результатом вычисления которого будет объект <see cref="T:MathCore.Vectors.SpaceAngle"/></param>
            <returns>Выражение проекции вектора на угол</returns>
            <exception cref="T:System.ArgumentNullException">Если <paramref name="d"/> <see langword="=="/> <see langword="null"/></exception>
            <exception cref="T:System.ArgumentException">Если тип выражения <paramref name="d"/> является не <see cref="T:MathCore.Vectors.SpaceAngle"/></exception>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор суммы вектора и числа</summary>
            <returns>Вектор, координаты которого увеличены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(System.Double,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы вектора и числа</summary>
            <returns>Вектор, координаты которого увеличены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор разности вектора и числа</summary>
            <returns>Вектор, координаты которого уменьшены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(System.Double,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы числа и вектора</summary>
            <returns>Вектор, координаты которого равны разности числа и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор произведения вектора и числа</summary>
            <returns>Вектор, координаты которого умножены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(System.Double,MathCore.Vectors.Vector3D)">
            <summary>Оператор произведения вектора и числа</summary>
            <returns>Вектор, координаты которого умножены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор деления вектора на число</summary>
            <returns>Вектор, координаты которого разделены на значения числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(System.Double,MathCore.Vectors.Vector3D)">
            <summary>Оператор деления числа на вектор</summary>
            <returns>Вектор, координаты которого являются результатом деления числа на координаты исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор суммы вектора и числа одинарной точности</summary>
            <returns>Вектор, координаты которого увеличены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(System.Single,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы вектора и числа одинарной точности</summary>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор разности вектора и числа одинарной точности</summary>
            <returns>Вектор, координаты которого уменьшены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(System.Single,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы числа одинарной точности и вектора</summary>
            <returns>Вектор, координаты которого равны разности числа одинарной точности и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор произведения вектора и числа одинарной точности</summary>
            <returns>Вектор, координаты которого умножены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(System.Single,MathCore.Vectors.Vector3D)">
            <summary>Оператор произведения вектора и числа одинарной точности</summary>
            <returns>Вектор, координаты которого умножены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор деления вектора на число одинарной точности</summary>
            <returns>Вектор, координаты которого разделены на значения числа одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(System.Single,MathCore.Vectors.Vector3D)">
            <summary>Оператор деления числа одинарной точности на вектор</summary>
            <returns>Вектор, координаты которого являются результатом деления числа одинарной точности на координаты исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор суммы вектора и целого числа</summary>
            <returns>Вектор, координаты которого увеличены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(System.Int32,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы вектора и целого числа</summary>
            <returns>Вектор, координаты которого увеличены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор разности вектора и целого числа</summary>
            <returns>Вектор, координаты которого уменьшены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(System.Int32,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы целого числа и вектора</summary>
            <returns>Вектор, координаты которого равны разности целого числа и координат исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(System.Int32,MathCore.Vectors.Vector3D)">
            <summary>Оператор произведения вектора и целого числа</summary>
            <returns>Вектор, координаты которого умножены на значения целого числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор деления вектора на целое число</summary>
            <returns>Вектор, координаты которого разделены на значения целое числа</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Division(System.Int32,MathCore.Vectors.Vector3D)">
            <summary>Оператор деления целого числа на вектор</summary>
            <returns>Вектор, координаты которого являются результатом деления целого числа на координаты исходного вектора</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Оператор проверки равенства двух векторов</summary>
            <returns>Истина, если координаты векторов равны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(System.ValueTuple{System.Double,System.Double,System.Double},MathCore.Vectors.Vector3D)">
            <summary>Оператор проверки равенства двух векторов</summary>
            <returns>Истина, если координаты векторов равны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Оператор проверки равенства двух векторов</summary>
            <returns>Истина, если координаты векторов равны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Оператор проверки неравенства двух векторов</summary>
            <returns>Истина, если координаты векторов неравны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(System.ValueTuple{System.Double,System.Double,System.Double},MathCore.Vectors.Vector3D)">
            <summary>Оператор проверки неравенства двух векторов</summary>
            <returns>Истина, если координаты векторов неравны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Оператор проверки неравенства двух векторов</summary>
            <returns>Истина, если координаты векторов неравны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Byte)">
            <summary>Оператор проверки равенства вектора и целого числа (1 байт)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (1 байт)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.SByte)">
            <summary>Оператор проверки равенства вектора и целого числа (1 байт со знаком)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (1 байт со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Int16)">
            <summary>Оператор проверки равенства вектора и целого числа (2 байта со знаком)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (2 байта со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.UInt16)">
            <summary>Оператор проверки равенства вектора и целого числа (2 байта без знака)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (2 байта без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор проверки равенства вектора и целого числа</summary>
            <returns>Истина, если длина вектора равна указанному целому числу</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.UInt32)">
            <summary>Оператор проверки равенства вектора и целого числа без знака</summary>
            <returns>Истина, если длина вектора равна указанному целому числу без знака</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Int64)">
            <summary>Оператор проверки равенства вектора и целого числа (8 байт со знаком)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (8 байт со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.UInt64)">
            <summary>Оператор проверки равенства вектора и целого числа (8 байт без знака)</summary>
            <returns>Истина, если длина вектора равна указанному целому числу (8 байт без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор проверки равенства вектора и числа одинарной точности</summary>
            <returns>Истина, если длина вектора равна указанному числу одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Equality(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор проверки равенства вектора и числа двойной точности</summary>
            <returns>Истина, если длина вектора равна указанному числу двойной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Byte)">
            <summary>Оператор проверки неравенства вектора и целого числа (1 байт без знака)</summary>
            <returns>Истина, если длина вектора не равна целому числу (1 байт без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.SByte)">
            <summary>Оператор проверки неравенства вектора и целого числа (1 байт со знаком)</summary>
            <returns>Истина, если длина вектора не равна целому числу (1 байт со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Int16)">
            <summary>Оператор проверки неравенства вектора и целого числа (2 байта со знаком)</summary>
            <returns>Истина, если длина вектора не равна целому числу (2 байта со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.UInt16)">
            <summary>Оператор проверки неравенства вектора и целого числа (2 байта без знака)</summary>
            <returns>Истина, если длина вектора не равна целому числу (2 байта без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Int32)">
            <summary>Оператор проверки неравенства вектора и целого числа</summary>
            <returns>Истина, если длина вектора не равна целому числу</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.UInt32)">
            <summary>Оператор проверки неравенства вектора и целого числа</summary>
            <returns>Истина, если длина вектора не равна целому числу</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Int64)">
            <summary>Оператор проверки неравенства вектора и целого числа (8 байт со знаком)</summary>
            <returns>Истина, если длина вектора не равна целому числу (8 байт со знаком)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.UInt64)">
            <summary>Оператор проверки неравенства вектора и целого числа (8 байт без знака)</summary>
            <returns>Истина, если длина вектора не равна целому числу (8 байт без знака)</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Single)">
            <summary>Оператор проверки неравенства вектора и вещественного числа одинарной точности</summary>
            <returns>Истина, если длина вектора не равна вещественному числу одинарной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Inequality(MathCore.Vectors.Vector3D,System.Double)">
            <summary>Оператор проверки неравенства вектора и вещественного числа двойной точности</summary>
            <returns>Истина, если длина вектора не равна вещественному числу двойной точности</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы двух векторов</summary>
            <returns>Вектор, координаты которого равны сумме координат двух исходных векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(System.ValueTuple{System.Double,System.Double,System.Double},MathCore.Vectors.Vector3D)">
            <summary>Оператор суммы двух векторов</summary>
            <returns>Вектор, координаты которого равны сумме координат двух исходных векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Addition(MathCore.Vectors.Vector3D,System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Оператор суммы двух векторов</summary>
            <returns>Вектор, координаты которого равны сумме координат двух исходных векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Оператор разности двух векторов</summary>
            <returns>Вектор, координаты которого равны разности координат двух исходных векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(System.ValueTuple{System.Double,System.Double,System.Double},MathCore.Vectors.Vector3D)">
            <summary>Оператор разности двух векторов</summary>
            <returns>Вектор, координаты которого равны разности координат двух исходных векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Subtraction(MathCore.Vectors.Vector3D,System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Оператор разности двух векторов</summary>
            <returns>Вектор, координаты которого равны разности координат двух исходных векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="A">Первый вектор-множитель</param>
            <param name="B">Второй вектор-множитель</param>
            <returns>Число - скалярное произведение векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(System.ValueTuple{System.Double,System.Double,System.Double},MathCore.Vectors.Vector3D)">
            <summary>Скалярное произведение векторов</summary>
            <param name="A">Первый вектор-множитель</param>
            <param name="B">Второй вектор-множитель</param>
            <returns>Число - скалярное произведение векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Multiply(MathCore.Vectors.Vector3D,System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Скалярное произведение векторов</summary>
            <param name="A">Первый вектор-множитель</param>
            <param name="B">Второй вектор-множитель</param>
            <returns>Число - скалярное произведение векторов</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_ExclusiveOr(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Угол между векторами</summary>
            <param name="A">Вектор 1</param>
            <param name="B">Вектор 2</param>
            <returns>Угол между вектором А и вектором В в пространстве</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_BitwiseOr(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Проверка на параллельность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_BitwiseOr(System.ValueTuple{System.Double,System.Double,System.Double},MathCore.Vectors.Vector3D)">
            <summary>Проверка на параллельность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_BitwiseOr(MathCore.Vectors.Vector3D,System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Проверка на параллельность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектора параллельны</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_BitwiseAnd(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Проверка на ортогональность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектор 1 ортогонален вектору 2</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_BitwiseAnd(System.ValueTuple{System.Double,System.Double,System.Double},MathCore.Vectors.Vector3D)">
            <summary>Проверка на ортогональность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектор 1 ортогонален вектору 2</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_BitwiseAnd(MathCore.Vectors.Vector3D,System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Проверка на ортогональность</summary>
            <param name="A">Вектор 1</param><param name="B">Вектор 2</param>
            <returns>Истина, если вектор 1 ортогонален вектору 2</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Modulus(MathCore.Vectors.Vector3D,MathCore.Vectors.Vector3D)">
            <summary>Проекция вектора A на вектор B</summary>
            <param name="A">Проецируемый вектор</param>
            <param name="B">Вектор, на который производится проекции</param>
            <returns>Проекция вектора А на вектор В</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Modulus(System.ValueTuple{System.Double,System.Double,System.Double},MathCore.Vectors.Vector3D)">
            <summary>Проекция вектора A на вектор B</summary>
            <param name="A">Проецируемый вектор</param>
            <param name="B">Вектор, на который производится проекции</param>
            <returns>Проекция вектора А на вектор В</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Modulus(MathCore.Vectors.Vector3D,System.ValueTuple{System.Double,System.Double,System.Double})">
            <summary>Проекция вектора A на вектор B</summary>
            <param name="A">Проецируемый вектор</param>
            <param name="B">Вектор, на который производится проекции</param>
            <returns>Проекция вектора А на вектор В</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Modulus(MathCore.Vectors.Vector3D,MathCore.Vectors.SpaceAngle)">
            <summary>Проекция вектора на направление</summary>
            <param name="Vector">Проецируемый вектор</param>
            <param name="Direction">Пространственный угол направления проекции</param>
            <returns>Вещественное значение проекции</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Modulus(MathCore.Vectors.Vector3D,MathCore.Vectors.Basis3D)">
            <summary>Оператор представления вектора в базисе</summary>
            <returns>Вектор, представленный в базисе</returns>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Implicit(MathCore.Vectors.Vector3D)~System.Double">
            <summary>Оператор неявного приведения <see cref="T:MathCore.Vectors.Vector3D"/> к <see cref="T:System.Double"/>, результатом которого является длина вектора</summary>
            <param name="V">Трёхмерный вектор</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Implicit(MathCore.Vectors.Vector3D)~MathCore.Vectors.SpaceAngle">
            <summary>Оператор неявного приведения <see cref="T:MathCore.Vectors.Vector3D"/> к <see cref="T:MathCore.Vectors.SpaceAngle"/></summary>
            <param name="V">Трёхмерный вектор</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Explicit(MathCore.Vectors.SpaceAngle)~MathCore.Vectors.Vector3D">
            <summary>Оператор неявного приведения <see cref="T:MathCore.Vectors.SpaceAngle"/> к <see cref="T:MathCore.Vectors.Vector3D"/>, результатом которого является единичный вектор, ориентированный в пространстве</summary>
            <param name="Angle">Пространственный угол</param>
        </member>
        <member name="M:MathCore.Vectors.Vector3D.op_Explicit(System.Double)~MathCore.Vectors.Vector3D">
            <summary>Оператор явного приведения типа <see cref="T:System.Double"/> к <see cref="T:MathCore.Vectors.Vector3D"/>, результатом которого является вектор, с равными координатами, длина которого равна указанному числу</summary>
            <param name="V">Длина вектора</param>
        </member>
        <member name="T:MathCore.ViewModels.ViewModel">
            <summary>Наблюдаемая модель</summary>
        </member>
        <member name="E:MathCore.ViewModels.ViewModel.PropertyChanging">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.OnPropertyChanging``1(``0,``0@,System.String@)">
            <summary>Генерация события находящегося в процессе изменения значения свойства</summary>
            <param name="OldValue">Предыдущее значение свойства</param>
            <param name="NewValue">Новое значение свойства</param>
            <param name="PropertyName">Имя изменившегося свойства (если не указано, то берётся имя вызывающего метода)</param>
            <typeparam name="T">Тип значения свойства</typeparam>
            <returns>Истина, если событие было обработано и новое значение свойства не равно старому</returns>
        </member>
        <member name="E:MathCore.ViewModels.ViewModel.PropertyChanged">
            <summary>Событие возникает когда изменяется значение свойства объекта</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_AddHandler(System.ComponentModel.PropertyChangedEventHandler@)">
            <summary>Присоединить обработчик события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <param name="handler">Присоединяемый обработчик события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></param>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel._PropertyChangedHandlers">
            <summary>Словарь обработчиков событий изменений свойств</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_AddHandler(System.String@,System.Action@)">
            <summary>Добавление обработчика события изменения свойства</summary>
            <param name="PropertyName">Имя отслеживаемого события</param>
            <param name="handler">Устанавливаемый обработчик</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_RemoveHandler(System.String@,System.Action@)">
            <summary>Извлечение обработчика события изменения указанного свойства</summary>
            <param name="PropertyName">Имя отслеживаемого свойства</param>
            <param name="handler">Извлекаемый обработчик события</param>
            <returns>Истина, если обработчик события удалён успешно</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_ClearHandlers(System.String@)">
            <summary>Очистка обработчиков изменений свойства</summary>
            <returns>Истина, если очистка произведена успешно</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_ClearHandlers">
            <summary>Очистка обработчиков изменений всех свойств</summary>
            <returns>Истина, если очистка произведена успешно</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChanged_RemoveHandler(System.ComponentModel.PropertyChangedEventHandler@)">
            <summary>Отсоединить обработчик события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <param name="handler">Отсоединяемый обработчик события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.GetPropertyChangedObservers``1">
            <summary>Получить перечисление всех объектов, подписанных на событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <typeparam name="T">Тип интересующих объектов</typeparam>
            <returns>Перечисление объектов-подписчиков события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.GetPropertyChangedObserversMethods">
            <summary>Получить перечисление всех методов, подписанных на событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <returns>Перечисление всех методов-подписчиков события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.GetPropertyChangedObserversMethods``1">
            <summary>Получить перечисление всех методов, подписанных на событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></summary>
            <typeparam name="T">Тип интересующих объектов</typeparam>
            <returns>Перечисление всех методов-подписчиков события <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/> для объекта типа <typeparamref name="T"/></returns>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel._PropertiesDependenciesDictionary">
            <summary>Словарь графа зависимости изменений свойств</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyDependence_Add(System.String,System.String[])">
            <summary>Добавить зависимости между свойствами</summary>
            <param name="PropertyName">Имя исходного свойства</param>
            <param name="Dependencies">Перечисление свойств, на которые исходное свойство имеет влияние</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.IsLoopDependency(System.String@,System.String@,System.String@,System.Collections.Generic.Stack{System.String})">
            <summary>Проверка модели на циклические зависимости между свойствами</summary>
            <param name="property">Проверяемое свойство</param>
            <param name="dependency">Зависимость</param>
            <param name="next_property">Следующее свойство в цепочке зависимости</param>
            <param name="invoke_stack">Стек вызова свойств</param>
            <returns>Истина, если найден цикл</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyDependencies_Remove(System.String@,System.String@)">
            <summary>Удаление зависимости между свойствами</summary>
            <param name="PropertyName">Исходное свойство</param>
            <param name="Dependence">Свойство, связь с которым надо разорвать</param>
            <returns>Истина, если связь успешно удалена, ложь - если связь отсутствовала</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyDependencies_Clear(System.String@)">
            <summary>Очистить граф зависимостей между свойствами для указанного свойства</summary>
            <param name="PropertyName">Название свойства, связи которого нао удалить</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения значения свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel._PropertyAsyncInvokeTime">
            <summary>Словарь, хранящий время последней генерации события изменения указанного свойства в асинхронном режиме</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.OnPropertyChangedAsync(System.String,System.Int32,System.Action,System.Action)">
            <summary>Асинхронная генерация события изменения свойства с возможностью указания таймаута ожидания повторных изменений</summary>
            <param name="PropertyName">Имя свойства</param>
            <param name="Timeout">Таймаут ожидания повторных изменений, прежде чем событие будет сгенерировано</param>
            <param name="OnChanging">Метод, выполняемый до генерации события</param>
            <param name="OnChanged">Метод, выполняемый после генерации события</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.#ctor(System.Boolean)">
            <summary>Инициализация новой view-модели</summary>
            <param name="CheckDependencies">Создавать карту зависимостей на основе атрибутов</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Dispose">
            <inheritdoc />
        </member>
        <member name="F:MathCore.ViewModels.ViewModel._Disposed">
            <summary>Признак того, что объект уже уничтожен</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="disposing">Если истина, то требуется освободить управляемые объекты. Освободить неуправляемые объекты в любом случае</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.DisposeManagedObject">
            <summary>Освободить управляемые объекты</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.DisposeUnmanagedObject">
            <summary>Освободить неуправляемые объекты</summary>
        </member>
        <member name="T:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1">
            <summary>Аргумент события процесса изменения значения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1._OldValue">
            <summary>Предыдущее значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1._NewValue">
            <summary>Новое значение свойства</summary>
        </member>
        <member name="P:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.OldValue">
            <summary>Предыдущее значение свойства</summary>
        </member>
        <member name="P:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.NewValue">
            <summary>Новое значение свойства (которое может быть изменено)</summary>
        </member>
        <member name="P:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.IsChangingValue">
            <summary>Признак того, что новое значение свойства отличается от старого</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.#ctor(`0,`0,System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.ComponentModel.PropertyChangingEventArgs"/></summary>
            <param name="OldValue">Предыдущее значение свойства</param>
            <param name="NewValue">Новое значение свойства</param>
            <param name="PropertyName">Имя изменяющегося свойства</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.PropertyChangingEventArgs`1.Set(`0@)">
            <summary>Установить новое значение свойства</summary>
            <param name="Value">Новое значение свойства</param>
            <returns>Истина, если новое значение свойства отличается от старого</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0,System.String@)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0@,System.Func{``0,System.Boolean}@,System.String@)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="ValueChecker">Метод определения области допустимых значений (должен вернуть истину для корректного значения)</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0@,System.String@,System.Func{``0,System.Boolean}@,System.String@)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="field">Ссылка на поле модели</param>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="ErrorMessage">Сообщение, записываемое в генерируемое исключение <see cref="T:System.ArgumentOutOfRangeException"/> в случае если проверка <paramref name="Validator"/> не пройдена</param>
            <param name="Validator">Метод определения области допустимых значений (должен вернуть истину для корректного значения)</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0,``0@,System.Action{``0},System.String)">
            <summary>Установить значение поля модели, в котором хранится значение изменяющегося свойства</summary>
            <typeparam name="T">Тип значения поля</typeparam>
            <param name="value">Значение, устанавливаемое для поля</param>
            <param name="OldValue">Старое значение свойства</param>
            <param name="Setter">Метод установки значения свойства</param>
            <param name="PropertyName">Имя метода, вызывавшего обновление. По умолчанию должно быть равно пустоте</param>
            <returns>Истина, если метод изменил значение поля и вызвал событие <see cref="E:MathCore.ViewModels.ViewModel.PropertyChanged"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0@,System.Action{System.String}@,System.String@)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="OnPropertyChanged">Действие, выполняемое для извещения об изменении свойства</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.Set``1(``0@,``0@,System.Action{System.String}@,System.Func{``0,System.Boolean}@,System.String@)">
            <summary>Метод установки значения свойства, осуществляющий генерацию события изменения свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="field">Ссылка на поле, хранящее значение свойства</param>
            <param name="value">Значение свойства, которое надо установить</param>
            <param name="OnPropertyChanged">Действие, выполняемое для извещения об изменении свойства</param>
            <param name="Validator">Метод определения области допустимых значений (должен вернуть истину для корректного значения)</param>
            <param name="PropertyName">Имя свойства</param>
            <returns>Истина, если значение свойства установлено успешно</returns>
        </member>
        <member name="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1">
            <summary>Объект, отвечающий за управление процессом установки значения свойства при статическом вызове метода Set</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetStaticValueResult`1._Result">
            <summary>Было ли значение свойства обновлено</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetStaticValueResult`1._OldValue">
            <summary>Прежнее значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetStaticValueResult`1._NewValue">
            <summary>Новое значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetStaticValueResult`1._OnPropertyChanged">
            <summary>Действие по генерации события обновления свойства - делегат <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.#ctor(System.Boolean,`0,System.Action{System.String})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></summary>
            <param name="Result">Было ли значение свойства обновлено</param>
            <param name="OldValue">Прежнее значение свойства</param>
            <param name="OnPropertyChanged">Действие по генерации события обновления свойства - делегат <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.#ctor(System.Boolean,`0,`0,System.Action{System.String})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></summary>
            <param name="Result">Было ли значение свойства обновлено</param>
            <param name="OldValue">Прежнее значение свойства</param>
            <param name="NewValue">Новое значение свойства</param>
            <param name="OnPropertyChanged">Действие по генерации события обновления свойства - делегат <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Then(System.Action@)">
            <summary>В случае если значение свойства было изменено вызывать указанное действие</summary>
            <param name="execute">Действие, выполняемое в случае обновления значения свойства</param>
            <returns>Признак того, что свойство изменило своё значение</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Then(System.Action{`0}@)">
            <summary>В случае если значение свойства было изменено вызывать указанное действие над новым значением</summary>
            <param name="execute">Действие над новым значением, выполняемое в случае обновления значения свойства</param>
            <returns>Признак того, что свойство изменило своё значение</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Then(System.Action{`0,`0}@)">
            <summary>В случае если значение свойства было изменено вызывать указанное действие над старым и новым значением</summary>
            <param name="execute">Действие над старым и новым значением, выполняемое в случае обновления значения свойства</param>
            <returns>Признак того, что свойство изменило своё значение</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Update(System.String@)">
            <summary>Выполнить генерацию события изменения указанного свойства, если значение текущего свойства изменилось</summary>
            <param name="PropertyName">Имя обновившегося связанного свойства</param>
            <returns>Текущий объект <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayUpdate(System.String@)">
            <summary>Выполнить генерацию события изменения указанного свойства даже если значение свойства не изменилось</summary>
            <param name="PropertyName">Имя обновившегося связанного свойства</param>
            <returns>Текущий объект <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Update(System.String[])">
            <summary>Выполнить генерацию события изменения указанного набора свойств, если значение текущего свойства изменилось</summary>
            <param name="PropertyName">Имена обновившихся связанных свойства</param>
            <returns>Текущий объект <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayUpdate(System.String[])">
            <summary>Выполнить генерацию события изменения указанного набора свойств даже если значение свойства не изменилось</summary>
            <param name="PropertyName">Имена обновившихся связанных свойства</param>
            <returns>Текущий объект <see cref="T:MathCore.ViewModels.ViewModel.SetStaticValueResult`1"/></returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action@)">
            <summary>Выполнить указанное действие даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{System.Boolean}@)">
            <summary>Выполнить указанное действие с признаком обновления свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие с признаком обновления свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{`0}@)">
            <summary>Выполнить указанное действие над новым значением свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие над новым значением свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{`0,System.Boolean}@)">
            <summary>Выполнить указанное действие над новым значением и признаком изменения свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие над новым значением и признаком изменения свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{`0,`0}@)">
            <summary>Выполнить указанное действие над старым и новым значением свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие над старым и новым значением свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.AnywayThen(System.Action{`0,`0,System.Boolean}@)">
            <summary>Выполнить указанное действие над старым, новым значением и признаком изменения свойства даже в случае если значение свойства не изменилось</summary>
            <param name="execute">Выполняемое действие над старым, новым значением и признаком изменения свойства</param>
            <returns>Истина, если значение свойства изменилось</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Equals(MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@)">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <param name="other">The object to compare with the current instance.</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.op_Equality(MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@,MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@)">
            <summary>Оператор равенства двух значений</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetStaticValueResult`1.op_Inequality(MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@,MathCore.ViewModels.ViewModel.SetStaticValueResult{`0}@)">
            <summary>Оператор неравенства двух значений</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValue``1(``0@,``0@,System.Action{System.String}@,System.String@)">
            <summary>Установить новое значение свойства</summary>
            <param name="field">Ссылка на поле свойства</param>
            <param name="value">Устанавливаемое новое значение свойства</param>
            <param name="OnPropertyChanged">Метод извещения об изменении значения свойства</param>
            <param name="PropertyName">Имя изменяемого свойства</param>
            <typeparam name="T">ТИп значения свойства</typeparam>
            <returns>Объект контроля процесс обновления значения свойства</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValue``1(``0@,``0@,System.Func{``0,System.Boolean}@,System.Action{System.String}@,System.String@)">
            <summary>Установить новое значение свойства</summary>
            <param name="field">Ссылка на поле свойства</param>
            <param name="value">Устанавливаемое новое значение свойства</param>
            <param name="Validator">Метод проверки корректности значения свойства</param>
            <param name="OnPropertyChanged">Метод извещения об изменении значения свойства</param>
            <param name="PropertyName">Имя изменяемого свойства</param>
            <typeparam name="T">ТИп значения свойства</typeparam>
            <returns>Объект контроля процесс обновления значения свойства</returns>
        </member>
        <member name="T:MathCore.ViewModels.ViewModel.SetValueResult`1">
            <summary>Установщик значения</summary>
            <typeparam name="T">Тип устанавливаемого значения</typeparam>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetValueResult`1._Result">
            <summary>Результат установки значения</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetValueResult`1._OldValue">
            <summary>Предыдущее значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetValueResult`1._NewValue">
            <summary>Новое значение свойства</summary>
        </member>
        <member name="F:MathCore.ViewModels.ViewModel.SetValueResult`1._Model">
            <summary>Модель-представления, для которой производится установка значения</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.#ctor(System.Boolean,`0,MathCore.ViewModels.ViewModel)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ViewModels.ViewModel.SetValueResult`1"/></summary>
            <param name="Result">Было ли значение установлено для свойства</param>
            <param name="OldValue">Старое значение</param>
            <param name="model">Модель-представления, для свойство которой изменилось</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.#ctor(System.Boolean,`0,`0,MathCore.ViewModels.ViewModel)">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.ViewModels.ViewModel.SetValueResult`1"/></summary>
            <param name="Result">Было ли значение установлено для свойства</param>
            <param name="OldValue">Старое значение</param>
            <param name="NewValue">Новое (установленное) значение</param>
            <param name="model">Модель-представления, для свойство которой изменилось</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Then(System.Action)">
            <summary>В случае если значение было установлено, выполнить указанное действие</summary>
            <param name="execute">Действие, которое требуется выполнить в случае если значение свойства было установлено</param>
            <returns>Истина, если значение свойства было установлено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Then(System.Action{`0})">
            <summary>В случае если значение было установлено, выполнить указанное действие над новым значением</summary>
            <param name="execute">Действие над значением, которое требуется выполнить в случае если значение свойства было установлено</param>
            <returns>Истина, если значение свойства было установлено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Then(System.Action{`0,`0})">
            <summary>В случае если значение было установлено, выполнить указанное действие над старым и новым значением</summary>
            <param name="execute">Действие над старым и новым значением, которое требуется выполнить в случае если значение свойства было установлено</param>
            <returns>Истина, если значение свойства было установлено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Update(System.String)">
            <summary>Выполнить генерацию события обновления указанного свойства</summary>
            <param name="PropertyName">Имя свойства, которое также изменилось</param>
            <returns>Текущий объект установки значения</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Update(System.String[])">
            <summary>Выполнить генерацию события обновления для указанных свойств</summary>
            <param name="PropertyName">Массив имён изменившихся свойств</param>
            <returns>Текущий объект установки значения</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action)">
            <summary>Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет</summary>
            <param name="execute">Действие, которое требуется выполнить</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{System.Boolean})">
            <summary>
            Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет.
            Параметр действия - флаг, сигнализирующий о том, было ли изменено свойство
            </summary>
            <param name="execute">Действие, которое требуется выполнить</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{`0})">
            <summary>Выполнить действие с новым значением вне зависимости от того, изменилось оно, или нет</summary>
            <param name="execute">Действие, которое требуется выполнить с параметром в виде значения свойства</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{`0,System.Boolean})">
            <summary>
            Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет.
            Параметры действия - флаг, сигнализирующий о том, было ли изменено свойство, и значение свойства
            </summary>
            <param name="execute">Действие, которое требуется выполнить над значением свойства</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{`0,`0})">
            <summary>
            Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет.
            Параметры действия - предыдущее и текущее значение свойства
            </summary>
            <param name="execute">Действие, которое требуется выполнить над значением свойства</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.AnywayThen(System.Action{`0,`0,System.Boolean})">
            <summary>
            Выполнить действие вне зависимости от того, изменилось ли значение свойства, или нет.
            Параметры действия - предыдущее и текущее значение свойства, а также признак изменения значения
            </summary>
            <param name="execute">Действие, которое требуется выполнить над значением свойства</param>
            <returns>Истина, если свойство было изменено</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.Equals(MathCore.ViewModels.ViewModel.SetValueResult{`0})">
            <summary>Indicates whether this instance and a specified object are equal.</summary>
            <param name="other">The object to compare with the current instance.</param>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.op_Equality(MathCore.ViewModels.ViewModel.SetValueResult{`0},MathCore.ViewModels.ViewModel.SetValueResult{`0})">
            <summary>Оператор равенства двух значений</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValueResult`1.op_Inequality(MathCore.ViewModels.ViewModel.SetValueResult{`0},MathCore.ViewModels.ViewModel.SetValueResult{`0})">
            <summary>Оператор неравенства двух значений</summary>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValue``1(``0@,``0,System.String)">
            <summary>Установить значение свойства</summary>
            <param name="field">Поле свойства</param>
            <param name="value">Устанавливаемое значение</param>
            <param name="PropertyName">Имя свойства (если пусто, то будет взято имя метода, откуда выполняется запуск)</param>
            <typeparam name="T">Тип значения</typeparam>
            <returns>Объект, отвечающий за обработку результата установки значения</returns>
        </member>
        <member name="M:MathCore.ViewModels.ViewModel.SetValue``1(``0@,``0,System.Func{``0,System.Boolean},System.String)">
            <summary>Установить значение свойства</summary>
            <param name="field">Поле свойства</param>
            <param name="value">Устанавливаемое значение</param>
            <param name="Validator">Метод проверки корректности значения, передаваемого в свойство</param>
            <param name="PropertyName">Имя свойства (если пусто, то будет взято имя метода, откуда выполняется запуск)</param>
            <typeparam name="T">Тип значения</typeparam>
            <returns>Объект, отвечающий за обработку результата установки значения</returns>
        </member>
        <member name="T:MathCore.Xml.LambdaXmlSerializer">
            <summary>Настраиваемый сериализатор объектов в XML</summary>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer.Create``1(System.String)">
            <summary>Создать новый сериализатор объектов</summary>
            <typeparam name="T">Тип сериализуемого класса</typeparam>
            <param name="RootName">Имя корневого элемента (если не указано, то будет использовано имя класса)</param>
            <returns>Сериализатор</returns>
        </member>
        <member name="T:MathCore.Xml.LambdaXmlSerializer`1">
            <summary>Настраиваемый сериализатор объектов в XML</summary>
            <typeparam name="T">Тип сериализуемого класса</typeparam>
        </member>
        <member name="F:MathCore.Xml.LambdaXmlSerializer`1.__EmptyName">
            <summary>Название элемента по умолчанию</summary>
        </member>
        <member name="P:MathCore.Xml.LambdaXmlSerializer`1.EmptyName">
            <summary>Название элемента по умолчанию</summary>
        </member>
        <member name="F:MathCore.Xml.LambdaXmlSerializer`1._ElementName">
            <summary>Название элемента</summary>
        </member>
        <member name="F:MathCore.Xml.LambdaXmlSerializer`1._Attributes">
            <summary>Список методов формирования атрибутов элемента</summary>
        </member>
        <member name="F:MathCore.Xml.LambdaXmlSerializer`1._Elements">
            <summary>Список методов формирования дочерних элементов</summary>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.#ctor(System.String)">
            <summary>Инициализация нового настраиваемого сериализатора</summary>
            <param name="ElementName">Название корневого элемента</param>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Serialize(`0)">
            <summary>Выполнение процесса сериализации</summary>
            <param name="value">Сериализуемый объект</param>
            <returns>xml-представление сериализуемого объекта</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Serialize(System.String,`0)">
            <summary>Выполнение процесса сериализации</summary>
            <param name="Name">Название корневого элемента</param>
            <param name="value">Сериализуемый объект</param>
            <returns>xml-представление сериализуемого объекта</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Content(`0)">
            <summary>Формирование содержимого элемента</summary>
            <remarks>Выполнение списков методов вычисления значений атрибутов, затем - дочерних элементов</remarks>
            <param name="value">Сериализуемый объект</param>
            <returns>Перечисление атрибутов и дочерних элементов, вкладываемых в корневой элемент</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attribute``1(System.String,System.Func{`0,``0})">
            <summary>Добавление конфигурации атрибута</summary>
            <typeparam name="TValue">ТИп значения атрибута</typeparam>
            <param name="Name">Имя атрибута</param>
            <param name="Selector">Метод определения значения атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{``0,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута</param>
            <param name="NeedToSerialize">Метод, определяющий - требуется ли выполнять сериализацию конкретного значения в атрибут?</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Func{``0,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута в том числе по порядковому номеру</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута в том числе по порядковому номеру</param>
            <param name="NeedToSerialize">Метод, определяющий - требуется ли выполнять сериализацию конкретного значения в атрибут?</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{``0,System.Int32,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута в том числе</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута по порядковому номеру</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Attributes``2(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Func{``0,System.Boolean},System.Func{``0,System.Int32,``1})">
            <summary>Добавление конфигурации атрибутов</summary>
            <typeparam name="TItem">Тип данных сериализуемого элемента</typeparam>
            <typeparam name="TValue">Тип значения атрибута</typeparam>
            <param name="Selector">Метод определения набора данных, который должен быть упакован в атрибуты</param>
            <param name="NameSelector">Метод определения имени каждого конкретного атрибута в том числе</param>
            <param name="NeedToSerialize">Метод, определяющий - требуется ли выполнять сериализацию конкретного значения в атрибут?</param>
            <param name="ValueSelector">Метод определения значения каждого конкретного атрибута по порядковому номеру</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Element``1(System.String,System.Func{`0,``0})">
            <summary>Добавление конфигурации элемента</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="Selector">Метод определения значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Element``1(System.String,System.Func{`0,``0},System.Func{``0,System.Boolean})">
            <summary>Добавление конфигурации элемента</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="Selector">Метод определения значения элемента</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Element``1(System.String,System.Func{`0,``0},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации элемента</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="Selector">Метод определения значения элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Element``1(System.String,System.Func{`0,``0},System.Func{``0,System.Boolean},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации элемента</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="Selector">Метод определения значения элемента</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.String,System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.String,System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Boolean},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="Name">Имя элемента</param>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NameSelector">Метод определения имени элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.String},System.Func{``0,System.Boolean},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NameSelector">Метод определения имени элемента</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NameSelector">Метод определения имени элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Elements``1(System.Func{`0,System.Collections.Generic.IEnumerable{``0}},System.Func{``0,System.Int32,System.String},System.Func{``0,System.Boolean},System.Action{MathCore.Xml.LambdaXmlSerializer{``0}})">
            <summary>Добавление конфигурации набора элементов</summary>
            <typeparam name="TValue">Тип данных значения элемента</typeparam>
            <param name="ElementsSelector">Метод определения набора значений элементов для сериализации</param>
            <param name="NameSelector">Метод определения имени элемента</param>
            <param name="NeedToSerialize">Метод, определяющий - нужно ли выполнять сериализацию данного элемента</param>
            <param name="Configurator">Конфигурация сериализатора значения элемента</param>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Value">
            <summary>Добавление конфигурации, устанавливающий необходимость включения значения сериализуемого объекта</summary>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Value``1(``0)">
            <summary>Добавление конфигурации, устанавливающий необходимость включения указанного значения</summary>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="M:MathCore.Xml.LambdaXmlSerializer`1.Value``1(System.Func{`0,``0})">
            <summary>Добавление конфигурации, устанавливающий необходимость включения значения, определяемого на основе сериализуемого объекта</summary>
            <returns>Исходный сериализатор</returns>
        </member>
        <member name="T:MathCore.XmlInitializer`1">
            <summary>Инициализатор объекта по структуре xml-файла</summary>
            <typeparam name="TObject">Тип инициализируемого объекта</typeparam>
        </member>
        <member name="T:MathCore.XmlInitializer`1.Rule">
            <summary>Правило инициализации</summary>
        </member>
        <member name="F:MathCore.XmlInitializer`1.Rule._XPath">
            <summary>XPath-выражение - путь в структуре xml</summary>
        </member>
        <member name="F:MathCore.XmlInitializer`1.Rule._PropertyBody">
            <summary>Выражение, применяемое при обнаружении значения указанного XPath-пути</summary>
        </member>
        <member name="F:MathCore.XmlInitializer`1.Rule._Update">
            <summary>Скомпилированный метод инициализации</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Rule.UpdateExpression">
            <summary>Выражение, применяемое при обнаружении значения указанного XPath-пути</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Rule.XPath">
            <summary>XPath-выражение - путь в структуре xml</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Rule.IsObjectLess">
            <summary>Правилу не нужен объект</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Rule.Update">
            <summary>Скомпилированный метод инициализации</summary>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`0,System.String}},System.Boolean)">
            <summary>Инициализация нового правила</summary>
            <param name="XPath">XPath-путь в структуре xml</param>
            <param name="Expression">Выражение инициализации</param>
            <param name="IsObjectLess">Правилу не нужен объект</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule.Execute(`0,System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Выполнить инициализацию</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="e">Корень структуры xml</param>
            <param name="ns">Описание пространств имён</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule.Execute(System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Выполнить инициализацию</summary>
            <param name="e">Корень структуры xml</param>
            <param name="ns">Описание пространств имён</param>
        </member>
        <member name="T:MathCore.XmlInitializer`1.Rule`1">
            <summary>Типизированное правило инициализации</summary>
            <typeparam name="TValue">Тип значения инициализируемого параметра объекта</typeparam>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.GetExpression(System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Получить выражение инициализации для выражения определения свойства</summary>
            <param name="expression">Выражение определения инициализируемого параметра объекта</param>
            <param name="ValueConverterExpression">Выражение преобразования строки в тип объекта</param>
            <returns>Выражение инициализации, как процедура с параметром - объектом и строкой xml-узла</returns>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.GetExpression(System.Linq.Expressions.Expression{System.Action{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Получить выражение инициализации объекта по выражению инициализации и выражению конвертера</summary>
            <param name="expression">Выражение инициализации</param>
            <param name="ValueConverterExpression">Конвертер преобразования строки в нужный тип данных</param>
            <returns>Выражение инициализации объекта по строке xml-структуры</returns>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.#ctor(System.String,System.Linq.Expressions.Expression{System.Func{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1.Rule`1"/></summary>
            <param name="XPath">Путь к значению внутри xml-файла</param>
            <param name="expression">Выражение преобразования значения объекта инициализации к типу <typeparamref name="TValue"/>, выполняемое для инициализации значения объекта</param>
            <param name="converter">Выражение преобразования строкового типа значения из xml-файла в <typeparamref name="TValue"/></param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`0,`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1.Rule`1"/></summary>
            <param name="XPath">Путь к значению внутри xml-файла</param>
            <param name="expression">Выражение действия над объектом инициализации и типом <typeparamref name="TValue"/>, выполняемое для присвоения значения</param>
            <param name="converter">Выражение преобразования строкового типа значения из xml-файла в <typeparamref name="TValue"/></param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`0,System.String}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1.Rule`1"/></summary>
            <param name="XPath">Путь к значению внутри xml-файла</param>
            <param name="expression">Выражение действия над объектом инициализации и типом <typeparamref name="TValue"/>, выполняемое для присвоения значения</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Rule`1.#ctor(System.String,System.Linq.Expressions.Expression{System.Action{`1}},System.Linq.Expressions.Expression{System.Func{System.String,`1}})">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1.Rule`1"/></summary>
            <param name="XPath">Путь к значению внутри xml-файла</param>
            <param name="expression">Выражение действия над объектом инициализации, выполняемое для присвоения значения</param>
            <param name="converter">Выражение преобразования строкового типа значения из xml-файла в <typeparamref name="TValue"/></param>
        </member>
        <member name="F:MathCore.XmlInitializer`1._Rules">
            <summary>Набор правил</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Count">
            <summary>Число правил инициализации</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Item(System.Int32)">
            <summary>Правило инициализации с указанным индексом</summary>
            <param name="i">Индекс правила инициализации в списке</param>
            <returns>Правило инициализации с указанным индексом</returns>
        </member>
        <member name="P:MathCore.XmlInitializer`1.Namespace">
            <summary>Менеджер пространств имён xml-файла</summary>
        </member>
        <member name="M:MathCore.XmlInitializer`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1"/></summary>
        </member>
        <member name="M:MathCore.XmlInitializer`1.#ctor(MathCore.XmlInitializer{`0}.Rule[])">
            <summary>Инициализация нового экземпляра <see cref="T:MathCore.XmlInitializer`1"/></summary>
            <param name="Rules">Список правил инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.Linq.XDocument)">
            <summary>Инициализировать объект</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="xml">Xml-документ - источник данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.Linq.XElement)">
            <summary>Инициализировать объект</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="xml">Узел Xml-документа - источник данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(System.Xml.Linq.XDocument,System.Xml.IXmlNamespaceResolver)">
            <summary>Инициализировать объект</summary>
            <param name="xml">Xml-документ - источник данных процесса инициализации</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.Linq.XDocument,System.Xml.IXmlNamespaceResolver)">
            <summary>Инициализировать объект</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="xml">Xml-документ - источник данных процесса инициализации</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Инициализировать объект</summary>
            <param name="obj">Инициализируемый объект</param>
            <param name="xml">Узел Xml-документа - источник данных процесса инициализации</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(System.Xml.Linq.XElement,System.Xml.IXmlNamespaceResolver)">
            <summary>Инициализировать объект</summary>
            <param name="xml">Узел Xml-документа - источник данных процесса инициализации</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.XmlReader)">
            <summary>Инициализировать объект данными из xml-документа</summary>
            <param name="obj">инициализируемый объект</param>
            <param name="xml">Объект чтения xml-документа</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Initialize(`0,System.Xml.XmlReader,System.Xml.XmlNamespaceManager)">
            <summary>Инициализировать объект данными из xml-документа</summary>
            <param name="obj">инициализируемый объект</param>
            <param name="xml">Объект чтения xml-документа</param>
            <param name="XmlNamespace">Пространство имён данных процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{System.String,``0}})">
            <summary>Добавить правило с указанием выражения получения члена объекта</summary>
            <typeparam name="TPropertyValue">Тип значения свойства</typeparam>
            <param name="XPath">Путь в xml-структуре</param>
            <param name="InitializationExpression">Выражение, определяющее член объекта</param>
            <param name="DataConverterExpression">Выражение преобразования строки в целевой тип данных</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add``1(System.String,System.Linq.Expressions.Expression{System.Action{`0,``0}},System.Linq.Expressions.Expression{System.Func{System.String,``0}})">
            <summary>Добавить правило инициализации объекта <typeparamref name="TObject"/></summary>
            <param name="XPath">Путь к данным внутри xml-файла</param>
            <param name="InitializationExpression">Выражение, определяющее как записать данные в объект после извлечения их из xml-файла</param>
            <param name="DataConverterExpression">Выражение, определяющее как требуется преобразовать строку, полученную из xml-файла в тип данных, необходимый объекту</param>
            <typeparam name="TArgument">Тип устанавливаемого значения для объекта инициализации</typeparam>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add(System.String,System.Linq.Expressions.Expression{System.Action{`0,System.String}},System.Linq.Expressions.Expression{System.Func{System.String,System.String}})">
            <summary>Добавить правило инициализации</summary>
            <param name="XPath">Путь к данным внутри xml-файла</param>
            <param name="InitializationExpression">Выражение, определяющее как записать строку в объект после извлечения её из xml-файла</param>
            <param name="DataConverterExpression">Выражение, определяющее как требуется преобразовать строку, полученную из xml-файла в строку, необходимую объекту</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add``1(System.String,System.Linq.Expressions.Expression{System.Action{``0}},System.Linq.Expressions.Expression{System.Func{System.String,``0}})">
            <summary>Добавить правило инициализации без инициализируемого объекта</summary>
            <param name="XPath">Путь к данным внутри xml-файла</param>
            <param name="InitializationExpression">Выражение, определяющее что требуется сделать с данными после извлечения их из xml-файла</param>
            <param name="DataConverterExpression">Выражение, определяющее как требуется преобразовать строку, полученную из xml-файла в тип данных, необходимый объекту</param>
            <typeparam name="TArgument">Тип устанавливаемого значения для объекта инициализации</typeparam>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Add(System.String,System.Linq.Expressions.Expression{System.Action{System.String}},System.Linq.Expressions.Expression{System.Func{System.String,System.String}})">
            <summary>Добавить правило инициализации без инициализируемого объекта</summary>
            <param name="XPath">Путь к данным внутри xml-файла</param>
            <param name="InitializationExpression">Выражение, определяющее что требуется сделать со строкой после её извлечения из xml-файла</param>
            <param name="DataConverterExpression">Выражение, определяющее как требуется преобразовать строку, полученную из xml-файла в строку, необходимую для процесса инициализации</param>
        </member>
        <member name="M:MathCore.XmlInitializer`1.Clear">
            <summary>Удалить все правила инициализации</summary>
        </member>
        <member name="P:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#Add(MathCore.XmlInitializer{`0}.Rule)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#Contains(MathCore.XmlInitializer{`0}.Rule)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#CopyTo(MathCore.XmlInitializer{`0}.Rule[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#ICollection{MathCore#XmlInitializer{TObject}#Rule}#Remove(MathCore.XmlInitializer{`0}.Rule)">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:MathCore.XmlInitializer`1.System#Collections#Generic#IEnumerable{MathCore#XmlInitializer{TObject}#Rule}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:System.ActionsCollectionProcessor">
            <summary>Процессор, выполняющий действия</summary>
        </member>
        <member name="M:System.ActionsCollectionProcessor.#ctor(System.Collections.Generic.IEnumerable{System.Action})">
            <summary>Инициализация нового экземпляра <see cref="T:System.ActionsCollectionProcessor"/></summary>
            <param name="ActionsCollection">Перечисление действий, которые требуется выполнить</param>
        </member>
        <member name="M:System.ActionsCollectionProcessor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="M:System.ActionsCollectionProcessor.ProcessAction(System.Action)">
            <summary>Выполнить очередное действие</summary>
            <param name="action">Очередное действие из очереди действий, которые должен выполнить процессор</param>
        </member>
        <member name="T:System.AffectsTheAttribute">
            <summary>Влияние на</summary>
        </member>
        <member name="P:System.AffectsTheAttribute.Name">
            <summary>Элемент, на который оказывается влияние</summary>
        </member>
        <member name="M:System.AffectsTheAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.AffectsTheAttribute"/></summary>
        </member>
        <member name="M:System.AffectsTheAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.AffectsTheAttribute"/></summary>
            <param name="Name">Имя элемента, на что помеченный элемент оказывает влияние</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray``1(``0[],System.Range)">
            <summary>
            Slices the specified array using the specified range.
            </summary>
        </member>
        <member name="T:System.ChangedHandlerAttribute">
            <summary>Указывает процедуру без параметров, определённую в классе, которая должна быть вызвана после изменения значения свойства</summary>
        </member>
        <member name="P:System.ChangedHandlerAttribute.MethodName">
            <summary>Имя метода-реакции на изменение значения свойства</summary>
        </member>
        <member name="M:System.ChangedHandlerAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
        </member>
        <member name="M:System.ChangedHandlerAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="MethodName">Имя метода-реакции на изменение значения свойства</param>
        </member>
        <member name="T:System.CopyrightAttribute">
            <summary>Сведения об авторских правах на участок кода</summary>
        </member>
        <member name="P:System.CopyrightAttribute.Copyright">
            <summary>Авторские права</summary>
        </member>
        <member name="P:System.CopyrightAttribute.url">
            <summary>Ссылка на источник</summary>
        </member>
        <member name="M:System.CopyrightAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.CopyrightAttribute"/></summary>
            <param name="Copyright">Авторские права</param>
        </member>
        <member name="M:System.CopyrightAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.DependencyOnAttribute">
            <summary>Зависимость от</summary>
        </member>
        <member name="P:System.DependencyOnAttribute.Name">
            <summary>Элемент, от которого существует зависимость</summary>
        </member>
        <member name="M:System.DependencyOnAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
        </member>
        <member name="M:System.DependencyOnAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="Name">Имя элемента, от которого зависит помеченный элемент</param>
        </member>
        <member name="T:System.dValueAttribute">
            <summary>Допустимая величина изменения значения</summary>
        </member>
        <member name="P:System.dValueAttribute.dV">
            <summary>Допустимая величина изменения значения</summary>
        </member>
        <member name="M:System.dValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.dValueAttribute"/></summary>
        </member>
        <member name="M:System.dValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.dValueAttribute"/></summary>
            <param name="dV">Допустимая величина изменения значения</param>
        </member>
        <member name="T:System.ElementDescriptionAttribute">
            <summary>Описание</summary>
        </member>
        <member name="P:System.ElementDescriptionAttribute.Description">
            <summary>Описание</summary>
        </member>
        <member name="M:System.ElementDescriptionAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.ElementDescriptionAttribute"/></summary> 
        </member>
        <member name="M:System.ElementDescriptionAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.ElementDescriptionAttribute"/></summary>
            <param name="Description">Описание</param>
        </member>
        <member name="M:System.ElementDescriptionAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.GreaterOrEqualAttribute">
            <summary>Значение должно быть больше, либо равно</summary>
        </member>
        <member name="F:System.GreaterOrEqualAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.GreaterOrEqualAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
            <param name="Value">Пороговое значение</param>
        </member>
        <member name="M:System.GreaterOrEqualAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.GreaterThenAttribute">
            <summary>Значение должно быть больше, чем</summary>
        </member>
        <member name="F:System.GreaterThenAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.GreaterThenAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.GreaterThenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterThenAttribute"/></summary>
        </member>
        <member name="M:System.GreaterThenAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterThenAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="M:System.GreaterThenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.HyperlinkAttribute">
            <summary>Ссылка</summary>
        </member>
        <member name="P:System.HyperlinkAttribute.Link">
            <summary>Ссылка</summary>
        </member>
        <member name="M:System.HyperlinkAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.HyperlinkAttribute"/></summary>
        </member>
        <member name="M:System.HyperlinkAttribute.#ctor(System.String)">
            <summary>Инициализация нового экземпляра <see cref="T:System.HyperlinkAttribute"/></summary>
            <param name="Link">Текст ссылки</param>
        </member>
        <member name="M:System.HyperlinkAttribute.op_Implicit(System.HyperlinkAttribute)~System.Uri">
            <summary>Оператор неявного приведения типа <see cref="T:System.HyperlinkAttribute"/> к <see cref="T:System.Uri"/></summary>
            <param name="A">Атрибут ссылки, преобразуемый в <see cref="T:System.Uri"/></param>
        </member>
        <member name="T:System.IntervalValueAttribute">
            <summary>Допустимый интервал значений</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Min">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Max">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:System.IntervalValueAttribute.Interval">
            <summary>Допустимый интервал значений</summary>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor(MathCore.Interval)">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
            <param name="Interval">Допустимый интервал значений</param>
        </member>
        <member name="M:System.IntervalValueAttribute.#ctor(System.Double,System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.IntervalValueAttribute"/></summary>
            <param name="Min">Минимально допустимое значение</param>
            <param name="Max">Максимально допустимое значение</param>
        </member>
        <member name="T:System.LessOrEqualAttribute">
            <summary>Значение должно быть больше, либо равно</summary>
        </member>
        <member name="F:System.LessOrEqualAttribute._Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="P:System.LessOrEqualAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.LessOrEqualAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.LessOrEqualAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessOrEqualAttribute"/></summary>
            <param name="Value">Пороговое значение</param>
        </member>
        <member name="M:System.LessOrEqualAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.LessThenAttribute">
            <summary>Значение должно быть больше, чем</summary>
        </member>
        <member name="P:System.LessThenAttribute.Value">
            <summary>Пороговое значение</summary>
        </member>
        <member name="M:System.LessThenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessThenAttribute"/></summary>
        </member>
        <member name="M:System.LessThenAttribute.#ctor(System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.LessThenAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="M:System.LessThenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.MaxValueAttribute">
            <summary>Максимально допустимое значение</summary>
        </member>
        <member name="P:System.MaxValueAttribute.Value">
            <summary>Максимально допустимое значение</summary>
        </member>
        <member name="M:System.MaxValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.MaxValueAttribute"/></summary>
        </member>
        <member name="M:System.MaxValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.MaxValueAttribute"/></summary>
            <param name="Value">Максимально допустимое значение</param>
        </member>
        <member name="T:System.MinValueAttribute">
            <summary>Минимально допустимое значение</summary>
        </member>
        <member name="P:System.MinValueAttribute.Value">
            <summary>Минимально допустимое значение</summary>
        </member>
        <member name="M:System.MinValueAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.MinValueAttribute"/></summary>
        </member>
        <member name="M:System.MinValueAttribute.#ctor(System.Double)">
            <summary>Инициализация нового экземпляра <see cref="T:System.MinValueAttribute"/></summary>
            <param name="Value">Минимально допустимое значение</param>
        </member>
        <member name="T:System.NotImplementedAttribute">
            <summary>Атрибут признака нереализованности</summary>
        </member>
        <member name="P:System.NotImplementedAttribute.Message">
            <summary>Сообщение</summary>
        </member>
        <member name="M:System.NotImplementedAttribute.#ctor">
            <summary>Новый атрибут нереализованности</summary>
        </member>
        <member name="M:System.NotImplementedAttribute.#ctor(System.String)">
            <summary>Новый атрибут нереализованности</summary>
            <param name="Message">Сообщение (почему не реализовано?)</param>
        </member>
        <member name="M:System.NotImplementedAttribute.IsDefaultAttribute">
            <summary>Признак атрибута "по умолчанию"</summary>
            <returns>Истина, если указан незаполненный атрибут</returns>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.NotSupportedAttribute">
            <summary>Атрибут признака неподдерживаемости</summary>
        </member>
        <member name="P:System.NotSupportedAttribute.Message">
            <summary>Сообщение</summary>
        </member>
        <member name="M:System.NotSupportedAttribute.#ctor">
            <summary>Новый атрибут неподдерживаемости</summary>
        </member>
        <member name="M:System.NotSupportedAttribute.#ctor(System.String)">
            <summary>Новый атрибут неподдерживаемости</summary>
            <param name="Message">Сообщение (почему не поддерживается?)</param>
        </member>
        <member name="M:System.NotSupportedAttribute.IsDefaultAttribute">
            <summary>Признак атрибута "по умолчанию"</summary>
            <returns>Истина, если указан незаполненный атрибут</returns>
        </member>
        <member name="T:System.RegexPatternAttribute">
            <summary>Является регулярным выражением</summary>
        </member>
        <member name="T:System.ValueBetweenAttribute">
            <summary>Значение должно быть в диапазоне значений</summary>
        </member>
        <member name="F:System.ValueBetweenAttribute._Min">
            <summary>Нижнее пороговое значение</summary>
        </member>
        <member name="F:System.ValueBetweenAttribute._Max">
            <summary>Нижнее пороговое значение</summary>
        </member>
        <member name="P:System.ValueBetweenAttribute.Min">
            <summary>Нижнее пороговое значение</summary>
        </member>
        <member name="P:System.ValueBetweenAttribute.Max">
            <summary>Нижнее пороговое значение</summary>
        </member>
        <member name="M:System.ValueBetweenAttribute.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
        </member>
        <member name="M:System.ValueBetweenAttribute.#ctor(System.Object,System.Object)">
            <summary>Инициализация нового экземпляра <see cref="T:System.GreaterOrEqualAttribute"/></summary>
            <param name="Min">Минимальное значение</param>
            <param name="Max">Максимальное значение</param>
        </member>
        <member name="M:System.ValueBetweenAttribute.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.Collections.BitArrayExtensions">
            <summary>Класс методов-расширений для <see cref="T:System.Collections.BitArray"/></summary>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.Set(System.Collections.BitArray,System.Int32)">
            <summary>Установить значение бита с указанным индексом</summary>
            <param name="A">Массив бит</param>
            <param name="Value">Устанавливаемое состояние бита</param>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetInt8(System.Collections.BitArray)">
            <summary>Получить 8-битовое слово из массива бит</summary>
            <param name="A">Массив бит - источник данных</param>
            <returns>Байт, сформированный из массива бит</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetInt16(System.Collections.BitArray)">
            <summary>Получить 16-битовое слово из массива бит</summary>
            <param name="A">Массив бит - источник данных</param>
            <returns>Двухбайтовое целое со знаком, сформированный из массива бит</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetInt32(System.Collections.BitArray)">
            <summary>Получить 32-битовое слово из массива бит</summary>
            <param name="A">Массив бит - источник данных</param>
            <returns>Четырёхбайтное целое со знаком, сформированный из массива бит</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetInt64(System.Collections.BitArray)">
            <summary>Получить 64-битовое слово из массива бит</summary>
            <param name="A">Массив бит - источник данных</param>
            <returns>Восьмибайтное целое со знаком, сформированный из массива бит</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.ToBoolArray(System.Collections.BitArray)">
            <summary>Преобразовать массив бит в массив логических значений</summary>
            <param name="A">Массив бит - источник данных</param>
            <returns>Массив <see cref="T:System.Boolean"/></returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.Inverse(System.Collections.BitArray)">
            <summary>Инвертировать состояние бит массива</summary>
            <param name="A">Массив бит - источник данных</param>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetInversed(System.Collections.BitArray)">
            <summary>
            Сформировать новый массив бит,
            состояние каждого бита нового массива будет инвертированным по отношению к исходному массиву
            </summary>
            <param name="A">Массив бит - источник данных</param>
            <returns>Новый битовый массив, состояние бит которого обратно к состоянию бит исходного массива</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.IsPartyCorrect(System.Collections.BitArray,System.Boolean)">
            <summary>Проверка корректности чётности</summary>
            <param name="bits">Битовый массив</param>
            <param name="PartyBit">Бит чётности</param>
            <returns>Истина, если сумма бит по модулю 2 и бита чётности равна 0</returns>
        </member>
        <member name="M:System.Collections.BitArrayExtensions.GetBitSumMod2(System.Collections.BitArray)">
            <summary>Сумма бит по модулю 2</summary>
            <param name="bits">Битовый массив</param>
            <returns>Результат сложения бит массива по модулю 2</returns>
        </member>
        <member name="T:System.Collections.Generic.ICloneableExtensions">
            <summary>Класс методов-расширений для интерфейса <see cref="T:System.ICloneable"/></summary>
        </member>
        <member name="M:System.Collections.Generic.ICloneableExtensions.CloneObject``1(``0)">
            <summary>
            Клонировать объект <typeparamref name="T"/>
            (с возможностью последующей инициализации <see cref="T:System.IInitializable"/>, если интерфейс поддерживается)
            </summary>
            <typeparam name="T">Тип клонируемого объекта</typeparam>
            <param name="obj">Клонируемый объект</param>
            <returns>Клонированный объект</returns>
        </member>
        <member name="M:System.Collections.Generic.ICloneableExtensions.CloneObject``1(``0,System.Action{``0})">
            <summary>
            Клонировать объект <typeparamref name="T"/>
            (с возможностью последующей инициализации <see cref="T:System.IInitializable"/>, если интерфейс поддерживается)
            </summary>
            <typeparam name="T">Тип клонируемого объекта</typeparam>
            <param name="obj">Клонируемый объект</param>
            <param name="Initializer">Метод, вызываемый для клонированного объекта для его инициализации</param>
            <returns>Клонированный объект</returns>
        </member>
        <member name="M:System.Collections.Generic.ICloneableExtensions.CloneObject``2(``0,System.Action{``0,``1},``1)">
            <summary>
            Клонировать объект <typeparamref name="T"/>
            (с возможностью последующей инициализации <see cref="T:System.IInitializable"/>, либо <see cref="T:System.IInitializable`1"/>
            если интерфейсы поддерживается)
            </summary>
            <typeparam name="T">Тип клонируемого объекта</typeparam>
            <typeparam name="TParameter">Тип параметра процесса инициализации</typeparam>
            <param name="obj">Клонируемый объект</param>
            <param name="Initializer">Метод, вызываемый для клонированного объекта для его инициализации</param>
            <param name="parameter">Параметр процесса инициализации</param>
            <returns>Клонированный объект</returns>
        </member>
        <member name="M:System.Collections.Generic.ICloneableExtensions.CloneObject``2(``0,``1)">
            <summary>
            Клонировать объект <typeparamref name="T"/> 
            с последующей инициализацией <see cref="T:System.IInitializable"/>, либо <see cref="T:System.IInitializable`1"/>
            </summary>
            <typeparam name="T">Тип клонируемого объекта</typeparam>
            <typeparam name="TParameter">Тип параметра процесса инициализации</typeparam>
            <param name="obj">Клонируемый объект</param>
            <param name="parameter">Параметр процесса инициализации</param>
            <returns>Клонированный объект</returns>
        </member>
        <member name="T:System.Collections.Generic.ICollectionExtensions">
            <summary>Класс методов-расширений для интерфейса коллекции <see cref="T:System.Collections.Generic.ICollection`1"/></summary>
        </member>
        <member name="M:System.Collections.Generic.ICollectionExtensions.AddItems``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пакетное добавление элементов в коллекцию</summary>
            <typeparam name="T">Тип добавляемых элементов</typeparam>
            <param name="collection">Коллекция, в которую надо добавить перечисленных элементы</param>
            <param name="items">Перечисление добавляемых элементов</param>
        </member>
        <member name="M:System.Collections.Generic.ICollectionExtensions.RemoveItemsLazy``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пакетное ленивое удаление элементов из коллекции. Элементы будут удалены лишь при перечислении результатов удаления</summary>
            <typeparam name="T">Тип удаляемых элементов</typeparam>
            <param name="collection">Коллекция, из которой требуется удалить перечисленные элементы</param>
            <param name="items">Перечисление удаляемых из коллекции элементов</param>
            <returns>Перечисление результатов удаления элементов</returns>
        </member>
        <member name="M:System.Collections.Generic.ICollectionExtensions.RemoveItemsWithResults``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пакетное удаление элементов из коллекции</summary>
            <typeparam name="T">Тип удаляемых элементов</typeparam>
            <param name="collection">Коллекция, из которой требуется удалить перечисленные элементы</param>
            <param name="items">Перечисление удаляемых из коллекции элементов</param>
            <returns>Перечисление результатов удаления элементов</returns>
        </member>
        <member name="M:System.Collections.Generic.ICollectionExtensions.RemoveItems``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пакетное удаление элементов из коллекции</summary>
            <typeparam name="T">Тип удаляемых элементов</typeparam>
            <param name="collection">Коллекция, из которой требуется удалить перечисленные элементы</param>
            <param name="items">Перечисление удаляемых из коллекции элементов</param>
            <returns>Перечисление результатов удаления элементов</returns>
        </member>
        <member name="T:System.Collections.Generic.IDictionaryExtensions">
            <summary>Класс методов-расширений для интерфейса <see cref="T:System.Collections.Generic.IDictionary`2"/></summary>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>Деконструктор пары ключ-значение на составляющие</summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="item">Деконструируемое значение</param>
            <param name="key">Значение ключа</param>
            <param name="value">Значение значения</param>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}},``0,``1)">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="key">Ключ словаря типа <typeparamref name="TKey"/></param>
            <param name="value">Значение списка типа <typeparamref name="TValue"/></param>
            <typeparam name="TKey">Тип ключа словаря <paramref name="key"/></typeparam>
            <typeparam name="TValue">Тип значения списка значений <paramref name="value"/></typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``3(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``2}},``1,System.Func{``1,``0},System.Func{``1,``2})">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="obj">Объект-ключ словаря типа <typeparamref name="TObject"/></param>
            <param name="KeySelector">Метод образования ключа типа <typeparamref name="TKey"/> словаря из объекта типа <typeparamref name="TObject"/></param>
            <param name="ValueSelector">Метод образования значения типа <typeparamref name="TValue"/> из объекта типа <typeparamref name="TObject"/></param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TObject">Тип входного объекта</typeparam>
            <typeparam name="TValue">Тип значения списка</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValue``2(System.Collections.Generic.IDictionary{``0,System.Collections.Generic.IList{``1}},``1,System.Func{``1,``0})">
            <summary>Метод добавления значения в словарь списков значений</summary>
            <param name="dictionary">Словарь списков <see cref="T:System.Collections.Generic.IList`1"/> значений типа <typeparamref name="TValue"/></param>
            <param name="value">Значение, записываемое в словарь</param>
            <param name="KeySelector">Метод извлечения ключа из указанного значения</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения списка</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddValues``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>Добавление значений в словарь</summary>
            <param name="dictionary">Словарь в который надо добавить значения</param>
            <param name="collection">Коллекция добавляемых значений</param>
            <param name="converter">Метод определения ключа словаря для каждого из элементов коллекции</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.Dictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения по указанному ключу, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValueOrAddNew``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ значения, которое надо получить</param>
            <param name="creator">Метод получения нового значения, заносимого в словарь при отсутствии в нём указанного ключа</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Полученное из словаря по указанному ключу значение, либо созданное вновь и помещённое значение указанным методом</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``2(System.Collections.Generic.Dictionary{``0,``1},``0,``1)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ, значение для которого требуется получить</param>
            <param name="DefaultValue">Значение по-умолчанию, которое будет добавлено в словарь с указанным ключом, если он отсутствует</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа, либо указанное значение по-умолчанию</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="key">Ключ, значение для которого требуется получить</param>
            <param name="DefaultValue">Значение по-умолчанию, которое будет добавлено в словарь с указанным ключом, если он отсутствует</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа, либо указанное значение по-умолчанию</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.GetValue``1(System.Collections.Generic.Dictionary{System.String,System.Object},System.String)">
            <summary>Получить значение из словаря в случае его наличия, или добавить новое</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="name">Название объекта, значение для которого требуется получить</param>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Значение словаря для указанного ключа</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32,System.Func{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Int32,``2,System.Func{``2,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32,System.Func{System.Int32,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Int32,``2,System.Func{System.Int32,``2,System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="count">Количество добавляемых элементов</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="keys">Коллекция ключей</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.Initialize``3(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0},``2,System.Func{``0,``2,``1})">
            <summary>Инициализация словаря указанным методом для указанного числа значений</summary>
            <param name="dictionary">Инициализируемый словарь</param>
            <param name="keys">Коллекция ключей</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="initializer">Метод генерации новых элементов</param>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения словаря</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный словарь</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.RemoveWhere``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{System.Collections.Generic.KeyValuePair{``0,``1},System.Boolean})">
            <summary>Удаление из словаря элементов, удовлетворяющих предикату</summary>
            <param name="dictionary">Рассматриваемый словарь</param>
            <param name="selector">Метод отбора элементов</param>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <returns>Массив удалённых пар ключ-значение</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.RemoveItems``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>Удалить записи с перечисленными ключами</summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="dictionary">Словарь, из которого требуется удалить данные</param>
            <param name="keys">Перечисление удаляемых ключей</param>
            <returns>Массив удалённых значений</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.ToDictionary``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
            <summary>Преобразование перечисления кортежей двух элементов в словарь</summary>
            <typeparam name="TKey">Тип первого элемента кортежа - тип ключа</typeparam>
            <typeparam name="TValue">Тип второго элемента кортежа - тип значения</typeparam>
            <param name="items">Перечисление кортежей двух элементов</param>
            <returns>Словарь, составленный из ключей - первых элементов кортежа и значений - вторых элементов</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.ToSafeDictionary``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>Преобразовать в безопасный для ключей словарь</summary>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="Dictionary">Исходный словарь</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.AddIfNotExists``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>Добавить значение в словарь, если ключ отсутствует</summary>
            <typeparam name="TKey">Тип ключа</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="dictionary">Словарь</param>
            <param name="key">Ключ</param>
            <param name="value">Значение</param>
            <returns>Истина, если значение было добавлено</returns>
        </member>
        <member name="M:System.Collections.Generic.IDictionaryExtensions.ToPatternString``1(System.Collections.Generic.IDictionary{System.String,``0},System.String,System.IFormatProvider)">
            <summary>Преобразование словаря значений в строку по заданному шаблону</summary>
            <typeparam name="TValue">Тип значений словаря</typeparam>
            <param name="dictionary">Словарь с данными для заполнения шаблона</param>
            <param name="Pattern">Шаблон строки</param>
            <param name="FormatProvider">Формат</param>
            <returns>Строка по заданному шаблону</returns>
        </member>
        <member name="T:System.Collections.Generic.IListExtensions">
            <summary>Методы расширения для интерфейса <see cref="T:System.Collections.Generic.IList`1"/></summary>
        </member>
        <member name="M:System.Collections.Generic.IListExtensions.GetRandomizer``1(System.Collections.Generic.IList{``0},System.Random)">
            <summary>Создать генератор случных элементов</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <param name="Items">Список элементов, на основе которого надо создать генератор</param>
            <param name="Random">Датчик случайных чисел</param>
            <returns>Генератор случайного значения из элементов списка</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtensions.IsNullOrEmpty(System.Collections.IList)">
            <summary>Ссылка на список пуста, либо список не содержит элементов</summary>
            <param name="list">Проверяемый список</param>
            <returns>Истина, если не задана ссылка на список, либо список пуст</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtensions.Initialize``1(System.Collections.Generic.IList{``0},System.Int32,System.Func{System.Int32,``0},System.Boolean)">
            <summary>Метод расширения для инициализации списка</summary>
            <param name="list">Инициализируемый объект</param>
            <param name="Count">Требуемое число элементов</param>
            <param name="Initializator">Метод инициализации</param>
            <param name="ClearBefore">Очищать предварительно (по умолчанию)</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Инициализированный список</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtensions.Initialize``2(System.Collections.Generic.IList{``0},System.Int32,``1@,System.Func{System.Int32,``1,``0},System.Boolean)">
            <summary>Метод расширения для инициализации списка</summary>
            <param name="list">Инициализируемый объект</param>
            <param name="Count">Требуемое число элементов</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializator">Метод инициализации</param>
            <param name="ClearBefore">Очищать предварительно (по умолчанию)</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <returns>Инициализированный список</returns>
        </member>
        <member name="M:System.Collections.Generic.IListExtensions.Mix``1(System.Collections.Generic.IList{``0},System.Random)">
            <summary>Перемешать список</summary>
            <param name="list">Перемешиваемый список</param>
            <param name="rnd">Генератор случайных чисел</param>
            <typeparam name="T">Тип элементов списка</typeparam>
            <returns>Перемешанный исходный список</returns>
        </member>
        <member name="T:System.Collections.Generic.QueueExtensions">
            <summary>Методы-расширения для <see cref="T:System.Collections.Generic.Queue`1"/></summary>
        </member>
        <member name="M:System.Collections.Generic.QueueExtensions.Add``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>Добавить элемент в очередь</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
            <param name="queue">Очередь, в которую надо добавить элемент</param>
            <param name="value">Добавляемый элемент</param>
        </member>
        <member name="M:System.Collections.Generic.QueueExtensions.AddValue``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>Добавить элемент в очередь и вернуть модифицированную очередь в качестве результата</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
            <param name="queue">Очередь, в которую надо добавить элемент</param>
            <param name="value">Добавляемый элемент</param>
            <returns>Модифицированная очередь</returns>
        </member>
        <member name="M:System.Collections.Generic.QueueExtensions.ToStackReverse``1(System.Collections.Generic.Queue{``0})">
            <summary>Преобразовать очередь в стек в обратном порядке</summary>
            <typeparam name="T">Тип элементов очереди</typeparam>
            <param name="queue">Преобразуемая очередь</param>
            <returns>Стек из элементов очереди, взятых в обратном порядке</returns>
        </member>
        <member name="T:System.Collections.Generic.StackExtensions">
            <summary>Методы-расширения для <see cref="T:System.Collections.Generic.Stack`1"/></summary>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.Add``1(System.Collections.Generic.Stack{``0},``0)">
            <summary>Добавить элемент в стек</summary>
            <typeparam name="T">Тип элементов стека</typeparam>
            <param name="stack">Стек, в который надо добавить элемент</param>
            <param name="value">Добавляемый элемент</param>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.AddValue``1(System.Collections.Generic.Stack{``0},``0)">
            <summary>Добавить элемент в стек и вернуть модифицированный стек в качестве результата</summary>
            <typeparam name="T">Тип элементов стека</typeparam>
            <param name="stack">Стек, в который надо добавить элемент</param>
            <param name="value">Добавляемый элемент</param>
            <returns>Модифицированный стек</returns>
        </member>
        <member name="M:System.Collections.Generic.StackExtensions.ToQueueReverse``1(System.Collections.Generic.Stack{``0})">
            <summary>Преобразовать стек в инвертированную очередь</summary>
            <typeparam name="T">Тип элементов стека</typeparam>
            <param name="stack">Преобразуемый стек</param>
            <returns>Очередь из элементов стека, взятых в обратном порядке</returns>
        </member>
        <member name="F:System.Collections.Generic.ObservableLinkedList`1._List">
            <summary>Связный список элементов</summary>
        </member>
        <member name="P:System.Collections.Generic.ObservableLinkedList`1.Count">
            <summary>Число элементов</summary>
        </member>
        <member name="P:System.Collections.Generic.ObservableLinkedList`1.First">
            <summary>Первый элемент списка</summary>
        </member>
        <member name="P:System.Collections.Generic.ObservableLinkedList`1.Last">
            <summary>Последний элемент списка</summary>
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.Collections.Generic.ObservableLinkedList`1"/></summary>
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>Инициализация нового экземпляра <see cref="T:System.Collections.Generic.ObservableLinkedList`1"/></summary>
            <param name="collection">Исходная последовательность элементов, добавляемая в список при инициализации</param>
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.AddAfter(System.Collections.Generic.LinkedListNode{`0},`0)">
            <summary>Добавить элемент после указанного элемента</summary>
            <param name="PrevNode">Элемент, после которого надо добавить значение в список</param>
            <param name="value">Добавляемое значение</param>
            <returns>Новый элемент списка</returns>
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc />
        </member>
        <member name="M:System.Collections.Generic.ObservableLinkedList`1.OnDeserialization(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.GetEnumerator">
            <summary>
            Возвращает перечислитель, выполняющий перебор элементов в коллекции.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.IEnumerator`1"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Возвращает перечислитель, который осуществляет перебор элементов коллекции.
            </summary>
            <returns>
            Объект <see cref="T:System.Collections.IEnumerator"/>, который может использоваться для перебора элементов коллекции.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Добавляет элемент в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <param name="item">Объект, добавляемый в интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Clear">
            <summary>
            Удаляет все элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения. </exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Определяет, содержит ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> указанное значение.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> найден в <see cref="T:System.Collections.Generic.ICollection`1"/>; в противном случае — значение false.
            </returns>
            <param name="item">Объект, который требуется найти в <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Копирует элементы <see cref="T:System.Collections.Generic.ICollection`1"/> в массив <see cref="T:System.Array"/>, начиная с указанного индекса <see cref="T:System.Array"/>.
            </summary>
            <param name="array">Одномерный массив <see cref="T:System.Array"/>, в который копируются элементы из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>. Индексация в массиве <see cref="T:System.Array"/> должна начинаться с нуля.</param><param name="arrayIndex">Значение индекса (с нуля) в массиве <paramref name="array"/>, с которого начинается копирование.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="array"/> имеет значение null.</exception><exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="arrayIndex"/> меньше 0.</exception><exception cref="T:System.ArgumentException">Массив <paramref name="array"/> является многомерным.-или-
                            Значение индекса массива <paramref name="arrayIndex"/> больше или равно длине массива <paramref name="array"/>.-или-Количество элементов в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/> превышает размер доступного места, начиная с индекса <paramref name="arrayIndex"/> и до конца массива назначения <paramref name="array"/>.-или-Тип <paramref name="T"/> не может быть автоматически приведен к типу массива назначения <paramref name="array"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Удаляет первое вхождение указанного объекта из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Значение true, если объект <paramref name="item"/> успешно удален из <see cref="T:System.Collections.Generic.ICollection`1"/>, в противном случае — значение false. Этот метод также возвращает значение false, если параметр <paramref name="item"/> не найден в исходном интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            <param name="item">Объект, который необходимо удалить из интерфейса <see cref="T:System.Collections.Generic.ICollection`1"/>.</param><exception cref="T:System.NotSupportedException">Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Count">
            <summary>
            Получает число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            <returns>
            Число элементов, содержащихся в интерфейсе <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.IsReadOnly">
            <summary>
            Получает значение, указывающее, доступен ли интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> только для чтения.
            </summary>
            <returns>
            Значение true, если интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/> доступен только для чтения, в противном случае — значение false.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.ContainsKey(`0)">
            <summary>
            Определяет, содержится ли элемент с указанным ключом в <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Значение true, если в <see cref="T:System.Collections.Generic.IDictionary`2"/> содержится элемент с данным ключом; в противном случае — значение false.
            </returns>
            <param name="key">Ключ, который требуется найти в <see cref="T:System.Collections.Generic.IDictionary`2"/>.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Add(`0,`1)">
            <summary>
            Добавляет элемент с указанными ключом и значением в <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">Объект, используемый в качестве ключа добавляемого элемента.</param><param name="value">Объект, используемый в качестве значения добавляемого элемента.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.ArgumentException">Элемент с таким ключом уже существует в <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.Remove(`0)">
            <summary>
            Удаляет элемент с указанным ключом из <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Значение true, если элемент успешно удален, в противном случае — значение false.  Этот метод также возвращает значение false, если параметр <paramref name="key"/> не найден в исходном объекте <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">Ключ элемента, который необходимо удалить.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.NotSupportedException">Объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="M:System.Collections.Generic.DictionaryReadOnly`2.TryGetValue(`0,`1@)">
            <summary>
            Получает значение, связанное с указанным ключом.
            </summary>
            <returns>
            Значение true, если объект, реализующий <see cref="T:System.Collections.Generic.IDictionary`2"/>, содержит элемент с указанным ключом, в противном случае — значение false.
            </returns>
            <param name="key">Ключ, значение которого необходимо получить.</param><param name="value">Этот метод возвращает значение, связанное с указанным ключом, если он найден; в противном случае — значение по умолчанию для данного типа параметра <paramref name="value"/>. Этот параметр передается не инициализированным.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Item(`0)">
            <summary>
            Получает или задает элемент с указанным ключом.
            </summary>
            <returns>
            Элемент с указанным ключом.
            </returns>
            <param name="key">Ключ элемента, который требуется получить или задать.</param><exception cref="T:System.ArgumentNullException">Параметр <paramref name="key"/> имеет значение null.</exception><exception cref="T:System.Collections.Generic.KeyNotFoundException">Свойство получено и параметр <paramref name="key"/> не найден.</exception><exception cref="T:System.NotSupportedException">Свойство задано, и объект <see cref="T:System.Collections.Generic.IDictionary`2"/> доступен только для чтения.</exception>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Keys">
            <summary>
            Получает интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий ключи <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий ключи объекта, который реализует <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="P:System.Collections.Generic.DictionaryReadOnly`2.Values">
            <summary>
            Получает интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий значения <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            Интерфейс <see cref="T:System.Collections.Generic.ICollection`1"/>, содержащий значения объекта, который реализует <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
        </member>
        <member name="T:System.EventArgs`1">
            <summary>Аргумент события с типизированным параметром</summary>
        </member>
        <member name="P:System.EventArgs`1.Argument">
            <summary>Параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`1.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`1"/></summary>
        </member>
        <member name="M:System.EventArgs`1.#ctor(`0)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`1"/></summary>
            <param name="Argument">Параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`1.ToString">
            <summary>Строковое представление аргумента события</summary>
        </member>
        <member name="M:System.EventArgs`1.op_Implicit(System.EventArgs{`0})~`0">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения</summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="M:System.EventArgs`1.op_Implicit(`0)~System.EventArgs{`0}">
            <summary>Оператор неявного преобразования типа хранимого значения в обёртку из аргумента события, содержащего это значение</summary>
            <param name="Argument">Объект аргумента события</param>
            <returns>Аргумент события</returns>
        </member>
        <member name="T:System.EventArgs`2">
            <summary>Аргумент события с 2 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
        </member>
        <member name="P:System.EventArgs`2.Argument1">
            <summary>1 параметр аргумента</summary>
        </member>
        <member name="P:System.EventArgs`2.Argument2">
            <summary>2 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`2.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`2"/></summary>
        </member>
        <member name="M:System.EventArgs`2.#ctor(`0,`1)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`2"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`2.Deconstruct(`0@,`1@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`2"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`2.op_Implicit(System.EventArgs{`0,`1})~System.ValueTuple{`0,`1}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`2"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`2"/></param>
            <returns>Кортеж из 2 параметров</returns>
        </member>
        <member name="M:System.EventArgs`2.op_Implicit(System.ValueTuple{`0,`1})~System.EventArgs{`0,`1}">
            <summary>Оператор неявного преобразования кортежа из 2 параметров к типу <see cref="T:System.EventArgs`2"/></summary>
            <param name="Args">Кортеж из 2 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`2"/></returns>
        </member>
        <member name="T:System.EventArgs`3">
            <summary>Аргумент события с 3 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
        </member>
        <member name="P:System.EventArgs`3.Argument3">
            <summary>3 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`3.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`3"/></summary>
        </member>
        <member name="M:System.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`3"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`3.Deconstruct(`0@,`1@,`2@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`3"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`3.op_Implicit(System.EventArgs{`0,`1,`2})~System.ValueTuple{`0,`1,`2}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`3"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`3"/></param>
            <returns>Кортеж из 3 параметров</returns>
        </member>
        <member name="M:System.EventArgs`3.op_Implicit(System.ValueTuple{`0,`1,`2})~System.EventArgs{`0,`1,`2}">
            <summary>Оператор неявного преобразования кортежа из 3 параметров к типу <see cref="T:System.EventArgs`3"/></summary>
            <param name="Args">Кортеж из 3 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`3"/></returns>
        </member>
        <member name="T:System.EventArgs`4">
            <summary>Аргумент события с 4 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
        </member>
        <member name="P:System.EventArgs`4.Argument4">
            <summary>4 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`4.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`4"/></summary>
        </member>
        <member name="M:System.EventArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`4"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`4.Deconstruct(`0@,`1@,`2@,`3@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`4"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`4.op_Implicit(System.EventArgs{`0,`1,`2,`3})~System.ValueTuple{`0,`1,`2,`3}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`4"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`4"/></param>
            <returns>Кортеж из 4 параметров</returns>
        </member>
        <member name="M:System.EventArgs`4.op_Implicit(System.ValueTuple{`0,`1,`2,`3})~System.EventArgs{`0,`1,`2,`3}">
            <summary>Оператор неявного преобразования кортежа из 4 параметров к типу <see cref="T:System.EventArgs`4"/></summary>
            <param name="Args">Кортеж из 4 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`4"/></returns>
        </member>
        <member name="T:System.EventArgs`5">
            <summary>Аргумент события с 5 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
        </member>
        <member name="P:System.EventArgs`5.Argument5">
            <summary>5 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`5.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`5"/></summary>
        </member>
        <member name="M:System.EventArgs`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`5"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`5.Deconstruct(`0@,`1@,`2@,`3@,`4@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`5"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`5.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4})~System.ValueTuple{`0,`1,`2,`3,`4}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`5"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`5"/></param>
            <returns>Кортеж из 5 параметров</returns>
        </member>
        <member name="M:System.EventArgs`5.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4})~System.EventArgs{`0,`1,`2,`3,`4}">
            <summary>Оператор неявного преобразования кортежа из 5 параметров к типу <see cref="T:System.EventArgs`5"/></summary>
            <param name="Args">Кортеж из 5 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`5"/></returns>
        </member>
        <member name="T:System.EventArgs`6">
            <summary>Аргумент события с 6 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
        </member>
        <member name="P:System.EventArgs`6.Argument6">
            <summary>6 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`6.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`6"/></summary>
        </member>
        <member name="M:System.EventArgs`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`6"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`6.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`6"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`6.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5})~System.ValueTuple{`0,`1,`2,`3,`4,`5}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`6"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`6"/></param>
            <returns>Кортеж из 6 параметров</returns>
        </member>
        <member name="M:System.EventArgs`6.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5})~System.EventArgs{`0,`1,`2,`3,`4,`5}">
            <summary>Оператор неявного преобразования кортежа из 6 параметров к типу <see cref="T:System.EventArgs`6"/></summary>
            <param name="Args">Кортеж из 6 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`6"/></returns>
        </member>
        <member name="T:System.EventArgs`7">
            <summary>Аргумент события с 7 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
            <typeparam name="TArgument7">Тип аргумента 7</typeparam>
        </member>
        <member name="P:System.EventArgs`7.Argument7">
            <summary>7 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`7.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`7"/></summary>
        </member>
        <member name="M:System.EventArgs`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`7"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
            <param name="Argument7">7 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`7.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@,`6@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`7"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
            <param name="Arg7">7 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`7.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5,`6})~System.ValueTuple{`0,`1,`2,`3,`4,`5,`6}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`7"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`7"/></param>
            <returns>Кортеж из 7 параметров</returns>
        </member>
        <member name="M:System.EventArgs`7.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})~System.EventArgs{`0,`1,`2,`3,`4,`5,`6}">
            <summary>Оператор неявного преобразования кортежа из 7 параметров к типу <see cref="T:System.EventArgs`7"/></summary>
            <param name="Args">Кортеж из 7 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`7"/></returns>
        </member>
        <member name="T:System.EventArgs`8">
            <summary>Аргумент события с 8 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
            <typeparam name="TArgument7">Тип аргумента 7</typeparam>
            <typeparam name="TArgument8">Тип аргумента 8</typeparam>
        </member>
        <member name="P:System.EventArgs`8.Argument8">
            <summary>8 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`8.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`8"/></summary>
        </member>
        <member name="M:System.EventArgs`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`8"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
            <param name="Argument7">7 параметр аргумента</param>
            <param name="Argument8">8 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`8.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@,`6@,`7@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`8"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
            <param name="Arg7">7 параметр аргумента</param>
            <param name="Arg8">8 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`8.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7})~System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7}}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`8"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`8"/></param>
            <returns>Кортеж из 8 параметров</returns>
        </member>
        <member name="M:System.EventArgs`8.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7}})~System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7}">
            <summary>Оператор неявного преобразования кортежа из 8 параметров к типу <see cref="T:System.EventArgs`8"/></summary>
            <param name="Args">Кортеж из 8 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`8"/></returns>
        </member>
        <member name="T:System.EventArgs`9">
            <summary>Аргумент события с 9 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
            <typeparam name="TArgument7">Тип аргумента 7</typeparam>
            <typeparam name="TArgument8">Тип аргумента 8</typeparam>
            <typeparam name="TArgument9">Тип аргумента 9</typeparam>
        </member>
        <member name="P:System.EventArgs`9.Argument9">
            <summary>9 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`9.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`9"/></summary>
        </member>
        <member name="M:System.EventArgs`9.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`9"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
            <param name="Argument7">7 параметр аргумента</param>
            <param name="Argument8">8 параметр аргумента</param>
            <param name="Argument9">9 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`9.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@,`6@,`7@,`8@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`9"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
            <param name="Arg7">7 параметр аргумента</param>
            <param name="Arg8">8 параметр аргумента</param>
            <param name="Arg9">9 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`9.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7,`8})~System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7,`8}}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`9"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`9"/></param>
            <returns>Кортеж из 9 параметров</returns>
        </member>
        <member name="M:System.EventArgs`9.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7,`8}})~System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <summary>Оператор неявного преобразования кортежа из 9 параметров к типу <see cref="T:System.EventArgs`9"/></summary>
            <param name="Args">Кортеж из 9 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`9"/></returns>
        </member>
        <member name="T:System.EventArgs`10">
            <summary>Аргумент события с 10 типизированными параметрами</summary>
            <typeparam name="TArgument1">Тип аргумента 1</typeparam>
            <typeparam name="TArgument2">Тип аргумента 2</typeparam>
            <typeparam name="TArgument3">Тип аргумента 3</typeparam>
            <typeparam name="TArgument4">Тип аргумента 4</typeparam>
            <typeparam name="TArgument5">Тип аргумента 5</typeparam>
            <typeparam name="TArgument6">Тип аргумента 6</typeparam>
            <typeparam name="TArgument7">Тип аргумента 7</typeparam>
            <typeparam name="TArgument8">Тип аргумента 8</typeparam>
            <typeparam name="TArgument9">Тип аргумента 9</typeparam>
            <typeparam name="TArgument10">Тип аргумента 10</typeparam>
        </member>
        <member name="P:System.EventArgs`10.Argument10">
            <summary>10 параметр аргумента</summary>
        </member>
        <member name="M:System.EventArgs`10.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`10"/></summary>
        </member>
        <member name="M:System.EventArgs`10.#ctor(`0,`1,`2,`3,`4,`5,`6,`7,`8,`9)">
            <summary>Инициализация нового экземпляра <see cref="T:System.EventArgs`10"/></summary>
            <param name="Argument1">1 параметр аргумента</param>
            <param name="Argument2">2 параметр аргумента</param>
            <param name="Argument3">3 параметр аргумента</param>
            <param name="Argument4">4 параметр аргумента</param>
            <param name="Argument5">5 параметр аргумента</param>
            <param name="Argument6">6 параметр аргумента</param>
            <param name="Argument7">7 параметр аргумента</param>
            <param name="Argument8">8 параметр аргумента</param>
            <param name="Argument9">9 параметр аргумента</param>
            <param name="Argument10">10 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`10.Deconstruct(`0@,`1@,`2@,`3@,`4@,`5@,`6@,`7@,`8@,`9@)">
            <summary>Деконструктор <see cref="T:System.EventArgs`10"/></summary>
            <param name="Arg1">1 параметр аргумента</param>
            <param name="Arg2">2 параметр аргумента</param>
            <param name="Arg3">3 параметр аргумента</param>
            <param name="Arg4">4 параметр аргумента</param>
            <param name="Arg5">5 параметр аргумента</param>
            <param name="Arg6">6 параметр аргумента</param>
            <param name="Arg7">7 параметр аргумента</param>
            <param name="Arg8">8 параметр аргумента</param>
            <param name="Arg9">9 параметр аргумента</param>
            <param name="Arg10">10 параметр аргумента</param>
        </member>
        <member name="M:System.EventArgs`10.op_Implicit(System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9})~System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7,`8,`9}}">
            <summary>Оператор неявного преобразования типа <see cref="T:System.EventArgs`10"/> к кортежу</summary>
            <param name="Args">Аргумент события <see cref="T:System.EventArgs`10"/></param>
            <returns>Кортеж из 10 параметров</returns>
        </member>
        <member name="M:System.EventArgs`10.op_Implicit(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7,`8,`9}})~System.EventArgs{`0,`1,`2,`3,`4,`5,`6,`7,`8,`9}">
            <summary>Оператор неявного преобразования кортежа из 10 параметров к типу <see cref="T:System.EventArgs`10"/></summary>
            <param name="Args">Кортеж из 10 параметров</param>
            <returns>Аргумент события <see cref="T:System.EventArgs`10"/></returns>
        </member>
        <member name="T:System.EventHandlerArgs`2">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandlerArgs`3">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TResult">Тип результата события</typeparam>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
            <returns>Результат события</returns>
        </member>
        <member name="T:System.EventHandler`2">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter">Тип параметра аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`3">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`4">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`5">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`6">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`7">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`8">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <typeparam name="TParameter7">Тип параметра 7 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`9">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <typeparam name="TParameter7">Тип параметра 7 аргумента события</typeparam>
            <typeparam name="TParameter8">Тип параметра 8 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`10">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <typeparam name="TParameter7">Тип параметра 7 аргумента события</typeparam>
            <typeparam name="TParameter8">Тип параметра 8 аргумента события</typeparam>
            <typeparam name="TParameter9">Тип параметра 9 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventHandler`11">
            <summary>Делегат обработчика события</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TParameter1">Тип параметра 1 аргумента события</typeparam>
            <typeparam name="TParameter2">Тип параметра 2 аргумента события</typeparam>
            <typeparam name="TParameter3">Тип параметра 3 аргумента события</typeparam>
            <typeparam name="TParameter4">Тип параметра 4 аргумента события</typeparam>
            <typeparam name="TParameter5">Тип параметра 5 аргумента события</typeparam>
            <typeparam name="TParameter6">Тип параметра 6 аргумента события</typeparam>
            <typeparam name="TParameter7">Тип параметра 7 аргумента события</typeparam>
            <typeparam name="TParameter8">Тип параметра 8 аргумента события</typeparam>
            <typeparam name="TParameter9">Тип параметра 9 аргумента события</typeparam>
            <typeparam name="TParameter10">Тип параметра 10 аргумента события</typeparam>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="T:System.EventSenderArgs`2">
            <summary>Аргумент события с типизированным параметром</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArg">Тип параметра аргумента</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`2.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`2.#ctor(`0,`1)">
            <summary>Новый аргумент события с типизированным параметром</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument">Параметр аргумента</param>
        </member>
        <member name="M:System.EventSenderArgs`2.ToString">
            <summary>
            Возвращает объект <see cref="T:System.String"/>, который представляет текущий объект <see cref="T:System.Object"/>.
            </summary>
            <returns>Объект <see cref="T:System.String"/>, представляющий текущий объект <see cref="T:System.Object"/>.</returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:System.EventSenderArgs`2.op_Implicit(System.EventSenderArgs{`0,`1})~`1">
            <summary>Оператор неявного преобразования аргумента события к типу содержащегося в нём значения </summary>
            <param name="Args">Аргумент события</param>
            <returns>Хранимый объект</returns>
        </member>
        <member name="T:System.EventSenderArgs`4">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArg1">Тип первого параметра</typeparam>
            <typeparam name="TArg2">Тип второго параметра</typeparam>
            <typeparam name="TArg3">Тип третьего параметра</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`4.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`4.#ctor">
            <summary>Новый аргумент события с тремя параметрами</summary>
        </member>
        <member name="M:System.EventSenderArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>Новый аргумент события с тремя параметрами</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
            <param name="Argument3">Третий аргумент события</param>
        </member>
        <member name="T:System.EventSenderArgs`3">
            <summary>Аргумент события с двумя типизированными параметрами</summary>
            <typeparam name="TSender">Тип источника события</typeparam>
            <typeparam name="TArg1">Тип первого параметра</typeparam>
            <typeparam name="TArg2">Тип второго параметра</typeparam>
        </member>
        <member name="P:System.EventSenderArgs`3.Sender">
            <summary>Источник события</summary>
        </member>
        <member name="M:System.EventSenderArgs`3.#ctor">
            <summary>Новый аргумент события с двумя параметрами</summary>
        </member>
        <member name="M:System.EventSenderArgs`3.#ctor(`0,`1,`2)">
            <summary>Новый аргумент события с двумя параметрами</summary>
            <param name="Sender">Источник события</param>
            <param name="Argument1">Первый аргумент события</param>
            <param name="Argument2">Второй аргумент события</param>
        </member>
        <member name="T:System.ExceptionEventHandler`1">
            <summary>Обработчик событий генерации исключения</summary>
            <param name="Sender">Источник события</param>
            <param name="Args">Аргументы события</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="T:System.ExceptionEventHandlerExtensions">
            <summary>Класс методов расширений для обработчика событий генерации исключений</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerExtensions.Start``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0})">
            <summary>Генерация события обработки исключения</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtensions.StartAsync``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0},System.AsyncCallback,System.Object)">
            <summary>Асинхронная генерация события обработки исключения</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <param name="CallBack">Делегат завершения вызова события</param>
            <param name="State">Объект состояния, передаваемый в обработчик завершающего метода</param>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtensions.FastStart``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0})">
            <summary>Быстрый запуск события без учёта многопоточных компонентов</summary>
            <param name="Handler">Обработчики события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <typeparam name="TException">Тип события</typeparam>
        </member>
        <member name="M:System.ExceptionEventHandlerExtensions.ThrowIfUnhandled``1(System.ExceptionEventHandler{``0},System.Object,System.ExceptionEventHandlerArgs{``0},System.Nullable{System.Boolean})">
            <summary>
            Вызвать <typeparamref name="TException">исключение</typeparamref>, 
            если обработчики его не обработали, либо если кто-либо из обработчиков принял решение вызвать исключение
            </summary>
            <param name="Handler">Обработчики событий</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <param name="IsHandledDefault">
            Если истина, то исключение считается обработанным до тех пор, пока обработчик события не укажет обратного
            Если ложь, то обработчики должны явно указать, что исключение обработано.
            По умолчанию значение не определено (= null) - при наличии обработчиков у события исключение считается обработанным. Иначе оно генерируется. 
            </param>
            <typeparam name="TException">Тип исключения</typeparam>
            <exception cref="T:System.Exception"><typeparamref name="TException">Исключение</typeparamref> генерируется при отсутствии обработки его обработчиками события</exception>
        </member>
        <member name="T:System.ExceptionEventHandlerArgs`1">
            <summary>Аргументы события исключения</summary>
            <typeparam name="TException">Тип исключения</typeparam>
        </member>
        <member name="F:System.ExceptionEventHandlerArgs`1._Unhandled">
            <summary>Флаг необходимости генерации исключения</summary>
        </member>
        <member name="F:System.ExceptionEventHandlerArgs`1._IsHandled">
            <summary>Флаг признака обработки исключения обработчиками</summary>
        </member>
        <member name="P:System.ExceptionEventHandlerArgs`1.IsHandled">
            <summary>Исключение обработано</summary>
        </member>
        <member name="P:System.ExceptionEventHandlerArgs`1.NeedToThrow">
            <summary>Признак необходимости генерации исключения</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.#ctor(`0)">
            <summary>Новый аргумент события генерации исключения</summary>
            <param name="Error">Исключение</param>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.Handled">
            <summary>Исключение обработано</summary>
        </member>
        <member name="M:System.ExceptionEventHandlerArgs`1.Unhandled">
            <summary>Исключение должно быть сгенерировано в любом случае</summary>
        </member>
        <member name="T:System.Linq.Expressions.AttributesExtractor">
            <summary>Объект, осуществляющий извлечение атрибута с указанным именем из информации о методе</summary>
        </member>
        <member name="F:System.Linq.Expressions.AttributesExtractor._Info">
            <summary>Информация о методе</summary>
        </member>
        <member name="P:System.Linq.Expressions.AttributesExtractor.Inherit">
            <summary>Искать в данных предков цепочки наследования классов/интерфейсов</summary>
        </member>
        <member name="P:System.Linq.Expressions.AttributesExtractor.Item(System.String)">
            <summary>Атрибут (если найден) с указанным именем</summary>
            <param name="Name">Имя искомого атрибута</param>
            <returns>Атрибут, с указанным именем, либо <see langword="null"/></returns>
        </member>
        <member name="P:System.Linq.Expressions.AttributesExtractor.Item(System.String,System.Boolean)">
            <summary>Атрибут (если найден) с указанным именем</summary>
            <param name="Name">Имя искомого атрибута</param>
            <param name="IsInherit">Искать в данных предков цепочки наследования классов/интерфейсов</param>
            <returns>Атрибут, с указанным именем, либо <see langword="null"/></returns>
        </member>
        <member name="P:System.Linq.Expressions.AttributesExtractor.Item(System.String,System.String)">
            <summary>Получить значение свойства атрибута, определяемое именем атрибута и именем свойства атрибута</summary>
            <param name="Name">Имя искомого атрибута</param>
            <param name="ValueName">Имя свойства атрибута, значение которого надо получить</param>
            <returns>Значение свойства атрибута, если тот был найден и если у него было найдено указанное свойство</returns>
        </member>
        <member name="M:System.Linq.Expressions.AttributesExtractor.#ctor(System.Reflection.MemberInfo)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Linq.Expressions.AttributesExtractor"/></summary>
            <param name="Info">Мета-информация о методе, для для которого надо осуществлять поиск атрибутов</param>
        </member>
        <member name="M:System.Linq.Expressions.AttributesExtractor.GetAttributes(System.String)">
            <summary>Получить все атрибуты с указанным именем</summary>
            <param name="Name">Имя искомых атрибутов</param>
            <returns>Перечисление атрибутов с указанным именем</returns>
        </member>
        <member name="M:System.Linq.Expressions.AttributesExtractor.GetAttributes(System.String,System.Boolean)">
            <summary>Получить все атрибуты с указанным именем</summary>
            <param name="Name">Имя искомых атрибутов</param>
            <param name="IsInherit">Искать в данных предков цепочки наследования классов/интерфейсов</param>
            <returns>Перечисление атрибутов с указанным именем</returns>
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitElementInitializer(System.Linq.Expressions.ElementInit)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitTypeIs(System.Linq.Expressions.TypeBinaryExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberAccess(System.Linq.Expressions.MemberExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberAssignment(System.Linq.Expressions.MemberAssignment)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberMemberBinding(System.Linq.Expressions.MemberMemberBinding)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberListBinding(System.Linq.Expressions.MemberListBinding)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitLambda(System.Linq.Expressions.LambdaExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitMemberInit(System.Linq.Expressions.MemberInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitListInit(System.Linq.Expressions.ListInitExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.CloningVisitor.VisitInvocation(System.Linq.Expressions.InvocationExpression)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Expressions.ExpressionMatrix">
            <summary>Матрица выражений NxM</summary>
            <remarks>
            i (первый индекс) - номер строки,<br/>
            j (второй индекс) - номер столбца<br/>
            ------------ j ----------><br/>
            | a11 a12 a13 a14 a15 a16 a1M<br/>
            | a21........................<br/>
            | a31........................<br/>
            | a41.......aij..............<br/>
            i a51........................<br/>
            | a61........................<br/>
            | aN1.....................aNM<br/>
            \/
            </remarks>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetUnitaryMatrix(System.Int32)">
            <summary>Получить единичную матрицу размерности NxN</summary>
            <param name="N">Размерность матрицы</param>
            <returns>Единичная матрица размерности NxN</returns>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._M">
            <summary>Число столбцов матриц</summary>
        </member>
        <member name="F:System.Linq.Expressions.ExpressionMatrix._Data">
            <summary>Элементы матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.N">
            <summary>Число строк матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.M">
            <summary>Число столбцов матрицы</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.Item(System.Int32,System.Int32)">
            <summary>Элемент матрицы</summary>
            <param name="i">Номер строки (элемента в столбце) 0..N-1</param>
            <param name="j">Номер столбца (элемента в строке) 0..M-1</param>
            <returns>Элемент матрицы</returns>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.Item(System.Int32)">
            <summary>Вектор-столбец</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы</returns>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsSquare">
            <summary>Матрица является квадратной матрицей</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsCol">
            <summary>Матрица является столбцом</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsRow">
            <summary>Матрица является строкой</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.IsDigit">
            <summary>Матрица является числом</summary>
        </member>
        <member name="P:System.Linq.Expressions.ExpressionMatrix.T">
            <summary>Транспонированная матрица</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Int32)">
            <summary>Матрица выражения</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32)">
            <summary>Квадратная матрица выражения</summary>
            <param name="N">Размерность</param>
        </member>
        <member name="T:System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator">
            <summary>Метод определения значения элемента матрицы выражения</summary>
            <param name="i">Номер строки</param>
            <param name="j">Номер столбца</param>
            <returns>Значение элемента матрицы M[<paramref name="i"/>, <paramref name="j"/>]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator)">
            <summary>Квадратная матрица выражения</summary>
            <param name="N">Размерность</param>
            <param name="CreateFunction">Порождающая функция</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.#ctor(System.Int32,System.Int32,System.Linq.Expressions.ExpressionMatrix.MatrixItemCreator)">
            <summary>Матрица выражения</summary>
            <param name="N">Число строк</param>
            <param name="M">Число столбцов</param>
            <param name="CreateFunction">Порождающая функция f(i,j) - i-строка, j-столбец</param>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetCol(System.Int32)">
            <summary>Получить столбец матрицы</summary>
            <param name="j">Номер столбца</param>
            <returns>Столбец матрицы номер j</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetRow(System.Int32)">
            <summary>Получить строку матрицы</summary>
            <param name="i">Номер строки</param>
            <returns>Строка матрицы номер i</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTriangle">
            <summary>Приведение матрицы к ступенчатому виду методом Гаусса</summary>
            <returns>Треугольная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetInverse">
            <summary>Получить обратную матрицу</summary>
            <returns>Обратная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTransvection(System.Int32)">
            <summary>Трансвекция матрицы</summary>
            <param name="col">Опорный столбец</param>
            <returns>Трансвекция матрицы А</returns>                    
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetTranspose">
            <summary>Транспонирование матрицы</summary>
            <returns>Транспонированная матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetAdjunct(System.Int32,System.Int32)">
            <summary>Алгебраическое дополнение к элементу [n,m]</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Алгебраическое дополнение к элементу [n,m]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetMinor(System.Int32,System.Int32)">
            <summary>Минор матрицы по определённому элементу</summary>
            <param name="n">Номер столбца</param>
            <param name="m">Номер строки</param>
            <returns>Минор элемента матрицы [n,m]</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetDeterminant">
            <summary>Определитель матрицы</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.Clone">
            <summary>Клонирование матрицы</summary>
            <returns>Копия текущей матрицы</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.System#ICloneable#Clone">
            <summary> Создает новый объект, который является копией текущего экземпляра</summary>
            <returns> Новый объект, являющийся копией этого экземпляра </returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Addition(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор сложения двух матриц</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Сумма двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Subtraction(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор разности двух матриц</summary>
            <param name="A">Уменьшаемое</param>
            <param name="B">Вычитаемое</param>
            <returns>Разность двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Multiply(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор произведения двух матриц</summary>
            <param name="A">Первый сомножитель</param>
            <param name="B">Второй сомножитель</param>
            <returns>Произведение двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Division(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Оператор деления двух матриц</summary>
            <param name="A">Делимое</param>
            <param name="B">Делитель</param>
            <returns>Частное двух матриц</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_BitwiseOr(System.Linq.Expressions.ExpressionMatrix,System.Linq.Expressions.ExpressionMatrix)">
            <summary>Конкатенация двух матриц (либо по строкам, либо по столбцам)</summary>
            <param name="A">Первое слагаемое</param>
            <param name="B">Второе слагаемое</param>
            <returns>Объединённая матрица</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.op_Implicit(System.Linq.Expressions.Expression)~System.Linq.Expressions.ExpressionMatrix">
            <summary>Оператор неявного приведения типа вещественного числа двойной точности к типу Матрица порядка 1х1</summary>
            <param name="X">Приводимое число</param><returns>Матрица порядка 1х1</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Expressions.ExpressionMatrix.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Expressions.ExpressionRebuilder">
            <summary>Пересборщик дерева выражения Linq.Expression</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.InvokeEvent``1(System.EventHandlerReturn{System.EventArgs{``0},System.Linq.Expressions.Expression},``0,System.Func{``0,System.Linq.Expressions.Expression})">
            <summary>Метод генерации события посещения узла типа Expression</summary>
            <typeparam name="TExpressionNode">Тип узла дерева</typeparam>
            <param name="Handlers">Событие</param>
            <param name="Node">Узел дерева</param>
            <param name="Base">Базовый метод обработки узла</param>
            <returns>Узел, которым надо заместить посещённый узел дерева</returns>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.InvokeEvent``2(System.EventHandlerReturn{System.EventArgs{``1},``1},``0,System.Func{``0,``1})">
            <summary>Метод генерации события посещения узла произвольного типа</summary>
            <typeparam name="TElement">Тип узла дерева</typeparam><typeparam name="TOut">Тип выходного узла</typeparam>
            <param name="Handlers">Событие</param>
            <param name="Node">Посещённый узел дерева</param>
            <param name="Base">Базовый метод обработки узла</param>
            <returns>Узел, которым надо заместить посещённый узел дерева</returns>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.Visited">
            <summary>Событие возникает при посещении любого узла дерева</summary>
        </member>
        <member name="M:System.Linq.Expressions.ExpressionRebuilder.Visit(System.Linq.Expressions.Expression)">
            <summary>Посетить узел дерева</summary><param name="Node">Узел дерева</param><returns>Новый узел дерева</returns>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BinaryVisited">
            <summary>Событие возникает при посещении узла дерева бинарного выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BindingVisited">
            <summary>Событие возникает при посещении узла привязки</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.BindingListVisited">
            <summary>Событие возникает при посещении коллекции привязки</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ConditionalVisited">
            <summary>Событие возникает при посещении узла условного оператора</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ConsonantVisited">
            <summary>Событие возникает при посещении узла константы</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ElementInitializerVisited">
            <summary>Событие возникает при посещении узла инициализатора объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ElementInitializerListVisited">
            <summary>Событие возникает при посещении коллекции инициализаторов объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ExpressionListVisited">
            <summary>Событие возникает при посещении коллекции выражений</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.LambdaVisited">
            <summary>Событие возникает при посещении лямбда-выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ListInitVisited">
            <summary>Событие возникает при посещении узла инициализатора коллекции</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.InvocationVisited">
            <summary>Событие возникает при посещении узла вызова функции</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberAccessVisited">
            <summary>Событие возникает при посещении узла доступа к члену объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberAssignmentVisited">
            <summary>Событие возникает при посещении узла присвоения члену объекта значения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberInitVisited">
            <summary>Событие возникает при посещении узла инициализатора свойства объекта</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberListBindingVisited">
            <summary>Событие возникает при посещении узла инициализатора коллекции объектов</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MemberMemberBindingVisited">
            <summary>Событие возникает при посещении узла инициализатора элементов элемента</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.MethodCallVisited">
            <summary>Событие возникает при посещении узла вызова метода</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.NewVisited">
            <summary>Событие возникает при посещении узла конструктора</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.NewArrayVisited">
            <summary>Событие возникает при посещении узла конструктора массива</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.ParameterVisited">
            <summary>Событие возникает при посещении узла параметра выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.TypeIsVisited">
            <summary>Событие возникает при посещении узла определения типа выражения</summary>
        </member>
        <member name="E:System.Linq.Expressions.ExpressionRebuilder.UnaryVisited">
            <summary>Событие возникает при посещении узла унарного выражения</summary>
        </member>
        <member name="T:System.Linq.Expressions.MultiplicationSign">
            <summary>TeX supports several styles for multiplication sign</summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.None">
            <summary>Without any sign</summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.Asterisk">
            <summary>* sign</summary>
        </member>
        <member name="F:System.Linq.Expressions.MultiplicationSign.Times">
            <summary>x sign</summary>
        </member>
        <member name="T:System.Linq.Expressions.Property`1">
            <summary>Свойство класса</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
        </member>
        <member name="E:System.Linq.Expressions.Property`1.PropertyChanged">
            <summary>Событие изменения свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения свойства</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._Reader">
            <summary>Метод чтения свойства</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property`1._Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.CanRead">
            <summary>Признак возможности чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.CanWrite">
            <summary>Признак возможности записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Reader">
            <summary>Метод чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.DescriptionAttribute">
            <summary>Свойство доступа к значению атрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property`1.IsNotifyPropertyChanged">
            <summary>Признак реализации объектом-хозяином свойства интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Type,System.String,System.Boolean)">
            <summary>Инициализация доступа к статическому свойству</summary>
            <param name="type">Рассматриваемый тип</param>
            <param name="Name">Имя статического свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Object,System.String,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="Name">Имя свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.#ctor(System.Object,System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="info">Информация о свойстве</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property`1.LoadAttributes">
            <summary>Чтение сведений из атрибутов</summary>
        </member>
        <member name="T:System.Linq.Expressions.Property">
            <summary>Свойство класса</summary>
        </member>
        <member name="E:System.Linq.Expressions.Property.PropertyChanged">
            <summary>Событие изменения свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property.OnPropertyChanged(System.String)">
            <summary>Метод генерации события изменения свойства</summary>
            <param name="PropertyName">Имя свойства</param>
        </member>
        <member name="F:System.Linq.Expressions.Property._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property._Reader">
            <summary>Метод чтения свойства</summary>
        </member>
        <member name="F:System.Linq.Expressions.Property._Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.CanRead">
            <summary>Признак возможности чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.CanWrite">
            <summary>Признак возможности записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Writer">
            <summary>Метод записи значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Reader">
            <summary>Метод чтения значения свойства</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.DescriptionAttribute">
            <summary>Свойство доступа к значению атрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.IsNotifyPropertyChanged">
            <summary>Признак реализации объектом-хозяином свойства интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="P:System.Linq.Expressions.Property.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Type,System.String,System.Boolean)">
            <summary>Инициализация доступа к статическому свойству</summary>
            <param name="type">Рассматриваемый тип</param>
            <param name="Name">Имя статического свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Object,System.String,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="Name">Имя свойства</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.#ctor(System.Object,System.Reflection.PropertyInfo,System.Boolean)">
            <summary>Инициализация доступа к свойству объекта</summary>
            <param name="Obj">Рассматриваемый объект</param>
            <param name="info">Информация о свойстве</param>
            <param name="IsPublicOnly">Признак публичности свойства</param>
        </member>
        <member name="M:System.Linq.Expressions.Property.LoadAttributes">
            <summary>Чтение сведений из атрибутов</summary>
        </member>
        <member name="T:System.Linq.Expressions.TeXEvaluationExpressionVisitor">
            <summary>Класс "посетителя" для "подстановки" актуальных значений в дерево выражения</summary>
        </member>
        <member name="T:System.Linq.Expressions.TeXExpressionVisitor">
            <summary>
            Класс "посетителя", который "изучает" дерево выражения путем переопределения соответствующих
            виртуальных методов базового класса System.Linq.Expressions.ExpressionVisitor
            </summary>
        </member>
        <member name="M:System.Linq.Expressions.TeXExpressionVisitor.VisitPrefixBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Оператор деления \fract требует иного порядка аргументов:
            \frac{arg1}{arg2} 
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="T:System.Linq.IEnumerableExtensions">
            <summary>Класс методов-расширений для интерфейса перечисления</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AverageWindow(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>Усреднение последовательности методом скользящего среднего с заданной длиной окна</summary>
            <param name="samples">Исходная последовательность</param>
            <param name="WindowLength">Длина окна выборки (должна быть больше 1)</param>
            <returns>Усреднённая последовательность если <paramref name="WindowLength"/> &gt; 1</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на <paramref name="samples"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">При <paramref name="WindowLength"/> &lt; 1</exception>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AverageMedian(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>Усреднение последовательности методом выбора медианы в окне выборки</summary>
            <param name="samples">Исходная последовательность</param>
            <param name="WindowLength">Длина окна выборки (должна быть больше 1)</param>
            <returns>Усреднённая последовательность если <paramref name="WindowLength"/> &gt; 1</returns>
            <exception cref="T:System.ArgumentNullException">Если отсутствует ссылка на <paramref name="samples"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">При <paramref name="WindowLength"/> &lt; 1</exception>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CountGreater``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Последовательность содержит число элементов больше указанного количества</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="items">Проверяемая последовательность элементов</param>
            <param name="Count">Пороговое значение числа элементов последовательности</param>
            <returns>Истина если число элементов последовательности больше указанного</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CountGreater``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Boolean})">
            <summary>Последовательность содержит число элементов больше указанного количества</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="items">Проверяемая последовательность элементов</param>
            <param name="Count">Пороговое значение числа элементов последовательности</param>
            <param name="Selector">Функция выборки элементов из последовательности, которые должны быть учтены</param>
            <returns>Истина если число элементов последовательности больше указанного</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CountGreaterOrEqual``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Последовательность содержит число элементов больше, либо равное указанному количеству элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="items">Проверяемая последовательность элементов</param>
            <param name="Count">Пороговое значение числа элементов последовательности</param>
            <returns>Истина если число элементов последовательности больше, либо равно указанному количеству</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CountGreaterOrEqual``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Boolean})">
            <summary>Последовательность содержит число элементов больше, либо равное указанному количеству элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="items">Проверяемая последовательность элементов</param>
            <param name="Count">Пороговое значение числа элементов последовательности</param>
            <param name="Selector">Функция выборки элементов из последовательности, которые должны быть учтены</param>
            <returns>Истина если число элементов последовательности больше, либо равно указанному количеству</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CountLess``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Последовательность содержит число элементов меньше указанного количества</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="items">Проверяемая последовательность элементов</param>
            <param name="Count">Пороговое значение числа элементов последовательности</param>
            <returns>Истина если число элементов последовательности меньше указанного</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CountLess``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Boolean})">
            <summary>Последовательность содержит число элементов меньше указанного количества</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="items">Проверяемая последовательность элементов</param>
            <param name="Count">Пороговое значение числа элементов последовательности</param>
            <param name="Selector">Функция выборки элементов из последовательности, которые должны быть учтены</param>
            <returns>Истина если число элементов последовательности меньше указанного</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CountLessOrEqual``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Последовательность содержит число элементов меньше, либо равное указанному количеству элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="items">Проверяемая последовательность элементов</param>
            <param name="Count">Пороговое значение числа элементов последовательности</param>
            <returns>Истина если число элементов последовательности меньше, либо равно указанному количеству</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CountLessOrEqual``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Func{``0,System.Boolean})">
            <summary>Последовательность содержит число элементов меньше, либо равное указанному количеству элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="items">Проверяемая последовательность элементов</param>
            <param name="Count">Пороговое значение числа элементов последовательности</param>
            <param name="Selector">Функция выборки элементов из последовательности, которые должны быть учтены</param>
            <returns>Истина если число элементов последовательности меньше, либо равно указанному количеству</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetHashSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Преобразовать последовательность в хеш-таблицу</summary>
            <typeparam name="T">Тип элемента последовательности</typeparam>
            <param name="items">Последовательность элементов, для которой надо создать хеш-таблицу</param>
            <returns>Новая хеш-таблица, созданная из указанной последовательности элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Distinct``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Перечисление без повторений значений, определяемых лямбда-выражением</summary>
            <typeparam name="T">Тип перечисляемых объектов</typeparam>
            <typeparam name="TKey">Тип ключа значения</typeparam>
            <param name="enumerable">Исходное перечисление объектов</param>
            <param name="KeySelector">Критерий определения повторения значения</param>
            <returns>Перечисление, из которого исключены повторения по указанному критерию</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Dispersion(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Дисперсия значений</summary>
            <param name="enumerable">Объект-источник данных</param>
            <returns>Дисперсия значений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Dispersion(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>Дисперсия значений</summary>
            <param name="enumerable">Объект-источник данных</param>
            <returns>Дисперсия значений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Dispersion(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>Дисперсия значений</summary>
            <param name="enumerable">Объект-источник данных</param>
            <returns>Дисперсия значений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Dispersion``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>Дисперсия значений</summary>
            <param name="enumerable">Объект-источник данных</param>
            <param name="Selector">Метод получения вещественного значения</param>
            <returns>Дисперсия значений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertBefore``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>Добавить элемент в начало последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="enumerable">Исходная последовательность элементов</param>
            <param name="values">Добавляемый элемент</param>
            <returns>Результирующая последовательность элементов, в которой добавленный элемент идёт на первом месте</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertBefore``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить элемент в начало последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="enumerable">Исходная последовательность элементов</param>
            <param name="values">Добавляемый элемент</param>
            <returns>Результирующая последовательность элементов, в которой добавленный элемент идёт на первом месте</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertAfter``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>Добавить элемент в конец последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Исходная последовательность элементов</param>
            <param name="values">Добавляемый элемент</param>
            <returns>Результирующая последовательность элементов, в которой добавленный элемент идёт на последнем месте</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertAfter``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить элемент в конец последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Исходная последовательность элементов</param>
            <param name="values">Добавляемый элемент</param>
            <returns>Результирующая последовательность элементов, в которой добавленный элемент идёт на последнем месте</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0)">
            <summary>Первый элемент перечисления, удовлетворяющий задаваемому критерию с параметром</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="enumerable">Перечисление элементов</param>
            <param name="Selector">Критерий отбора элементов перечисления с параметром</param>
            <param name="DefaultValue">Значение по умолчанию, возвращаемое если ни один из элементов перечисления не соответствует критерию</param>
            <returns>Первый найденный элемент в перечислении, удовлетворяющий критерию, либо значение по умолчанию</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.FirstOrDefault``2(System.Collections.Generic.IEnumerable{``0},``1@,System.Func{``0,``1,System.Boolean},``0@)">
            <summary>Первый элемент перечисления, удовлетворяющий задаваемому критерию с параметром</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <typeparam name="TP">Тип параметра</typeparam>
            <param name="enumerable">Перечисление элементов</param>
            <param name="p">Параметр, передаваемый в критерий, необходимый для устранения замыкания</param>
            <param name="Selector">Критерий отбора элементов перечисления с параметром</param>
            <param name="DefaultValue">Значение по умолчанию, возвращаемое если ни один из элементов перечисления не соответствует критерию</param>
            <returns>Первый найденный элемент в перечислении, удовлетворяющий критерию, либо значение по умолчанию</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.FirstOrDefault``3(System.Collections.Generic.IEnumerable{``0},``1@,``2@,System.Func{``0,``1,``2,System.Boolean},``0@)">
            <summary>Первый элемент перечисления, удовлетворяющий задаваемому критерию с параметром</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <typeparam name="TP1">Тип параметра 1</typeparam>
            <typeparam name="TP2">Тип параметра 2</typeparam>
            <param name="enumerable">Перечисление элементов</param>
            <param name="p1">Параметр 1, передаваемый в критерий, необходимый для устранения замыкания</param>
            <param name="p2">Параметр 2, передаваемый в критерий, необходимый для устранения замыкания</param>
            <param name="Selector">Критерий отбора элементов перечисления с параметром</param>
            <param name="DefaultValue">Значение по умолчанию, возвращаемое если ни один из элементов перечисления не соответствует критерию</param>
            <returns>Первый найденный элемент в перечислении, удовлетворяющий критерию, либо значение по умолчанию</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectMany``3(``0)">
            <summary>Сделать перечисление плоским (линейным)</summary>
            <param name="enumerable">Перечисление перечислений элементов</param>
            <typeparam name="TSource">Тип перечисления первого уровня</typeparam>
            <typeparam name="TSubSource">Тип перечисления второго уровня</typeparam>
            <typeparam name="TItem">Тип перечисления результатов</typeparam>
            <returns>Перечисление вложенных элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AsBlockEnumerable``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Boolean)">
            <summary>Сформировать блочный перечислитель элементов</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="enumerable">Перечисление элементов, которое требуется разбить на блоки</param>
            <param name="BlockSize">Размер блоков, не которые будет разбито исходное перечисление</param>
            <param name="CreateNewBlocks">Создавать новые блоки (не использовать один и тот же буфер)</param>
            <returns>Перечисление блоков элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Except``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Перечисление элементов за исключением указанного</summary>
            <param name="enumerable">Исходное перечисление</param>
            <param name="item">Элемент, исключаемый из перечисления</param>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <returns>Перечисление элементов за исключением указанного</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.FirstIndexOf``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary>Индекс первого найденного элемента</summary>
            <typeparam name="T">Тип искомого элемента</typeparam>
            <param name="enumerable">Перечисление элементов, в котором требуется найти заданный</param>
            <param name="item">Искомый элемент</param>
            <returns>Индекс первого вхождения элемента в перечисление, либо -1 в случае, если он в ней отсутствует</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.LastIndexOf``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <summary>Индекс последнего найденного элемента</summary>
            <typeparam name="T">Тип искомого элемента</typeparam>
            <param name="enumerable">Перечисление элементов, в котором требуется найти заданный</param>
            <param name="item">Искомый элемент</param>
            <returns>Индекс последнего вхождения элемента в перечисление, либо -1 в случае, если он в ней отсутствует</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Concat(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>Объединение двух перечислений</summary>
            <param name="source">Первое перечисление элементов</param>
            <param name="other">Второе перечисление элементов</param>
            <returns>Перечисление элементов, составленное из элементов первого и второго перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetLambdaEnumerable``2(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Преобразовать объект в перечисление</summary>
            <param name="obj">Объект-источник элементов</param>
            <param name="Creator">Метод извлечения дочерних элементов объекта</param>
            <typeparam name="TObject">Тип объекта</typeparam>
            <typeparam name="TValue">Тип дочерних элементов</typeparam>
            <returns>Перечисление дочерних элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Исключение пустых ссылок из перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="enumerable">Перечисление элементов</param>
            <returns>Перечисление, составленное из элементов исходного перечисления, за исключением пустых ссылок</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Where(System.Collections.Generic.IEnumerable{System.String},System.Text.RegularExpressions.Regex)">
            <summary>Фильтрация последовательности строк по указанному регулярному выражению</summary>
            <param name="strings">Последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, удовлетворяющая регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot(System.Collections.Generic.IEnumerable{System.String},System.Text.RegularExpressions.Regex)">
            <summary>Фильтрация последовательности строк, которые не удовлетворяют регулярному выражению</summary>
            <param name="strings">Фильтруемая последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, которые не удовлетворяют регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Where(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>Фильтрация последовательности строк по указанному регулярному выражению</summary>
            <param name="strings">Последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, удовлетворяющая регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>Фильтрация последовательности строк, которые не удовлетворяют регулярному выражению</summary>
            <param name="strings">Фильтруемая последовательность строк</param>
            <param name="regex">Регулярное выражение-фильтр</param>
            <returns>Последовательность строк, которые не удовлетворяют регулярному выражению</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WhereNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Выполняет фильтрацию последовательности значений на основе заданного предиката</summary>
            <returns>
            Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, содержащий элементы входной последовательности, которые не удовлетворяют условию.
            </returns>
            <param name="enumerable">Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, подлежащий фильтрации.</param>
            <param name="NotSelector">Функция для проверки каждого элемента на не соответствие условию.</param>
            <typeparam name="T">Тип элементов последовательности <paramref name="enumerable"/>.</typeparam>
            <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="enumerable"/> или <paramref name="NotSelector"/> — null.</exception>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.TakeWhileNot``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Возвращает цепочку элементов последовательности, удовлетворяющих указанному условию</summary>
            <returns>
            Объект <see cref="T:System.Collections.Generic.IEnumerable`1"/>, содержащий элементы входной последовательности до первого элемента, который не прошел проверку.
            </returns>
            <param name="enumerable">Последовательность, из которой требуется возвратить элементы.</param>
            <param name="NotSelector">Функция для проверки каждого элемента на соответствие условию.</param>
            <typeparam name="T">Тип элементов последовательности <paramref name="enumerable"/>.</typeparam>
            <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="enumerable"/> или <paramref name="NotSelector"/> — null.</exception>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Преобразование перечисления в массив с преобразованием элементов</summary>
            <typeparam name="T">Тип элементов исходного перечисления</typeparam>
            <typeparam name="TValue">Тип элементов результирующего массива</typeparam>
            <param name="enumerable">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий массив, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на массив
            </returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>Преобразование перечисления в массив с преобразованием элементов</summary>
            <typeparam name="T">Тип элементов исходного перечисления</typeparam>
            <typeparam name="TValue">Тип элементов результирующего массива</typeparam>
            <param name="enumerable">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов и индекса элемента</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий массив, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на массив
            </returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToList``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Преобразование перечисления в список с преобразованием элементов</summary>
            <typeparam name="T">Тип элементов исходного перечисления</typeparam>
            <typeparam name="TValue">Тип элементов результирующего списка</typeparam>
            <param name="enumerable">Исходное перечисление</param>
            <param name="converter">Метод преобразования элементов</param>
            <returns>
            Если ссылка на исходное перечисление не пуста, то
                Результирующий список, состоящий из элементов исходного перечисления, преобразованных указанным методом
            иначе
                пустая ссылка на список
            </returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToDictionaryDistinctKeys``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Boolean)">
            <summary>Преобразование перечисления в словарь с отбрасыванием повторяющихся значений ключей</summary>
            <param name="enumerable">Перечисление элементов</param>
            <param name="KeySelector">Метод формирования ключа словаря</param>
            <param name="OverloadValues">Перезаписывать значения в словаре?</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <returns>Словарь, составленный из элементов перечисления без повторений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToDictionaryDistinctKeys``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Boolean)">
            <summary>Преобразование перечисления в словарь с отбрасыванием повторяющихся значений ключей</summary>
            <param name="enumerable">Перечисление элементов</param>
            <param name="KeySelector">Метод формирования ключа словаря</param>
            <param name="ValueSelector">Метод вычисления значения словаря</param>
            <param name="OverloadValues">Перезаписывать значения в словаре?</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TKey">Тип ключа словаря</typeparam>
            <typeparam name="TValue">Тип значения записи словаря</typeparam>
            <returns>Словарь, составленный из элементов перечисления без повторений</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Aggregate(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Объединение перечисления строк в единую строку с разделителем - переносом строки</summary>
            <param name="Lines">Перечисление строк</param>
            <returns>Если ссылка на перечисление пуста, то пустая ссылка на строку, иначе - объединение строк с разделителем - переносом строки</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AddTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})">
            <summary>Добавить элементы перечисления в коллекцию</summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="source">Перечисление добавляемых элементов</param>
            <param name="collection">Коллекция-приёмник элементов</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.RemoveFrom``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})">
            <summary>Удалить перечисление элементов из коллекции</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="source">Перечисление удаляемых элементов</param>
            <param name="collection">Коллекция, из которой производится удаление</param>
            <returns>Перечисление результатов операций удаления для каждого из элементов исходного перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AddToDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IDictionary{``0,``1},System.Func{``1,``0})">
            <summary>Добавить в словарь</summary>
            <typeparam name="TKey">Тип ключей словаря</typeparam>
            <typeparam name="TValue">Тип значений словаря</typeparam>
            <param name="collection">Коллекция элементов, добавляемых в словарь</param>
            <param name="dictionary">Словарь, в который добавляются элементы</param>
            <param name="converter">Метод определения ключа элемента</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ConvertToType``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>Преобразовать последовательность одних элементов в последовательность других элементов с использованием механизма конвертации</summary>
            <typeparam name="TItem">Тип исходных элементов</typeparam>
            <typeparam name="TValue">Тип элементов, в которые преобразуются исходные</typeparam>
            <param name="collection">Последовательность исходных элементов</param>
            <returns>Последовательность элементов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectWithLastValue``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``1})">
            <summary>Создать последовательность элементов, каждое значение в которой будет получено на основе двух значений исходной последовательности</summary>
            <typeparam name="TItem">Тип элементов исходной последовательности</typeparam>
            <typeparam name="TValue">Тип элементов последовательности конвертированных элементов</typeparam>
            <param name="collection">Исходная последовательность элементов</param>
            <param name="converter">
            Метод преобразования, в который передаётся исходный элемент последовательности, предыдущий элемент последовательности, 
            и на основе двух этих элементов, он определяет значение элемента результирующей последовательности</param>
            <returns>Последовательность элементов, составляемая из преобразованных элементов исходной последовательности, где метод преобразования учитывает значение предшествующего элемента</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AtFirst``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнить действие для первого элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, выполняемое для первого элемента последовательности в момент её перечисления</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AtLast``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнить действие для последнего элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, выполняемое для последнего элемента в момент её перечисления. Если последовательность элементов просмотрена до конца</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Before``1(System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary> Выполнить действие до начала перечисления последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="ActionBefore">Действие, выполняемое до начала перечисления элементов последовательности</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.OnComplete``1(System.Collections.Generic.IEnumerable{``0},System.Action)">
            <summary>Выполнение действия по завершению перечисления коллекции</summary>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <param name="collection">Коллекция элементов</param>
            <param name="CompleteAction">Действие, выполняемое по завершению перечисления коллекции</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="T:System.Linq.IEnumerableExtensions.EnumerableHistory`1">
            <summary>История перечисления последовательности элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHistory`1._HistoryLength">
            <summary>Длина истории</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHistory`1._Queue">
            <summary>Список элементов в истории</summary>
        </member>
        <member name="F:System.Linq.IEnumerableExtensions.EnumerableHistory`1._ObservableObject">
            <summary>Объект-наблюдения за историей</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Current">
            <summary>Текущий элемент перечисления</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Length">
            <summary>Длина истории</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Count">
            <summary>Количество элементов в истории</summary>
        </member>
        <member name="P:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Item(System.Int32)">
            <summary>Доступ к элементам истории начиная с текущего</summary>
            <param name="i">Индекс элемента в истории, где 0 - текущий элемент</param>
            <returns>Элемент истории перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Linq.IEnumerableExtensions.EnumerableHistory`1"/></summary>
            <param name="HistoryLength">Длина истории</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Check">
            <summary>Удаление лишних элементов из истории</summary>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Add(`0)">
            <summary>Добавить элемент в историю перечисления</summary>
            <param name="item">Добавляемый элемент</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.GetEnumerator">
            <summary>Получить перечислитель истории элементов</summary><returns>Перечислитель истории элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Получить перечислитель истории элементов</summary><returns>Перечислитель истории элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.EnumerableHistory`1.Subscribe(System.IObserver{`0})">
            <summary>Подписка на изменения истории перечисления</summary>
            <param name="observer">Объект-подписчик, уведомляемый об изменениях в истории перечисления</param>
            <returns>Объект, осуществляющий возможность отписаться от уведомлений изменения истории перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectWithHistory``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Linq.IEnumerableExtensions.EnumerableHistory{``0},``1},System.Int32)">
            <summary>Преобразование исходной последовательности элементов с учётом указанного размера истории перечисления</summary>
            <typeparam name="TIn">Тип элементов исходной коллекции</typeparam>
            <typeparam name="TOut">Тип элементов результирующей коллекции</typeparam>
            <param name="collection">Исходная коллекция элементов</param>
            <param name="Selector">Метод преобразования элементов коллекции на основе истории их перечисления</param>
            <param name="HistoryLength">Максимальная длина истории перечисления</param>
            <returns>Коллекция элементов, сформированная на основе исходной с учётом истории процесса перечисления исходной коллекции</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetStatistic(System.Collections.Generic.IEnumerable{System.Double},System.Int32)">
            <summary>Оценка статистических параметров перечисления</summary>
            <param name="collection">Перечисление значений, статистику которых требуется получить</param>
            <param name="Length">Размер выборки для оценки</param>
            <returns>Оценка статистики</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.FilterNullValuesFromEnd(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Отбросить нулевые значения с конца перечисления</summary>
            <param name="collection">Фильтруемое перечисление</param>
            <returns>Перечисление чисел, в котором отсутствуют хвостовые нули</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},``0@,``0@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="selector">Метод преобразования объектов в вещественные числа</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="Max">Максимальный элемент перечисления</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax(System.Collections.Generic.IEnumerable{System.Double},System.Double@,System.Double@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="Max">Максимальный элемент перечисления</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},``0@,System.Int32@,``0@,System.Int32@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="selector">Метод преобразования объектов в вещественные числа</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="MinIndex">Индекс минимального элемента в коллекции</param>
            <param name="Max">Максимальный элемент перечисления</param>
            <param name="MaxIndex">Индекс максимального элемента в коллекции</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax(System.Collections.Generic.IEnumerable{System.Double},System.Double@,System.Int32@,System.Double@,System.Int32@)">
            <summary>Определить минимальное и максимальное значение перечисления</summary>
            <param name="collection">Перечисление, минимум и максимум которого необходимо определить</param>
            <param name="Min">Минимальный элемент перечисления</param>
            <param name="MinIndex">Индекс минимального элемента в коллекции</param>
            <param name="Max">Максимальный элемент перечисления</param>
            <param name="MaxIndex">Индекс максимального элемента в коллекции</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>Определение максимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Определение максимального элемента последовательности</summary>
            <param name="collection">Последовательность элементов</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Int32@)">
            <summary>Определение максимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <param name="index">Индекс максимального элемента в последовательности</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMax(System.Collections.Generic.IEnumerable{System.Double},System.Int32@)">
            <summary>Определение максимального элемента последовательности</summary>
            <param name="collection">Последовательность элементов</param>
            <param name="index">Индекс максимального элемента в последовательности</param>
            <returns>Максимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>Определение минимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Определение минимального элемента последовательности</summary>
            <param name="collection">Последовательность элементов</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double},System.Int32@)">
            <summary>Определение минимального элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод преобразования элементов в вещественные числа</param>
            <param name="index">Индекс минимального элемента в последовательности</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMin(System.Collections.Generic.IEnumerable{System.Double},System.Int32@)">
            <summary>Определение минимального элемента последовательности</summary>
            <param name="collection">Последовательность элементов</param>
            <param name="index">Индекс минимального элемента в последовательности</param>
            <returns>Минимальный элемент последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToListFast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Быстрое преобразование последовательности в список</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Enum">Последовательность, преобразуемая в список</param>
            <returns>Список элементов последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Sum(System.Collections.Generic.IEnumerable{MathCore.Complex})">
            <summary>Сумма последовательности комплексных чисел</summary>
            <param name="collection">Последовательность комплексных чисел</param>
            <returns>Комплексное число, являющееся суммой последовательности комплексных чисел</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,MathCore.Complex})">
            <summary>Комплексная сумма последовательности элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="selector">Метод формирования комплексного значения на основе очередного элемента последовательности</param>
            <returns>Комплексное число, являющееся суммой последовательности комплексных чисел</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,System.Int32,``1},System.Int32)">
            <summary>Объединить элементы коллекции</summary>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="collection">Исходная коллекция элементов</param>
            <param name="Init">Исходное состояние результата объединения</param>
            <param name="func">Метод объединения</param>
            <param name="index">Индекс элемента коллекции</param>
            <returns>Результат объединения коллекции элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Contains``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Проверка на наличие элемента в коллекции</summary>
            <typeparam name="T">Тип элемента</typeparam>
            <param name="collection">Проверяемая коллекция</param>
            <param name="selector">Метод выбора</param>
            <returns>Истина, если выполняется предикат хотя бы на одном элементе коллекции</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Find``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Найти элемент в перечислении, удовлетворяющий предикату</summary>
            <param name="collection">Перечисление элементов</param>
            <param name="selector">Предикат выбора</param>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <returns>Найденный элемент, либо пустая ссылка</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p">Параметр действия</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TP">Тип параметра процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``3(System.Collections.Generic.IEnumerable{``0},``1,``2,System.Action{``0,``1,``2})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p1">Параметр 1 действия</param>
            <param name="p2">Параметр 2 действия</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TP1">Тип параметра 1 процесса перебора</typeparam>
            <typeparam name="TP2">Тип параметра 2 процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``4(System.Collections.Generic.IEnumerable{``0},``1,``2,``3,System.Action{``0,``1,``2,``3})">
            <summary>Выполнение действия для всех элементов коллекции</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p1">Параметр 1 действия</param>
            <param name="p2">Параметр 2 действия</param>
            <param name="p3">Параметр 3 действия</param>
            <param name="Action">Выполняемое действие</param>
            <typeparam name="T">Тип элементов коллекции</typeparam>
            <typeparam name="TP1">Тип 1 параметра процесса перебора</typeparam>
            <typeparam name="TP2">Тип 2 параметра процесса перебора</typeparam>
            <typeparam name="TP3">Тип 3 параметра процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента коллекции</param>
            <typeparam name="T">Тип элемента коллекции</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p">Параметр действия</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента коллекции</param>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TP">Тип параметра процесса перебора</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``3(System.Collections.Generic.IEnumerable{``0},``1,``2,System.Action{``0,System.Int32,``1,``2},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p1">Параметр действия 1</param>
            <param name="p2">Параметр действия 2</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента коллекции</param>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TP1">Тип параметра процесса перебора 1</typeparam>
            <typeparam name="TP2">Тип параметра процесса перебора 2</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Foreach``4(System.Collections.Generic.IEnumerable{``0},``1,``2,``3,System.Action{``0,System.Int32,``1,``2,``3},System.Int32)">
            <summary>Выполнение действия для всех элементов коллекции с указанием индекса элемента</summary>
            <param name="collection">Коллекция элементов</param>
            <param name="p1">Параметр действия 1</param>
            <param name="p2">Параметр действия 2</param>
            <param name="p3">Параметр действия 3</param>
            <param name="Action">Действие над элементом</param>
            <param name="index">Смещение индекса элемента коллекции</param>
            <typeparam name="T">Тип элемента коллекции</typeparam>
            <typeparam name="TP1">Тип параметра процесса перебора 1</typeparam>
            <typeparam name="TP2">Тип параметра процесса перебора 2</typeparam>
            <typeparam name="TP3">Тип параметра процесса перебора 3</typeparam>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CastLazy``1(System.Collections.IEnumerable)">
            <summary>Ленивое преобразование типов, пропускающее непреобразуемые объекты</summary>
            <param name="collection">Исходное перечисление объектов</param>
            <typeparam name="T">Тип объектов входного перечисления</typeparam>
            <returns>Коллекция объектов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.CastLazy``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>Ленивое преобразование типов элементов перечисления</summary>
            <typeparam name="TItem">Тип элементов входной перечисления</typeparam>
            <typeparam name="TValue">Тип элементов перечисления, в который требуется осуществить преобразование</typeparam>
            <param name="collection">Исходная перечисление элементов</param>
            <returns>Перечисление элементов преобразованного типа</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazyIf``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>Действие, выполняемое в процессе перебора элементов для всех элементов перечисления при условии выполнения предиката</summary>
            <typeparam name="T">Ип элементов перечисления</typeparam>
            <param name="collection">Перечисление элементов, для которых надо выполнить действие</param>
            <param name="Predicate">Условие выполнения действия</param>
            <param name="Action">Действие, выполняемое для всех элементов перечисления</param>
            <returns>Исходное перечисление</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazy``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Отложенное выполнение указанного действия для каждого элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="Action">Выполняемое действие</param>
            <returns>Последовательность элементов, для элементов которой выполняется отложенное действие</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>Отложенное выполнение указанного действия для каждого элемента последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <typeparam name="T1">Тип значения</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="Action">Выполняемое действие</param>
            <returns>Последовательность элементов, для элементов которой выполняется отложенное действие</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazyLast``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>Выполнение указанного действия на каждом шаге перебора последовательности после выдачи элемента</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="action">Действие, выполняемое после выдачи элемента последовательности</param>
            <returns>Исходная последовательность элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ForeachLazy``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32)">
            <summary>Отложенное выполнение действия до перебора элементов последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов</param>
            <param name="Action">Выполняемое действие</param>
            <param name="index">Начальный индекс элемента последовательности</param>
            <returns>Последовательность элементов, для элементов которой которой выполняется действие</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ExistingItems``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пересечение последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Source">Исходная последовательность элементов</param>
            <param name="Items">Последовательность элементов, пересечение с которой вычисляется</param>
            <returns>Последовательность элементов, входящих как в первую, так и во вторую последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetUnique``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean},System.Func{``0,System.Int32})">
            <summary>Последовательность уникальных элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="values">Исходная последовательность элементов</param>
            <param name="Comparer">Метод сравнения элементов</param>
            <param name="Hasher">Функция вычисления хеш-кода элемента</param>
            <returns>Последовательность элементов, таких, что ранее они отсутствовали во входной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetUnique``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Последовательность уникальных элементов</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="values">Исходная последовательность элементов</param>
            <returns>Последовательность элементов, таких, что ранее они отсутствовали во входной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.MissingItems``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Найти элементы, которые не входят во вторую последовательность</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="Source">Исходная последовательность</param>
            <param name="Items">Последовательность элементов, которых не должно быть в выходной последовательности</param>
            <returns>Последовательность элементов, которые отсутствуют во второй последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Intersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Пересечение последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Первая последовательность</param>
            <param name="B">Вторая последовательность</param>
            <returns>Массив элементов, входящих и в первую и во вторую последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ItemEquals``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Последовательности элементов поэлементно равны</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Первая последовательность</param>
            <param name="B">Вторая последовательность</param>
            <returns>Истина, если последовательности равны с точностью до элементов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.NotIntersection``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Определение объектов, которые не входят в пересечение двух последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Исходная последовательность</param>
            <param name="B">Вторичная последовательность</param>
            <returns>Массив элементов, входящих либо в первую, либо во вторую последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Xor``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},``0[]@,``0[]@,``0[]@,``0[]@,``0[]@,``0[]@)">
            <summary>Нахождение пересечения элементов двух последовательностей</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="A">Исходная последовательность</param>
            <param name="B">Вторичная последовательность</param>
            <param name="MissingInAFromB">Массив элементов, отсутствующих в первой последовательности</param>
            <param name="MissingInBFromA">Массив элементов, отсутствующих во второй последовательности</param>
            <param name="ExistingInAFromB">Массив элементов, присутствующих в первой последовательности</param>
            <param name="ExistingInBFromA">Массив элементов, присутствующих во второй последовательности</param>
            <param name="Intersection">Пересечение элементов</param>
            <param name="NotIntersection">Остаток от пересечения элементов</param>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ToSeparatedStr``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Преобразовать последовательность в строку с указанной строкой-разделителем</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность объектов, преобразуемая в строку с разделителями</param>
            <param name="Separator">Разделитель элементов в строке</param>
            <returns>Строка, составленная из строковых представлений объектов последовательности, разделённых указанной строкой-разделителем</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.GetMinMax(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>Найти минимум и максимум последовательности вещественных чисел</summary>
            <param name="values">Последовательность вещественных чисел</param>
            <returns>Интервал, границы которого определяют минимум и максимум значений, которые принимала входная последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendLast``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Добавить элемент в конец последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Исходная последовательность элементов</param>
            <param name="obj">Добавляемый объект</param>
            <returns>Последовательность, составленная из элементов исходной последовательности и добавленного элемента</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendLast``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить последовательность элементов в конец последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="first_collection">Начальная последовательность элементов</param>
            <param name="last_collection">Завершающая последовательность элементов</param>
            <returns>Последовательность элементов, составленная из элементов первичной и вторичной последовательностей</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendFirst``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Добавить объект в начало перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="collection">Основное перечисление</param>
            <param name="obj">Объект, добавляемый в начало перечисления</param>
            <returns>Перечисление объектов, составленное из первого объекта и остального перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.AppendFirst``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Добавить перечисление объектов в начало основного перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="last_collection">Первая последовательность объектов</param>
            <param name="first_collection">Вторая последовательность объектов</param>
            <returns>Последовательность объектов, составленная из первой последовательности, за которой следует вторая последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertAtPos``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32)">
            <summary>Вставить элемент в указанное положение в последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов, в которую требуется вставить новый элемент</param>
            <param name="obj">Элемент, добавляемый в последовательность</param>
            <param name="pos">Положение в которое требуется вставить элемент</param>
            <returns>Последовательность элементов, в указанной позиции которой будет размещён указанный элемент</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.InsertAfterPos``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32)">
            <summary>Вставить элемент после указанной позиции в последовательности</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Последовательность элементов, в которую требуется вставить новый элемент</param>
            <param name="obj">Элемент, добавляемый в последовательность</param>
            <param name="pos">Положение после которого требуется вставить элемент</param>
            <returns>Последовательность элементов, в указанной позиции которой будет размещён указанный элемент</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.ConcatInverted``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Инверсная конкатенация перечислений</summary>
            <typeparam name="T">Тип элементов перечислений</typeparam>
            <param name="FirstCollection">Исходная последовательность, добавляемая в конец</param>
            <param name="SecondCollection">Вторичная последовательность, добавляемая в начало</param>
            <returns>Последовательность элементов, составленная из элементов вторичной последовательности и элементов первичной последовательности</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Sum(System.Collections.Generic.IEnumerable{MathCore.Polynom})">
            <summary>Сумма перечисления полиномов</summary>
            <param name="P">Перечисление полиномов, которые надо сложить</param>
            <returns>Полином, являющийся суммой полиномов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Multiply(System.Collections.Generic.IEnumerable{MathCore.Polynom})">
            <summary>Произведение перечисления полиномов</summary>
            <param name="P">Перечисление полиномов, которые надо перемножить</param>
            <returns>Полином, являющийся произведением полиномов</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Decimate``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>Проредить последовательность</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="collection">Прореживаемая последовательность</param>
            <param name="N">Размер выборки > 0</param>
            <param name="k">Положение в выборке (от 0 до N-1)</param>
            <returns>Последовательность из N-ых элементов выборки, стоящих на k-ом месте</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.TakeFirstAndLast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Получить первый и последний элементы перечисления</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="enumerable">Перечисление</param>
            <returns>Перечисление, состоящее из первого и последнего элементов исходного перечисления</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.WithPages``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Разбить перечисление на страницы</summary>
            <typeparam name="T">Тип элемента перечисления</typeparam>
            <param name="items">Исходное перечисление элементов</param>
            <param name="PageItemsCount">Количество элементов на одну страницу</param>
            <returns>Перечисление страниц</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Page``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>Получить элементы перечисления для заданной страницы</summary>
            <typeparam name="T">Тип элемента перечисления</typeparam>
            <param name="items">Исходное перечисление элементов</param>
            <param name="PageNumber">Номер требуемой страницы</param>
            <param name="PageItemsCount">Количество элементов на одну страницу</param>
            <returns>Перечисление элементов из указанной страницы</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Replace``1(System.Collections.Generic.IEnumerable{``0},``0,``0)">
            <summary>Заменить указанный элемент в перечислении</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="items">Исходное перечисление</param>
            <param name="ItemToReplace">Элемент, Который требуется заменить</param>
            <param name="NewItem">Новый элемент</param>
            <returns>Модифицированная последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.Replace``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0)">
            <summary>Заменить указанный элемент в перечислении</summary>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <param name="items">Исходное перечисление</param>
            <param name="Selector">Метод оценки необходимости выполнить замену</param>
            <param name="NewItem">Новый элемент</param>
            <returns>Модифицированная последовательность</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectSequential``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Перебрать последовательно значения из нескольких перечислений</summary>
            <typeparam name="T">Тип элементов перечислений</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="Source">Источник данных</param>
            <param name="Selector">Метод определения источников данных</param>
            <returns>Последовательное перечисление всех элементов данных</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.SelectSequential``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Collections.Generic.IComparer{``1})">
            <summary>Перебрать последовательно значения из нескольких перечислений</summary>
            <typeparam name="T">Тип элементов перечислений</typeparam>
            <typeparam name="TValue">Тип значения</typeparam>
            <param name="Source">Источник данных</param>
            <param name="Selector">Метод определения источников данных</param>
            <param name="Comparer">Объект сравнения</param>
            <returns>Последовательное перечисление всех элементов данных</returns>
        </member>
        <member name="M:System.Linq.IEnumerableExtensions.DiscardRepetitions``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Отбросить последовательно повторяющиеся элементы</summary>
            <typeparam name="T">Тип элементов последовательности</typeparam>
            <param name="values">Последовательность элементов</param>
            <returns>Последовательность элементов без последовательных повторений</returns>
        </member>
        <member name="T:System.Linq.IQueryableExtensions">
            <summary>Класс методов-расширений для интерфейса <see cref="T:System.Linq.IQueryable`1"/></summary>
        </member>
        <member name="M:System.Linq.IQueryableExtensions.Page``1(System.Linq.IQueryable{``0},System.Int32,System.Int32)">
            <summary>Получить элементы перечисления для заданной страницы</summary>
            <typeparam name="T">Тип элемента перечисления</typeparam>
            <param name="items">Исходное перечисление элементов</param>
            <param name="PageNumber">Номер требуемой страницы</param>
            <param name="PageItemsCount">Количество элементов на одну страницу</param>
            <returns>Перечисление элементов из указанной страницы</returns>
        </member>
        <member name="T:System.Linq.JoinedEnumerable">
             <remarks>
             <code>
                 var left_outer_join = 
                     from item_a in ListA.Outer()
                     join item_b in ListB
                         on item_a.Key equals item_b.Key
                     select new (item_a, item_b);
            
                 var right_outer_join = 
                     from item_a in ListA.Inner()
                     join item_b in ListB.Outer()
                         on item_a.Key equals item_b.Key
                     select new (item_a, item_b);
            
                 var full_outer_join = 
                     from item_a in ListA.Outer()
                     join item_b in ListB.Outer()
                         on item_a.Key equals item_b.Key
                     select new (item_a, item_b);
             </code>
             <seealso url="https://habr.com/ru/sandbox/39626/"/>
             </remarks>
        </member>
        <member name="T:System.Linq.Reactive.IObservableEx`1">
            <summary>Обозреваемый объект</summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="M:System.Linq.Reactive.IObservableEx`1.Subscribe(System.Linq.Reactive.IObserverEx{`0})">
            <summary>Метод получения наблюдателя</summary>
            <param name="observer">Наблюдатель объекта</param>
            <returns>Объект, реализующий возможность разрушения связи с наблюдаемым объектом</returns>
        </member>
        <member name="T:System.Linq.Reactive.IObserverEx`1">
            <summary>Интерфейс наблюдателя</summary>
            <typeparam name="T">Тип объектов последовательности событий</typeparam>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Next">
            <summary>Событие появления следующего объекта последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Completed">
            <summary>Событие завершения последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Reset">
            <summary>Событие сброса последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.IObserverEx`1.Error">
            <summary>Событие появления исключения</summary>
        </member>
        <member name="M:System.Linq.Reactive.IObserverEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="T:System.Linq.Reactive.LambdaObservable`1">
            <summary>Наблюдаемый объект с методами обработки событий, задаваемыми лямбда-синтаксисом</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:System.Linq.Reactive.LambdaObservable`1._Observer">
            <summary>Присоединённый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.LambdaObservable`1._OnNext">
            <summary>Действие обработки следующего объекта наблюдения</summary>
        </member>
        <member name="F:System.Linq.Reactive.LambdaObservable`1._OnCompleted">
            <summary>Действие обработки завершения процесса наблюдения</summary>
        </member>
        <member name="F:System.Linq.Reactive.LambdaObservable`1._OnReset">
            <summary>Действие обработки сброса состояния наблюдаемого объекта</summary>
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.OnNext(System.IObserver{`0},`0)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.OnCompleted(System.IObserver{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.OnReset(System.Linq.Reactive.IObserverEx{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.OnError(System.IObserver{`0},System.Exception)">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.LambdaObservable`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Reactive.ObservableExtensions">
            <summary>Методы-расширения интерфейса наблюдаемых объектов <see cref="T:System.Linq.Reactive.IObservableEx`1"/></summary>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.AddObserver``1(System.Collections.Generic.ICollection{System.IObserver{``0}},System.IObserver{``0})">
            <summary>Добавить наблюдатель в список наблюдателей и получить объект-отписчик</summary>
            <typeparam name="T">Тип значений наблюдаемого объекта</typeparam>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Объект, удаляющий наблюдатель из списка наблюдателей в случае своей отписки</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.FromProperty``1(System.ComponentModel.INotifyPropertyChanged,System.String)">
            <summary>Метод получения наблюдаемого объекта для объекта, реализующего интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/>  для указанного имени свойства</summary>
            <typeparam name="T">Тип значения свойства</typeparam>
            <param name="Obj">Наблюдаемый объект</param>
            <param name="ProperName">Имя свойства</param>
            <returns>Объект-наблюдатель за свойством</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean})">
            <summary>Метод фильтрации событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Predicate">Метод фильтрации</param>
            <returns>Объект-наблюдатель с установленным методом фильтрации</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Where``1(System.IObservable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>Метод фильтрации событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Predicate">Метод фильтрации</param>
            <param name="ElseAction">Метод обработки невошедших событий</param>
            <returns>Объект-наблюдатель с установленным методом фильтрации</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Select``2(System.IObservable{``0},System.Func{``0,``1})">
            <summary>Метод преобразования объектов событий</summary>
            <typeparam name="T">Тип исходных объектов событий</typeparam>
            <typeparam name="TResult">Тип результирующих объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Selector">Объект-наблюдатель с преобразованными объектами событий</param>
            <returns>Объект-наблюдатель с преобразованными типами объектов</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.WhitSync``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Метод получения синхронно задержанных во времени событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Interval">Интервал времени задержки событий</param>
            <returns>Объект-наблюдатель, события которого синхронно задержаны во времени на указанный интервал</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.WhitAsync``1(System.IObservable{``0},System.TimeSpan)">
            <summary>Метод получения задержанных во времени событий</summary>
            <typeparam name="T">Тип объектов событий</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Interval">Интервал времени задержки событий</param>
            <returns>Объект-наблюдатель, события которого задержаны во времени на указанный интервал</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.FromEvent``1(System.Object,System.String)">
            <summary>Метод получения объекта-наблюдателя для указанного события</summary>
            <typeparam name="TEventArgs">Тип аргументов события</typeparam>
            <param name="Obj">Наблюдаемый объект</param>
            <param name="EventName">Имя события</param>
            <returns>Объект-наблюдатель за событием</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.GetObservable``1(System.Collections.Generic.IEnumerable{``0},System.IObservable{``0}@)">
            <summary>Метод получения объекта-наблюдателя из объекта-перечисления</summary>
            <typeparam name="T">Тип объектов перечисления</typeparam>
            <param name="Enumerable">Перечисление объектов</param>
            <param name="Observable">Созданный объект-наблюдатель за перечислением объектов коллекции</param>
            <returns>Новое перечисление объектов, перечисление объектов которого вызывает события в наблюдателе</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Take``1(System.IObservable{``0},System.Int32)">
            <summary>Метод получения объекта-наблюдателя, пропускающего после создания указанное число событий</summary>
            <typeparam name="T">Тип объектов события</typeparam>
            <param name="Source">Исходный объект-наблюдатель</param>
            <param name="Count">Количество пропускаемых событий</param>
            <returns>Объект-наблюдатель с указанным количеством пропускаемых событий</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Take``3(System.IObservable{``0},System.IObservable{``1},System.IObservable{``2},System.Boolean)">
            <summary>Метод обработки последовательности событий с учётом разрешающей и запрещающей последовательностей</summary>
            <typeparam name="TSource">Тип объектов событий наблюдаемого объекта</typeparam>
            <typeparam name="TOpen">Тип объектов событий разрешающей последовательности</typeparam>
            <typeparam name="TClose">Тип объектов событий запрещающей последовательности</typeparam>
            <param name="Observable">Объект-наблюдатель источник событий</param>
            <param name="Open">Объект-наблюдатель разрешающий событий в выходной последовательности</param>
            <param name="Close">Объект-наблюдатель запрещающий событий в выходной последовательности</param>
            <param name="InitialState">Исходное состояния разрешения событий в выходной последовательности (по умолчанию разрешено)</param>
            <returns>Управляемый объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.TakeUntil``2(System.IObservable{``0},System.IObservable{``1},System.Boolean)">
            <summary>Метод получения объекта-наблюдателя, события в котором пропускаются в выходную последовательность только до появления события в управляющей последовательности</summary>
            <typeparam name="T">Тип исходных объектов события</typeparam>
            <typeparam name="TResult">Тип события управляющей последовательности</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Selector">Объект-наблюдатель управляющей последовательности</param>
            <param name="IsOpen">Исходное состояние выходной последовательности</param>
            <returns>Объект-наблюдатель управляемый управляющей последовательностью</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.SkipWhile``2(System.IObservable{``0},System.IObservable{``1},System.Boolean)">
            <summary>Метод получения объекта-наблюдателя, события в котором пропускаются в выходную последовательность только после появления события в управляющей последовательности</summary>
            <typeparam name="T">Тип исходных объектов события</typeparam>
            <typeparam name="TResult">Тип события управляющей последовательности</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Selector">Объект-наблюдатель управляющей последовательности</param>
            <param name="IsOpen">Исходное состояние выходной последовательности</param>
            <returns>Объект-наблюдатель управляемый управляющей последовательностью</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.ForeachAction``1(System.IObservable{``0},System.Action{``0})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Subscribe``1(System.IObservable{``0},System.Action{``0})">
            <summary>Подписаться на уведомления наблюдаемого объекта <see cref="T:System.IObservable`1"/></summary>
            <param name="Source">Источник событий</param>
            <param name="Action">Действие, выполняемое при возникновении события</param>
            <typeparam name="T">Тип значения событий</typeparam>
            <returns>Объект отписки</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.ForeachAction``1(System.IObservable{``0},System.Action{``0},System.Func{``0,System.Boolean})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <param name="Where">Метод выборки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.ForeachAction``1(System.IObservable{``0},System.Action{``0,System.Int32})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.ForeachAction``1(System.IObservable{``0},System.Action{``0,System.Int32},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="Action">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <param name="Where">Метод выборки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Next"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.OnError``1(System.IObservable{``0},System.Action{System.Exception})">
            <summary>Метод обработки события <see cref="T:System.Exception"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="OnError">Метод обработки события <see cref="T:System.Exception"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.OnCompleted``1(System.IObservable{``0},System.Action)">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Completed"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="OnCompleted">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Completed"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.OnReset``1(System.IObservable{``0},System.Action)">
            <summary>Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Reset"/></summary>
            <typeparam name="T">Тип объектов наблюдения</typeparam>
            <param name="Observable">Исходный объект-наблюдатель</param>
            <param name="OnReset">Метод обработки события <see cref="E:System.Linq.Reactive.IObserverEx`1.Reset"/></param>
            <returns>Исходный объект-наблюдатель</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.FromAsyncPattern``1(System.Func{System.AsyncCallback,System.Object,System.IAsyncResult},System.Func{System.IAsyncResult,``0})">
            <summary>Создать метод генерации наблюдаемого объекта из шаблона асинхронной операции</summary>
            <typeparam name="T">Тип результата</typeparam>
            <param name="BeginInvoke">Метод начала асинхронной операции</param>
            <param name="EndInvoke">Метод завершения асинхронной операции</param>
            <returns>Функция, возвращающая наблюдаемый объект, генерирующий своё значение в момент завершения асинхронной операции</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.SelectMany``1(System.IObservable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>Метод-лианиризатор событий для наблюдаемого объекта, возвращающего коллекцию объектов типа <see cref="!:T"/></summary>
            <typeparam name="T">Тип результирующих объектов</typeparam>
            <param name="Observable">Объект-наблюдатель коллекции</param>
            <returns>Объект-наблюдатель элементов коллекции</returns>
        </member>
        <member name="M:System.Linq.Reactive.ObservableExtensions.Single``1(System.IObservable{``0})">
            <summary>Получить первое значение наблюдаемого объекта</summary>
            <typeparam name="T">Тип значений объекта</typeparam>
            <param name="Observable">Наблюдаемый объект</param>
            <returns>Первое значение наблюдаемого объекта</returns>
        </member>
        <member name="T:System.Linq.Reactive.ObserverLink`1">
            <summary>Класс объектов-связей между наблюдателем и списком наблюдателей, позволяющих удалять наблюдатель из писка наблюдателей в случае если объект удаляется из памяти</summary>
            <typeparam name="T">Тип значений наблюдаемого объекта</typeparam>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.GetHash(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Получить хэш-код связи</summary>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Хэш-код связи</returns>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1.__Links">
            <summary>Словарь связей</summary>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.GetLink(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Получить связь между наблюдателем и списком наблюдателей</summary>
            <param name="Observers">Коллекция наблюдателей</param>
            <param name="Observer">Добавляемый наблюдатель</param>
            <returns>Связь между наблюдателем и списком наблюдателей</returns>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._Observer">
            <summary>Удаляемый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._Observers">
            <summary>Коллекция наблюдателей, из которой требуется удалить отслеживаемый наблюдатель</summary>
        </member>
        <member name="F:System.Linq.Reactive.ObserverLink`1._SyncRoot">
            <summary>Объект межпотоковой синхронизации</summary>
        </member>
        <member name="M:System.Linq.Reactive.ObserverLink`1.#ctor(System.Collections.Generic.ICollection{System.IObserver{`0}},System.IObserver{`0})">
            <summary>Инициализация новой связи между списком наблюдателей и отслеживаемым наблюдателем</summary>
            <param name="Observers">Список наблюдателей</param>
            <param name="Observer">Отслеживаемый наблюдатель</param>
        </member>
        <member name="T:System.Linq.Reactive.SimpleObservableEx`1">
            <summary>Простейший наблюдаемый объект</summary><typeparam name="T">Тип объектов событий</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.SimpleObservableEx`1._Observers">
            <summary>Список объектов наблюдателей</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnNext(`0)">
            <summary>Метод генерации следующего события</summary>
            <param name="item">Объект события</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnCompleted">
            <summary>Метод генерации события завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnError(System.Exception)">
            <summary>Метод генерации события возникновения ошибки</summary>
            <param name="error">Возникшее исключение</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.OnError(System.IObserver{`0},System.Exception)">
            <summary>Генерация события возникновения исключения</summary>
            <param name="observer">Наблюдаемый объект, в котором возникло исключение</param>
            <param name="error">Возникшее исключение</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Subscribe(System.Linq.Reactive.IObserverEx{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Subscribe(System.IObserver{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:System.Linq.Reactive.SimpleObservableEx`1.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="Disposing">Если <see langword="true"/>, то выполнить освобождение управляемых ресурсов</param>
        </member>
        <member name="T:System.Linq.Reactive.SimpleObserverEx`1">
            <summary>Простейший наблюдатель</summary>
            <typeparam name="T">Объект события</typeparam>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Next">
            <summary>События появления следующего объекта в последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Completed">
            <summary>Событие завершения последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Reset">
            <summary>Событие сброса последовательности</summary>
        </member>
        <member name="E:System.Linq.Reactive.SimpleObserverEx`1.Error">
            <summary>Событие появления исключения</summary>
        </member>
        <member name="P:System.Linq.Reactive.SimpleObserverEx`1.Tag">
            <summary>Тэг наблюдателя</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.#ctor(System.IObservable{`0})">
            <summary>Инициализация нового простейшего наблюдателя</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnNext(`0)">
            <summary>Метод генерации события появления следующего объекта</summary>
            <param name="item">Следующий объект в последовательности</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnError(System.Exception)">
            <summary>Метод генерации события исключительной ситуации</summary>
            <param name="error">Исключительная ситуация</param>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnCompleted">
            <summary>Метод генерации события завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.OnReset">
            <summary>Метод генерации события сброса последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.Dispose">
            <summary>Освобождение ресурсов и отписка от наблюдаемых объектов</summary>
        </member>
        <member name="M:System.Linq.Reactive.SimpleObserverEx`1.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов и отписка от наблюдаемых объектов</summary>
            <param name="Disposing">Если истина, то выполнить освобождение ресурсов и отписку</param>
        </member>
        <member name="T:System.Linq.Reactive.TakeObservable`1">
            <summary>Наблюдаемый объект с указанным числом генерации событий</summary>
            <typeparam name="T">Тип объектов последовательности</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.TakeObservable`1._Observer">
            <summary>Исходный наблюдатель</summary>
        </member>
        <member name="M:System.Linq.Reactive.TakeObservable`1.#ctor(System.IObservable{`0},System.Int32)">
            <summary>Наблюдаемый объект с указанным числом генерации событий</summary>
            <param name="observable">Исходный наблюдаемый объект</param>
            <param name="Count">Количество извлекаемых событий</param>
        </member>
        <member name="M:System.Linq.Reactive.TimeIntervalObservable.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Reactive.TriggeredObservable`1">
            <summary>Управляемый наблюдаемый объект</summary>
            <typeparam name="T">Тип объекта последовательности</typeparam>
        </member>
        <member name="F:System.Linq.Reactive.TriggeredObservable`1._Observer">
            <summary>Наблюдатель</summary>
        </member>
        <member name="P:System.Linq.Reactive.TriggeredObservable`1.State">
            <summary>Признак разрешения потока элементов последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.#ctor(System.IObservable{`0},System.Boolean)">
            <summary>Управляемый наблюдаемый объект</summary>
            <param name="observable">Наблюдаемый объект</param>
            <param name="InitialState">Исходное состояние</param>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.OnNext(`0)">
            <summary>Если состояние <see langword="true"/>, то значения пропускаются в выходную последовательность</summary>
            <param name="item">Объект события</param>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.OnCompleted">
            <summary>Если состояние <see langword="true"/>, то генерирует событие завершения последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.OnReset">
            <summary>Если состояние <see langword="true"/>, то генерирует событие сброса последовательности</summary>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.OnError(System.Exception)">
            <summary>Если состояние <see langword="true"/>, то генерирует событие возникновения ошибки</summary>
            <param name="error">Возникшее исключение</param>
        </member>
        <member name="M:System.Linq.Reactive.TriggeredObservable`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:System.Linq.Reactive.Unit">
            <summary>
            Represents a type with a single value.
            This type is often used to denote the successful completion of a void-returning method (C#)
            or a Sub procedure (Visual Basic).
            </summary>
        </member>
        <member name="P:System.Linq.Reactive.Unit.Default">
            <summary>Gets the single unit value</summary>
        </member>
        <member name="M:System.Linq.Reactive.Unit.op_Equality(System.Linq.Reactive.Unit,System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the two specified Unit values are equal.
            Because Unit has a single value, this always returns true.
            </summary>
            <param name="first">The first Unit value to compare</param>
            <param name="second">The second Unit value to compare</param>
            <returns>Because Unit has a single value, this always returns true</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.op_Inequality(System.Linq.Reactive.Unit,System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the two specified Unit values are not equal.
            Because Unit has a single value, this always returns false.
            </summary>
            <param name="first">The first Unit value to compare</param>
            <param name="second">The second Unit value to compare</param>
            <returns>Because Unit has a single value, this always returns false</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.Equals(System.Linq.Reactive.Unit)">
            <summary>
            Determines whether the specified Unit values is equal to the current Unit.
            Because Unit has a single value, this always returns true.
            </summary>
            <param name="other">An object to compare to the current Unit value</param>
            <returns>Because Unit has a single value, this always returns true</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.Equals(System.Object)">
            <summary>Determines whether the specified System.Object is equal to the current Unit</summary>
            <param name="obj">The System.Object to compare with the current Unit</param>
            <returns>true if the specified System.Object is a Unit value; otherwise, false</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.GetHashCode">
            <summary>Returns the hash code for the current Unit value</summary>
            <returns>A hash code for the current Unit value</returns>
        </member>
        <member name="M:System.Linq.Reactive.Unit.ToString">
            <summary>Returns a string representation of the current Unit value</summary>
            <returns>String representation of the current Unit value</returns>
        </member>
        <member name="T:System.Array`1">
            <summary>Статический класс для работы с типизированными массивами</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.Array`1.Length(System.Int32)">
            <summary>Создать генератор массивов для указанной длины</summary>
            <param name="Length">Требуемая длина массива</param>
            <returns>Генератор массивов, создающий массивы указанной длины</returns>
        </member>
        <member name="M:System.Array`1.Length(System.Int32,System.Func{System.Int32,`0})">
            <summary>Создать генератор массивов для указанной длины</summary>
            <param name="Length">Требуемая длина массива</param>
            <param name="Initializer">Функция инициализации элементов массива</param>
            <returns>Генератор массивов, создающий массивы указанной длины</returns>
        </member>
        <member name="T:System.Array`1.Creator">
            <summary>Объект, позволяющий создавать массивы и инициализировать их элементами</summary>
        </member>
        <member name="F:System.Array`1.Creator._Length">
            <summary>Длина создаваемого массива</summary>
        </member>
        <member name="F:System.Array`1.Creator._Initializer">
            <summary>Функция инициализации элементов массива</summary>
        </member>
        <member name="F:System.Array`1.Creator._Updater">
            <summary>Функция обновления значений элементов массива</summary>
        </member>
        <member name="F:System.Array`1.Creator._SetDefaultValue">
            <summary>Устанавливать значения ячеек массива в значение по умолчанию</summary>
        </member>
        <member name="F:System.Array`1.Creator._DefaultValue">
            <summary>Значение по умолчанию для элементов массива</summary>
        </member>
        <member name="M:System.Array`1.Creator.#ctor(System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Array`1.Creator"/></summary>
            <param name="Length">Длина массива, создаваемого объектом</param>
        </member>
        <member name="M:System.Array`1.Creator.#ctor(System.Int32,System.Func{System.Int32,`0})">
            <summary>Инициализация нового экземпляра <see cref="T:System.Array`1.Creator"/></summary>
            <param name="Length">Длина массива, создаваемого объектом</param>
            <param name="Initializer">Функция инициализации ячеек массива</param>
        </member>
        <member name="M:System.Array`1.Creator.Default(`0)">
            <summary>Установить значение по умолчанию для ячеек массива</summary>
            <param name="DefaultValue">Значение по умолчанию для ячеек массива</param>
            <returns>Исходный экземпляр <see cref="T:System.Array`1.Creator"/></returns>
        </member>
        <member name="M:System.Array`1.Creator.ResetDefault">
            <summary>Сбросить значение по умолчанию</summary>
            <returns>Исходный экземпляр <see cref="T:System.Array`1.Creator"/></returns>
        </member>
        <member name="M:System.Array`1.Creator.Init(System.Func{System.Int32,`0})">
            <summary>Задать функцию инициализации ячеек массива</summary>
            <param name="Initializer">Функция, генерирующая значение ячейки массива по её индексу</param>
            <returns>Исходный экземпляр <see cref="T:System.Array`1.Creator"/></returns>
        </member>
        <member name="M:System.Array`1.Creator.Update(System.Func{System.Int32,`0,`0})">
            <summary>Задать функцию обновления значений ячеек массива</summary>
            <param name="Updater">
            Функция, принимающая в качестве параметром индекс ячейки и её значение,
            результат вызова этой функции будет размещён в ячейке массива с указанным индексом
            </param>
            <returns>Исходный экземпляр <see cref="T:System.Array`1.Creator"/></returns>
        </member>
        <member name="M:System.Array`1.Creator.Create">
            <summary>Создать массив с заданными в объекте параметрами</summary>
            <returns>Новый массив, длина и ячейки которого определяются объектом инициализации</returns>
        </member>
        <member name="M:System.Array`1.Creator.op_Implicit(System.Array{`0}.Creator)~`0[]">
            <summary>Оператор неявного преобразования <see cref="T:System.Array`1.Creator"/> к типу массива</summary>
            <param name="creator">Объект инициализации массива</param>
        </member>
        <member name="T:System.ArrayExtensions">
            <summary>Методы расширения для массивов</summary>
        </member>
        <member name="M:System.ArrayExtensions.Shuffle``1(``0[],System.Random)">
            <summary>Перемешать элементы массива</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="items">Перемешиваемый массив</param>
            <param name="rnd">Генератор случайных чисел</param>
            <returns>Перечисление элементов массива в случайном порядке без повторений</returns>
        </member>
        <member name="M:System.ArrayExtensions.Deconstruct``1(``0[0:,0:],System.Int32@,System.Int32@)">
            <summary>Деконструктор двумерного массива на размеры по первому и второму измерению</summary>
            <param name="array">Деконструируемый массив</param>
            <param name="N">Число строк (первое измерение)</param>
            <param name="M">Число столбцов (второе измерение)</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Deconstruct``1(``0[0:,0:,0:],System.Int32@,System.Int32@,System.Int32@)">
            <summary>Деконструктор трёхмерного массива на размеры по первому, второму и третьему измерению</summary>
            <param name="array">Деконструируемый массив</param>
            <param name="N">Число строк (первое измерение)</param>
            <param name="M">Число столбцов (второе измерение)</param>
            <param name="K">Глубина (третье измерение)</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.AsRandomEnumerable``1(``0[],System.Random)">
            <summary>Перебрать элементы массива случайным образом без повторений</summary>
            <param name="Items">Массив элементов</param>
            <param name="Rnd">Генератор случайных чисел</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов массива в случайном порядке</returns>
        </member>
        <member name="M:System.ArrayExtensions.TakeLast``1(``0[],System.Int32)">
            <summary>Получить последовательность из последних элементов массива (в прямом порядке)</summary>
            <param name="Items">Перебираемый массив элементов</param>
            <param name="Count">Число элементов с конца, которые надо перебрать</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов в конце массива в указанном количестве</returns>
        </member>
        <member name="M:System.ArrayExtensions.TakeLastInverted``1(``0[],System.Int32)">
            <summary>Получить последовательность из последних элементов массива (в обратном порядке)</summary>
            <param name="Items">Перебираемый массив элементов</param>
            <param name="Count">Число элементов с конца, которые надо перебрать</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов в конце массива в указанном количестве</returns>
        </member>
        <member name="M:System.ArrayExtensions.TakeLastElements``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Получить последние элементы перечисления</summary>
            <param name="Items">Перечисление элементов</param>
            <param name="Count">Количество элементов с конца перечисления, которые требуется получить</param>
            <typeparam name="T">Тип элементов перечисления</typeparam>
            <returns>Перечисление последних <paramref name="Count"/> элементов <paramref name="Items"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.EnumerateElementsByRows``1(``0[0:,0:])">
            <summary>Перечисление элементов двумерного массива по строкам</summary>
            <param name="array">Двумерный массив, элементы которого требуется перечислить</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов двумерного массива по строкам</returns>
        </member>
        <member name="M:System.ArrayExtensions.EnumerateElementsByCols``1(``0[0:,0:])">
            <summary>Перечисление элементов двумерного массива по столбцам</summary>
            <param name="array">Двумерный массив, элементы которого требуется перечислить</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Перечисление элементов двумерного массива по столбцам</returns>
        </member>
        <member name="M:System.ArrayExtensions.Exist``1(``0[],``0)">
            <summary>Проверка на наличие элемента в массиве</summary>
            <param name="array">Массив, проверка наличия элемента в котором выполняется</param>
            <param name="value">Искомый элемент</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Истина, если элемент найден</returns>
        </member>
        <member name="M:System.ArrayExtensions.NotExist``1(``0[],``0)">
            <summary>Проверка на отсутствие элемента в массиве</summary>
            <param name="array">Массив, проверка отсутствия элемента в котором выполняется</param>
            <param name="value">Искомый элемент</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Истина, если элемент в массиве отсутствует</returns>
        </member>
        <member name="M:System.ArrayExtensions.Split``1(``0[],System.Func{``0,System.Boolean})">
            <summary>Разделить входной массив на подмассивы указанным методом</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Разделяемый массив</param>
            <param name="Splitter">Метод, возвращающий истину, когда надо начать новый подмассив</param>
            <returns>
            Массив подмассивов элементов исходного массива, разделённый выбранными указанным методом элементами.
            Выбранные элементы в результат не входят.
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.QuickSort``1(``0[],System.Int32,System.Int32)">
            <summary>Быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
        </member>
        <member name="M:System.ArrayExtensions.QuickSortAsync``1(``0[],System.Int32,System.Int32)">
            <summary>Асинхронная быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
            <returns>Задача, выполняющая процесс быстрой сортировки</returns>
        </member>
        <member name="M:System.ArrayExtensions.QuickSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>Быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух объектов <typeparamref name="T"/></param>
        </member>
        <member name="M:System.ArrayExtensions.QuickSortAsync``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>Асинхронная быстрая сортировка Хоара</summary>
            <typeparam name="T">Тип сортируемых элементов</typeparam>
            <param name="A">Сортируемый массив элементов</param>
            <param name="low">Нижняя граница индекса сортировки</param>
            <param name="high">Верхняя граница индекса сортировки</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух объектов <typeparamref name="T"/></param>
            <returns>Задача, выполняющая процесс быстрой сортировки</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetComplexHashCode``1(``0[])">
            <summary>Расчёт хеш-суммы всех элементов массива</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="Objects">Массив элементов</param>
            <returns>Хеш-сумма элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.Concatenate``1(``0[],``0[])">
            <summary>Объединение с массивом элементов</summary>
            <param name="A">Исходный массив</param>
            <param name="B">Присоединяемый массив</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>Массив из объединенных элементов</returns>
        </member>
        <member name="M:System.ArrayExtensions.Concatenate``1(``0[],``0[][])">
            <summary>Конкатенация массивов</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="A">Исходный массив</param>
            <param name="B">Присоединяемые массивы</param>
            <returns>Массив, содержащий все элементы объединяемых массивов</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetSelectedValue``2(``0[],System.Func{``0,``1,``1})">
            <summary>Получить элемент массива</summary>
            <param name="A">Массив элементов</param>
            <param name="Selector">Метод выбора элемента массива</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TOut">Тип выходного элемента</typeparam>
            <returns>Выбранный элемент массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.ConvertTo``2(``0[],System.Converter{``0,``1})">
            <summary>Преобразовать тип элементов массива</summary>
            <param name="In">Исходный массив элементов</param>
            <param name="converter">Метод преобразования элемента массива</param>
            <typeparam name="TIn">Исходный тип элементов массива</typeparam>
            <typeparam name="TOut">Требуемый тип элементов массива</typeparam>
            <returns>Массив преобразованных элементов</returns>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[],System.Action{``0})">
            <summary>Выполнение действия для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемой действие</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[],System.Action{``0},System.Func{System.Exception,System.Boolean})">
            <summary>Выполнение действия для всех элементов массива с обработкой исключений</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемое действие</param>
            <param name="ErrorHandler">Обработчик исключения</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``2(``0[],System.Action{``0},System.Func{``1,System.Boolean})">
            <summary>Выполнение действия для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="action">Выполняемое действие</param>
            <param name="ErrorHandler">Обработчик исключений</param>
            <exception cref="T:System.ApplicationException">Возникает в случае если в методе action возникшее исключение не было обработано</exception>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TException">Тип исключений</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Function``2(``0[],System.Func{``0,``1})">
            <summary>Определение значения функции для всех элементов массива</summary>
            <param name="array">Массив элементов</param>
            <param name="f">Вычисляемая функция</param>
            <typeparam name="TIn">Тип элементов массива области определения</typeparam>
            <typeparam name="TOut">Тип элементов массива области значения</typeparam>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetReversed``1(``0[])">
            <summary>Получить массив, индексы элементов которого имеют обратный порядок</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Переворачиваемый массив</param>
            <returns>Перевёрнутый массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetSubArray``1(``0[],System.Int32,System.Int32)">
            <summary>Извлечь подмассив</summary>
            <param name="array">Исходный массив</param>
            <param name="Length">Длина извлекаемого участка</param>
            <param name="Start">Начальное положение</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>
            Новый экземпляр массива, содержащий последовательность элементов
            начиная с указанного <paramref name="Start"/> положения и указанной длины <paramref name="Length"/>
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[],System.Func{System.Int32,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер элемента,
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[],``0)">
            <summary>Инициализация массива одним значением</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="value">Значение, размещаемое во всех элементах массива</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[],``1,System.Func{System.Int32,``1,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TValue">Тип элементов массива</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="p">Параметр инициализации</param>
            <param name="Initializer">Метод инициализации</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[],``1,``2,System.Func{System.Int32,``1,``2,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TValue">Тип элементов массива</typeparam>
            <typeparam name="TP1">Тип первого параметра инициализации</typeparam>
            <typeparam name="TP2">Тип второго параметра инициализации</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="p1">Первый параметр инициализации</param>
            <param name="p2">Второй параметр инициализации</param>
            <param name="Initializer">Метод инициализации</param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[],System.Func{``0,System.Int32,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметров инициализируемый массив и номер элемента,
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[],``1,System.Func{``0,System.Int32,``1,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="p">Параметр инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметров инициализируемый массив
            и номер элемента и параметр <paramref name="p"/>, 
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[],``1,``2,System.Func{``0,System.Int32,``1,``2,``0})">
            <summary>Инициализация массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <param name="array">Инициализируемый массив</param>
            <param name="p1">Параметр 1 инициализации</param>
            <param name="p2">Параметр 2 инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметров инициализируемый массив
            и номер элемента, параметр <paramref name="p1"/> и параметр <paramref name="p2"/>, 
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[0:,0:],System.Func{System.Int32,System.Int32,``0})">
            <summary>Инициализация двумерного массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <param name="array">Инициализируемый двумерный массив</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер строки и номер столбца элемента,
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[0:,0:],``1,System.Func{System.Int32,System.Int32,``1,``0})">
            <summary>Инициализация двумерного массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="array">Инициализируемый двумерный массив</param>
            <param name="p">Параметр инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер строки и номер столбца элемента,
            параметр инициализации <paramref name="p"/>
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[0:,0:],``1,``2,System.Func{System.Int32,System.Int32,``1,``2,``0})">
            <summary>Инициализация двумерного массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <param name="array">Инициализируемый двумерный массив</param>
            <param name="p1">Параметр 1 инициализации</param>
            <param name="p2">Параметр 2 инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер строки и номер столбца элемента,
            параметры инициализации <paramref name="p1"/> и <paramref name="p2"/>
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``4(``0[0:,0:],``1,``2,``3,System.Func{System.Int32,System.Int32,``1,``2,``3,``0})">
            <summary>Инициализация двумерного массива</summary>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <typeparam name="TP3">Тип 3 параметра инициализации</typeparam>
            <param name="array">Инициализируемый двумерный массив</param>
            <param name="p1">Параметр 1 инициализации</param>
            <param name="p2">Параметр 2 инициализации</param>
            <param name="p3">Параметр 3 инициализации</param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра номер строки и номер столбца элемента,
            параметры инициализации <paramref name="p1"/>, <paramref name="p2"/> и <paramref name="p3"/>
            а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``1(``0[][],System.Func{System.Int32,``0[]},System.Func{System.Int32,System.Int32,``0})">
            <summary>Инициализация невыровненного двумерного массива элементов</summary>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <param name="array">Инициализируемый невыровненный массив</param>
            <param name="ArrayInitializer">
            Метод создания очередного одномерного массива, получающий в качестве параметра индекс инициализируемого
            одномерного массива, а в результате своей работы он должен вернуть одномерный массив элементов,
            который будет помещён в ячейку массива верхнего уровня
            </param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра индекс массива и индекс элемента
            в одномерном массиве, а результатом его вызова должно быть значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный невыровненный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``2(``0[][],``1,System.Func{System.Int32,``1,``0[]},System.Func{System.Int32,System.Int32,``1,``0})">
            <summary>Инициализация невыровненного двумерного массива элементов</summary>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="array">Инициализируемый невыровненный массив</param>
            <param name="p">Параметр процесса инициализации</param>
            <param name="ArrayInitializer">
            Метод создания очередного одномерного массива, получающий в качестве параметра индекс инициализируемого
            одномерного массива и параметр, а в результате своей работы он должен вернуть одномерный массив
            элементов, который будет помещён в ячейку массива верхнего уровня
            </param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра индекс массива и индекс элемента
            в одномерном массиве, а также параметр инициализации, а результатом его вызова должно быть значение,
            помещаемое в ячейку массива
            </param>
            <returns>Инициализированный невыровненный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``3(``0[][],``1,``2,System.Func{System.Int32,``1,``2,``0[]},System.Func{System.Int32,System.Int32,``1,``2,``0})">
            <summary>Инициализация невыровненного двумерного массива элементов</summary>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <param name="array">Инициализируемый невыровненный массив</param>
            <param name="p1">Параметр 1 процесса инициализации</param>
            <param name="p2">Параметр 2 процесса инициализации</param>
            <param name="ArrayInitializer">
            Метод создания очередного одномерного массива, получающий в качестве параметра индекс инициализируемого
            одномерного массива и два параметра, а в результате своей работы он должен вернуть одномерный массив
            элементов, который будет помещён в ячейку массива верхнего уровня
            </param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра индекс массива и индекс элемента
            в одномерном массиве, а также два параметра инициализации, а результатом его вызова должно быть
            значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный невыровненный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Initialize``4(``0[][],``1,``2,``3,System.Func{System.Int32,``1,``2,``3,``0[]},System.Func{System.Int32,System.Int32,``1,``2,``3,``0})">
            <summary>Инициализация невыровненного двумерного массива элементов</summary>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <typeparam name="TP1">Тип 1 параметра инициализации</typeparam>
            <typeparam name="TP2">Тип 2 параметра инициализации</typeparam>
            <typeparam name="TP3">Тип 3 параметра инициализации</typeparam>
            <param name="array">Инициализируемый невыровненный массив</param>
            <param name="p1">Параметр 1 процесса инициализации</param>
            <param name="p2">Параметр 2 процесса инициализации</param>
            <param name="p3">Параметр 3 процесса инициализации</param>
            <param name="ArrayInitializer">
            Метод создания очередного одномерного массива, получающий в качестве параметра индекс инициализируемого
            одномерного массива и три параметра, а в результате своей работы он должен вернуть одномерный массив
            элементов, который будет помещён в ячейку массива верхнего уровня
            </param>
            <param name="Initializer">
            Метод инициализации, получающий в качестве параметра индекс массива и индекс элемента
            в одномерном массиве, а также три параметра инициализации, а результатом его вызова должно быть
            значение, помещаемое в ячейку массива
            </param>
            <returns>Инициализированный невыровненный двумерный массив</returns>
        </member>
        <member name="M:System.ArrayExtensions.Reverse``1(``0[])">
            <summary>Обращение порядка элементов в массиве</summary>
            <param name="array">
            Обращаемый массив, порядок следования элементов которого требуется перевернуть
            </param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.SetValues``1(``0[],System.Int32,``0[])">
            <summary>Установить значения ячеек массива</summary>
            <param name="array">Массив, значения ячеек которого требуется установить</param>
            <param name="StartIndex">Индекс первой устанавливаемой ячейки</param>
            <param name="Values">Значения, Которые требуется внести с <paramref name="array"/></param>
            <typeparam name="TArray">Тип ячеек массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.ToAlignedRows``1(``0[][])">
            <summary>
            Преобразование массива массивов в двумерный массив, где исходные массивы располагаются построчно
            </summary>
            <param name="array">Массив массивов элементов</param>
            <typeparam name="TArray">Тим элементов</typeparam>
            <returns>Двумерный массив, составленный построчно из исходных массивов</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.ToAlignedCols``1(``0[][])">
            <summary>
            Преобразование массива массивов в двумерный массив, где исходные массивы располагаются по столбцам
            </summary>
            <param name="array">Массив массивов элементов</param>
            <typeparam name="TArray">Тим элементов</typeparam>
            <returns>Двумерный массив, составленный из исходных массивов, расположенных по столбцам</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.ToNonAlignedRows``1(``0[0:,0:])">
            <summary>Преобразовать двумерный массив в массив массивов элементов строк</summary>
            <param name="array">Исходный двумерный массив</param>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <returns>Массив строк двумерного массива <paramref name="array"/></returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.ToNonAlignedCols``1(``0[0:,0:])">
            <summary>Преобразовать двумерный массив в массив массивов элементов столбцов</summary>
            <param name="array">Исходный двумерный массив</param>
            <typeparam name="TArray">Тип элементов массивов</typeparam>
            <returns>Массив столбцов двумерного массива <paramref name="array"/></returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.SetCol``1(``0[0:,0:],``0[],System.Int32)">
            <summary>Установить значения колонки (второй индекс) двумерного массива</summary>
            <param name="array">Двумерный массив, значение столбца которого требуется установить</param>
            <param name="Col">Массив элементов столбца, которые надо установить в <paramref name="array"/></param>
            <param name="m">Номер колонки (второй индекс массива)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentException">
            Если длина <paramref name="Col"/> неравна числу строк (первая размерность) <paramref name="array"/>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер колонки <paramref name="m"/> больше, либо равен числу колонок массива (вторая размерность)
            <paramref name="array"/>, либо меньше 0
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.SetRow``1(``0[0:,0:],``0[],System.Int32)">
            <summary>Установить значения строки (первый индекс) двумерного массива</summary>
            <param name="array">Двумерный массив, значение строки которого требуется установить</param>
            <param name="Row">Массив элементов строки, которые надо установить в <paramref name="array"/></param>
            <param name="n">Номер строки (первый индекс массива)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentException">Если длина <paramref name="Row"/> неравна числу столбцов (вторая размерность) <paramref name="array"/></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер колонки <paramref name="n"/> больше, либо равен числу строк массива (первая размерность)
            <paramref name="array"/>, либо меньше 0
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.GetCol``1(``0[0:,0:],System.Int32)">
            <summary>Получить столбец двумерного массива (второй индекс)</summary>
            <param name="array">Двумерный массив из которого требуется извлечь столбец значений</param>
            <param name="m">Номер столбца массива (второй индекс)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>
            Новый массив, значения которого скопированы из столбца элементов двумерного массива
            с выбранным индексом <paramref name="m"/>
            </returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер столбца больше, либо равен числу столбцов массива (вторая размерность), либо меньше 0
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.GetCol``1(``0[0:,0:],System.Int32,``0[]@)">
            <summary>Получить столбец двумерного массива (второй индекс)</summary>
            <param name="array">Двумерный массив из которого требуется извлечь столбец значений</param>
            <param name="m">Номер столбца массива (второй индекс)</param>
            <param name="Col">Массив столбца (если передана пустая ссылка, то будет создан новый)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер столбца больше, либо равен числу столбцов массива (вторая размерность), либо меньше 0
            </exception>
            <exception cref="T:System.ArgumentException">
            Если размер массива, переданного для копирования элементов столбца,
            не равен числу строк исходного двумерного массива
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.GetRow``1(``0[0:,0:],System.Int32)">
            <summary>Получить строку двумерного массива (первый индекс)</summary>
            <param name="array">Двумерный массив из которого требуется извлечь строку значений</param>
            <param name="n">Номер строки массива (первый индекс)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <returns>Новый массив, значения которого скопированы из строки элементов двумерного массива с выбранным индексом <paramref name="n"/></returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Если номер строки больше, либо равен числу строк массива (первая размерность), либо меньше 0</exception>
        </member>
        <member name="M:System.ArrayExtensions.GetRow``1(``0[0:,0:],System.Int32,``0[]@)">
            <summary>Получить строку двумерного массива (первый индекс)</summary>
            <param name="array">Двумерный массив из которого требуется извлечь строку значений</param>
            <param name="n">Номер строки массива (первый индекс)</param>
            <param name="Row">Массив строки (если передана пустая ссылка, то будет создан новый)</param>
            <typeparam name="TArray">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Если номер строки больше, либо равен числу строк массива (первая размерность), либо меньше 0
            </exception>
        </member>
        <member name="M:System.ArrayExtensions.SwapRows``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>Поменять местами элементы двух строк двумерного массива</summary>
            <param name="array">Массив в котором требуется поменять местами две строки</param>
            <param name="Row1">Индекс первой строки</param>
            <param name="Row2">Индекс второй строки</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.SwapCols``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>Поменять местами два столбца двумерного массива</summary>
            <param name="array">Массив в котором требуется поменять местами два столбца</param>
            <param name="j1">Индекс первого столбца</param>
            <param name="j2">Индекс второго столбца</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на исходный массив</exception>
        </member>
        <member name="M:System.ArrayExtensions.GetMinIndex``1(``0[],System.Comparison{``0})">
            <summary>Найти индекс минимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Comparison{``0})">
            <summary>Найти минимальный элемента в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Comparison{``0},System.Int32@)">
            <summary>Найти минимальный элемента в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <param name="MinIndex">Индекс минимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinIndex``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти индекс минимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Collections.Generic.IComparer{``0},System.Int32@)">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <param name="MinIndex">Индекс минимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinIndex``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти индекс минимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Func{``0,System.Double},System.Int32@)">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <param name="MinIndex">Индекс минимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinIndex``1(``0[])">
            <summary>Найти индекс минимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Индекс минимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[])">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinRef``1(``0[],System.Int32@)">
            <summary>Найти минимальный элемент в массиве и получить ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <param name="MinIndex">Индекс минимального элемента</param>
            <returns>Минимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxIndex``1(``0[],System.Comparison{``0})">
            <summary>Найти индекс максимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс максимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Comparison{``0})">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Comparison{``0},System.Int32@)">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <param name="MaxIndex">Индекс максимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxIndex``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти индекс максимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс максимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Collections.Generic.IComparer{``0},System.Int32@)">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <param name="MaxIndex">Индекс максимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxIndex``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти индекс максимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс максимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Func{``0,System.Double},System.Int32@)">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <param name="MaxIndex">Индекс максимального элемента</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxIndex``1(``0[])">
            <summary>Найти индекс максимального элемента в массиве</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Индекс максимального элемента</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[])">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMaxRef``1(``0[],System.Int32@)">
            <summary>Найти максимальный элемент в массиве и вернуть ссылку на него</summary>
            <param name="array">Массив элементов</param>
            <param name="MaxIndex">Индекс максимального элемента</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Максимальный элемент массива по ссылке</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinMaxIndex``1(``0[],System.Comparison{``0})">
            <summary>Найти индексы минимального и максимального элементов</summary>
            <param name="array">Массив элементов</param>
            <param name="compare">Метод сравнения двух объектов между собой</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального и максимального элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinMaxIndex``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>Найти индексы минимального и максимального элементов</summary>
            <param name="array">Массив элементов</param>
            <param name="Comparer">Объект, обеспечивающий сравнение двух элементов в массиве</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального и максимального элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinMaxIndex``1(``0[],System.Func{``0,System.Double})">
            <summary>Найти индексы минимального и максимального элементов</summary>
            <param name="array">Массив элементов</param>
            <param name="converter">Функция, обеспечивающая преобразования элемента в численное значение для сравнения</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Индекс минимального и максимального элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.GetMinMaxIndex``1(``0[])">
            <summary>Найти индексы минимального и максимального элементов</summary>
            <param name="array">Массив элементов</param>
            <typeparam name="T">Тип элементов массива, поддерживающий возможность сравнения</typeparam>
            <returns>Индекс минимального и максимального элементов массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.CreateSequence(System.Int32,System.Int32)">
            <summary>Создать массив последовательных значений длины <paramref name="length"/> начиная с <paramref name="offset"/></summary>
            <param name="length">Длина массива</param>
            <param name="offset">Начальное значение</param>
            <returns>Массив чисел длины <paramref name="length"/> начиная с <paramref name="offset"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.Mix``1(``0[])">
            <summary>Создать копию массива с перемешанным содержимым</summary>
            <param name="array">Исходный массив</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Копия исходного массива с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.Mix``1(``0[],System.Random)">
            <summary>Создать копию массива с перемешанным содержимым</summary>
            <param name="array">Исходный массив</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="rnd">Генератор случайных чисел</param>
            <returns>Копия исходного массива с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.MixRef``1(``0[],System.Random)">
            <summary>Перемешать массив</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Перемешиваемый массив</param>
            <param name="rnd">Генератор случайных чисел</param>
            <returns>Исходный массив с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.MixRef``1(``0[])">
            <summary>Перемешать массив</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Перемешиваемый массив</param>
            <returns>Исходный массив с перемешанным содержимым</returns>
        </member>
        <member name="M:System.ArrayExtensions.SetSubArrays``1(``0[],``0[][])">
            <summary>Последовательно скопировать набор массивов в буфер</summary>
            <param name="A">Буферный массив соответствующей длины</param>
            <param name="B">Перечень устанавливаемых значений</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.IsContains``1(``0[],``0)">
            <summary>Проверка, что элемент входит в состав массива</summary>
            <param name="array">Проверяемый массив элементов</param>
            <param name="item">Элемент, вхождение в состав массива <paramref name="array"/> которого проверяется</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Истина, если массив <paramref name="array"/> содержит среди своих элементов <paramref name="item"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.Linearize``1(``0[][])">
            <summary>Создать одномерный массив, содержащий все элементы указанных массивов</summary>
            <param name="array">Массив массивов элементов</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>Одномерный массив, содержащий все элементы массивов из <paramref name="array"/></returns>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[0:,0:],System.Action{``0})">
            <summary>Выполнить действие для всех элементов двумерного массива</summary>
            <param name="array">Двумерный массив элементов, действие для всех элементов которого следует выполнить</param>
            <param name="action">Выполняемое действие, получающее в качестве параметра элемент массива</param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Foreach``1(``0[0:,0:],System.Action{System.Int32,System.Int32,``0})">
            <summary>Выполнить действие для всех элементов двумерного массива</summary>
            <param name="array">Двумерный массив элементов, действие для всех элементов которого следует выполнить</param>
            <param name="action">
            Выполняемое действие, получающее в качестве параметра номер строки (первый индекс),
            номер столбца (второй индекс) и элемент массива
            </param>
            <typeparam name="T">Тип элементов массива</typeparam>
        </member>
        <member name="M:System.ArrayExtensions.Select``2(``0[0:,0:],System.Func{``0,``1})">
            <summary>Получить перечисление значений на основе элементов двумерного массива</summary>
            <param name="array">Двумерный массив элементов</param>
            <param name="selector">
            Метод конвертации элемента массива <typeparamref name="TItem"/> в его значение
            <typeparamref name="TValue"/>, получающий в качестве параметра значение элемента массива
            </param>
            <typeparam name="TItem">Тип элементов массива</typeparam>
            <typeparam name="TValue">Тип результата элементов перечисления</typeparam>
            <returns>Перечисление значений, сформированное на основе элементов двумерного массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.Select``2(``0[0:,0:],System.Func{System.Int32,System.Int32,``0,``1})">
            <summary>Получить перечисление значений на основе элементов двумерного массива</summary>
            <param name="array">Двумерный массив элементов</param>
            <param name="selector">
            Метод конвертации элемента массива <typeparamref name="TItem"/> в его значение
            <typeparamref name="TValue"/>, получающий в качестве параметров номер строки (первый индекс),
            номер столбца (второй индекс) и значение элемента массива
            </param>
            <typeparam name="TItem">Тип элементов массива</typeparam>
            <typeparam name="TValue">Тип результата элементов перечисления</typeparam>
            <returns>Перечисление значений, сформированное на основе элементов двумерного массива</returns>
        </member>
        <member name="M:System.ArrayExtensions.ToStringView``1(``0[0:,0:],System.String)">
            <summary>Представить двумерный массив в текстовом виде в виде матрицы</summary>
            <param name="array">Двумерный массив, текстовое представление которого требуется выполнить</param>
            <param name="Splitter">Строка-разделитель элементов матрицы</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>
            Строковое представление двумерного массива в котором строки массива разделены переносом строки
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.ToStringView``2(``0[0:,0:],System.Func{``0,``1},System.String)">
            <summary>Представить двумерный массив в текстовом виде в виде матрицы</summary>
            <param name="array">Двумерный массив, текстовое представление которого требуется выполнить</param>
            <param name="Selector">Метод преобразования значения элемента массива перед его записью</param>
            <param name="Splitter">Строка-разделитель элементов матрицы</param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <typeparam name="TValue">Тип данных, записываемых в текстовую форму представления</typeparam>
            <returns>
            Строковое представление двумерного массива в котором строки массива разделены переносом строки
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.ToStringFormatView``1(``0[0:,0:],System.String,System.String,System.IFormatProvider)">
            <summary>Представить двумерный массив в текстовом виде в виде матрицы</summary>
            <param name="array">Двумерный массив, текстовое представление которого требуется выполнить</param>
            <param name="Format">Строка формата данных каждого элемента</param>
            <param name="Splitter">Строка-разделитель элементов матрицы</param>
            <param name="provider">
            Объект, осуществляющий конечное форматирование элемента массива перед его выводом в текстовую форму
            </param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <returns>
            Строковое представление двумерного массива в котором строки массива разделены переносом строки
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.ToStringFormatView``2(``0[0:,0:],System.Func{``0,``1},System.String,System.String,System.IFormatProvider)">
            <summary>Представить двумерный массив в текстовом виде в виде матрицы</summary>
            <param name="array">Двумерный массив, текстовое представление которого требуется выполнить</param>
            <param name="Selector">Метод преобразования значения элемента массива перед его записью</param>
            <param name="Format">Строка формата данных каждого элемента</param>
            <param name="Splitter">Строка-разделитель элементов матрицы</param>
            <param name="provider">
            Объект, осуществляющий конечное форматирование элемента массива перед его выводом в текстовую форму
            </param>
            <typeparam name="T">Тип элементов массива</typeparam>
            <typeparam name="TValue">Тип данных, записываемых в текстовую форму представления</typeparam>
            <returns>
            Строковое представление двумерного массива в котором строки массива разделены переносом строки
            </returns>
        </member>
        <member name="M:System.ArrayExtensions.ResamplingOptimal(System.Double[],System.Int32,System.Double)">
            <summary>Изменение размера массива с интерполяцией значений методом оптимальной фильтрации</summary>
            <param name="array">Исходный массив значений</param>
            <param name="NewLength">Новая длина массива</param>
            <param name="k0">Коэффициент смещения значений в пределах [0..1]</param>
            <returns>Новый массив изменённой длины с интерполированными значениями</returns>
        </member>
        <member name="M:System.ArrayExtensions.ResamplingOptimal(MathCore.Complex[],System.Int32,System.Double)">
            <summary>Изменение размера массива с интерполяцией комплексных значений методом оптимальной фильтрации</summary>
            <param name="array">Исходный массив комплексных значений</param>
            <param name="NewLength">Новая длина массива</param>
            <param name="k0">Коэффициент смещения значений в пределах [0..1]</param>
            <returns>Новый массив изменённой длины с интерполированными значениями</returns>
        </member>
        <member name="M:System.ArrayExtensions.ResamplingNewton(System.Double[],System.Int32)">
            <summary>Изменение размера массива с интерполяцией значений методом интерполяционного полинома Ньютона</summary>
            <param name="array">Исходный массив значений</param>
            <param name="NewLength">Новая длина массива</param>
            <returns>Новый массив изменённой длины с интерполированными значениями</returns>
        </member>
        <member name="M:System.ArrayExtensions.ResamplingNewton(MathCore.Complex[],System.Int32)">
            <summary>Изменение размера массива с интерполяцией значений методом интерполяционного полинома Ньютона</summary>
            <param name="array">Исходный массив значений</param>
            <param name="NewLength">Новая длина массива</param>
            <returns>Новый массив изменённой длины с интерполированными значениями</returns>
        </member>
        <member name="M:System.ArrayExtensions.ResamplingLagrange(System.Double[],System.Int32)">
            <summary>Изменение размера массива с интерполяцией значений методом интерполяционного полинома Лагранжа</summary>
            <param name="array">Исходный массив значений</param>
            <param name="NewLength">Новая длина массива</param>
            <returns>Новый массив изменённой длины с интерполированными значениями</returns>
        </member>
        <member name="M:System.ArrayExtensions.ResamplingLagrange(MathCore.Complex[],System.Int32)">
            <summary>Изменение размера массива с интерполяцией значений методом интерполяционного полинома Лагранжа</summary>
            <param name="array">Исходный массив значений</param>
            <param name="NewLength">Новая длина массива</param>
            <returns>Новый массив изменённой длины с интерполированными значениями</returns>
        </member>
        <member name="M:System.ArrayExtensions.SwapArrayParts``1(``0[],System.Int32)">
            <summary>Поменять подмассивы местами</summary>
            <typeparam name="T">Тип элементов массива</typeparam>
            <param name="array">Исходный массив</param>
            <param name="Index">Индекс разделения массивов</param>
        </member>
        <member name="T:System.Threading.Tasks.CancellationTokenExtensions">
            <summary>Extension methods for CancellationToken.</summary>
        </member>
        <member name="M:System.Threading.Tasks.CancellationTokenExtensions.CancelAndThrow(System.Threading.CancellationTokenSource)">
            <summary>Cancels a CancellationTokenSource and throws a corresponding OperationCanceledException.</summary>
            <param name="source">The source to be canceled.</param>
        </member>
        <member name="M:System.Threading.Tasks.CancellationTokenExtensions.CreateLinkedSource(System.Threading.CancellationToken)">
            <summary>Creates a CancellationTokenSource that will be canceled when the specified token has cancellation requested.</summary>
            <param name="token">The token.</param>
            <returns>The created CancellationTokenSource.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskCompletionSourceExtensions">
            <summary>Extension methods for TaskCompletionSource.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
            <summary>Transfers the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transferred.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.SetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
            <summary>Transfers the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transferred.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task)">
            <summary>Attempts to transfer the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transferred.</param>
            <returns>Whether the transfer could be completed.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskCompletionSourceExtensions.TrySetFromTask``1(System.Threading.Tasks.TaskCompletionSource{``0},System.Threading.Tasks.Task{``0})">
            <summary>Attempts to transfer the result of a Task to the TaskCompletionSource.</summary>
            <typeparam name="TResult">Specifies the type of the result.</typeparam>
            <param name="ResultSetter">The TaskCompletionSource.</param>
            <param name="task">The task whose completion results should be transferred.</param>
            <returns>Whether the transfer could be completed.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.CAF(System.Threading.Tasks.Task,System.Boolean)">
            <summary><c>.ConfigureAwait(false)</c></summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.CAF``1(System.Threading.Tasks.Task{``0},System.Boolean)">
            <summary><c>.ConfigureAwait(false)</c></summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.YieldAsync">
            <summary>Переход в асинхронную область - в новый поток из пула потоков</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.SwitchContext(System.Threading.Tasks.TaskScheduler)">
            <summary>Переключиться в контекст планировщика потоков</summary>
            <param name="scheduler">Планировщик потоков, распределяющий процессы выполнения задач</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Select``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            https://blogs.msdn.microsoft.com/pfxteam/2010/04/04/a-tour-of-parallelextensionsextras/
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.OneElementGrouping`2">
            <summary>Represents a grouping of one element.</summary>
            <typeparam name="TKey">The type of the key for the element.</typeparam>
            <typeparam name="TElement">The type of the element.</typeparam>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith(System.Threading.Tasks.Task,System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskFactory)">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationAction">The continuation action.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskFactory)">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationFunction">The continuation function.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``1(System.Threading.Tasks.Task{``0},System.Action{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationAction">The continuation action.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ContinueWith``2(System.Threading.Tasks.Task{``0},System.Func{System.Threading.Tasks.Task{``0},``1},System.Threading.Tasks.TaskFactory{``0})">
            <summary>Creates a continuation task using the specified TaskFactory.</summary>
            <param name="task">The antecedent Task.</param>
            <param name="ContinuationFunction">The continuation function.</param>
            <param name="factory">The TaskFactory.</param>
            <returns>A continuation task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToAsync(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Creates a Task that represents the completion of another Task, and 
            that schedules an AsyncCallback to run upon completion.
            </summary>
            <param name="task">The antecedent Task.</param>
            <param name="callback">The AsyncCallback to run.</param>
            <param name="state">The object state to use with the AsyncCallback.</param>
            <returns>The new task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToAsync``1(System.Threading.Tasks.Task{``0},System.AsyncCallback,System.Object)">
            <summary>
            Creates a Task that represents the completion of another Task, and 
            that schedules an AsyncCallback to run upon completion.
            </summary>
            <param name="task">The antecedent Task.</param>
            <param name="callback">The AsyncCallback to run.</param>
            <param name="state">The object state to use with the AsyncCallback.</param>
            <returns>The new task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.IgnoreExceptions(System.Threading.Tasks.Task)">
            <summary>Suppresses default exception handling of a Task that would otherwise reraise the exception on the finalizer thread.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.IgnoreExceptions``1(System.Threading.Tasks.Task{``0})">
            <summary>Suppresses default exception handling of a Task that would otherwise reraise the exception on the finalizer thread.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.FailFastOnException(System.Threading.Tasks.Task)">
            <summary>Fails immediately when an exception is encountered.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.FailFastOnException``1(System.Threading.Tasks.Task{``0})">
            <summary>Fails immediately when an exception is encountered.</summary>
            <param name="task">The Task to be monitored.</param>
            <returns>The original Task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.PropagateExceptions(System.Threading.Tasks.Task)">
            <summary>Propagates any exceptions that occurred on the specified task.</summary>
            <param name="task">The Task whose exceptions are to be propagated.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.PropagateExceptions(System.Threading.Tasks.Task[])">
            <summary>Propagates any exceptions that occurred on the specified tasks.</summary>
            <param name="tasks">The Task whose exceptions are to be propagated.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.ToObservable``1(System.Threading.Tasks.Task{``0})">
            <summary>Creates an IObservable that represents the completion of a Task.</summary>
            <typeparam name="TResult">Specifies the type of data returned by the Task.</typeparam>
            <param name="task">The Task to be represented as an IObservable.</param>
            <returns>An IObservable that represents the completion of the Task.</returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.TaskObservable`1">
            <summary>An implementation of IObservable that wraps a Task.</summary>
            <typeparam name="TResult">The type of data returned by the task.</typeparam>
        </member>
        <member name="T:System.Threading.Tasks.TaskEx.CancelOnDispose">
            <summary>Translate a call to IDisposable.Dispose to a CancellationTokenSource.Cancel.</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WithTimeout(System.Threading.Tasks.Task,System.TimeSpan@)">
            <summary>Creates a new Task that mirrors the supplied task but that will be canceled after the specified timeout.</summary>
            <param name="task">The task.</param>
            <param name="timeout">The timeout.</param>
            <returns>The new Task that may time out.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WithTimeout``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>Creates a new Task that mirrors the supplied task but that will be canceled after the specified timeout.</summary>
            <typeparam name="TResult">Specifies the type of data contained in the task.</typeparam>
            <param name="task">The task.</param>
            <param name="timeout">The timeout.</param>
            <returns>The new Task that may time out.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.AttachToParent(System.Threading.Tasks.Task)">
            <summary>
            Ensures that a parent task can't transition into a completed state
            until the specified task has also completed, even if it's not
            already a child task.
            </summary>
            <param name="task">The task to attach to the current task as a child.</param>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.WaitForCompletionStatus(System.Threading.Tasks.Task)">
            <summary>Waits for the task to complete execution, returning the task's final status.</summary>
            <param name="task">The task for which to wait.</param>
            <returns>The completion status of the task.</returns>
            <remarks>Unlike Wait, this method will not throw an exception if the task ends in the Faulted or Canceled state.</remarks>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then(System.Threading.Tasks.Task,System.Action)">
            <summary>Creates a task that represents the completion of a follow-up action when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The action to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the action.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task,System.Func{``0})">
            <summary>Creates a task that represents the completion of a follow-up function when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The function to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the function.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task{``0},System.Action{``0})">
            <summary>Creates a task that represents the completion of a follow-up action when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The action to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the action.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            <summary>Creates a task that represents the completion of a follow-up function when a task completes.</summary>
            <param name="task">The task.</param>
            <param name="next">The function to run when the task completes.</param>
            <returns>The task that represents the completion of both the task and the function.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task based on the result of the first task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Creates a task that represents the completion of a second task when a first task completes.</summary>
            <param name="task">The first task.</param>
            <param name="next">The function that produces the second task based on the result of the first.</param>
            <returns>The task that represents the completion of both the first and second task.</returns>
        </member>
        <member name="M:System.Threading.Tasks.YieldAwaiterExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Boolean)">
            <summary>Продолжить в пуле потоков</summary>
            <param name="LockContext">Если истина, то продолжение будет выполнено в том же потоке, если ложь - то в пуле потоков</param>
        </member>
        <member name="M:System.Threading.Tasks.YieldAwaiterExtensions.ConfigureAwaitLongRunning(System.Runtime.CompilerServices.YieldAwaitable)">
            <summary>Продолжить в новом потоке</summary>
        </member>
        <member name="M:System.Threading.Tasks.YieldAwaiterExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Threading.Tasks.TaskScheduler)">
            <summary>Выполнить продолжение в указанном планировщике</summary>
            <param name="Scheduler">Планировщик, в котором требуется выполнить продолжение</param>
        </member>
        <member name="M:System.Threading.Tasks.YieldAwaiterExtensions.ConfigureAwait(System.Runtime.CompilerServices.YieldAwaitable,System.Threading.SynchronizationContext)">
            <summary>Выполнить продолжение в указанном контексте синхронизации</summary>
            <param name="context">Контекст синхронизации, в котором требуется выполнить продолжение</param>
        </member>
        <member name="T:System.ComponentModel.BindingListExtensions">
            <summary>Класс методов-расширений для <see cref="T:System.ComponentModel.BindingList`1"/></summary>
        </member>
        <member name="M:System.ComponentModel.BindingListExtensions.Initialize``1(System.ComponentModel.BindingList{``0},System.Int32,System.Func{System.Int32,``0})">
            <summary>Инициализация нового экземпляра <see cref="T:System.ComponentModel.BindingList`1"/> с помощью функции</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <param name="list">Инициализируемый <see cref="T:System.ComponentModel.BindingList`1"/></param>
            <param name="ElementsCount">Число добавляемых элементов</param>
            <param name="Initializer">Функция генерации новых элементов списка</param>
            <returns>Инициализируемый <see cref="T:System.ComponentModel.BindingList`1"/></returns>
        </member>
        <member name="M:System.ComponentModel.BindingListExtensions.Initialize``2(System.ComponentModel.BindingList{``0},System.Int32,``1,System.Func{System.Int32,``1,``0})">
            <summary>Инициализация нового экземпляра <see cref="T:System.ComponentModel.BindingList`1"/> с помощью функции</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <typeparam name="TParameter">Тип параметра инициализации</typeparam>
            <param name="list">Инициализируемый <see cref="T:System.ComponentModel.BindingList`1"/></param>
            <param name="ElementsCount">Число добавляемых элементов</param>
            <param name="parameter">Параметр процесса инициализации, передаваемый в функцию</param>
            <param name="Initializer">Функция генерации новых элементов списка</param>
            <returns>Инициализируемый <see cref="T:System.ComponentModel.BindingList`1"/></returns>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions">
            <summary>Класс методов-расширений интерфейса <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String)">
            <summary>Подписка на событие изменения указанного свойства</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Name">Имя свойства</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String)">
            <summary>Подписка на событие изменения указанного свойства</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Name">Имя свойства</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String[])">
            <summary>Подписка на событие изменения указанных свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свойств</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.String[])">
            <summary>Подписка на событие изменения указанных свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свойств</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Подписка на событие изменения указанных свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свойств</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegisterPropertyChangedHandler_Disposable(System.ComponentModel.INotifyPropertyChanged,System.ComponentModel.PropertyChangedEventHandler,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Подписка на событие изменения указанных свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="handler">Обработчик события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> типа <see cref="T:System.ComponentModel.PropertyChangedEventHandler"/></param>
            <param name="Names">Имена свойств</param>
            <returns>Объект <see cref="T:System.IDisposable"/>, вызывающий отписку от события в случае своего уничтожения</returns>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs">
            <summary>Аргумент события изменения зависимого свойства</summary>
        </member>
        <member name="P:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs.FromProperties">
            <summary>Перечень свойств, породивших изменение</summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.DependentPropertyChangedEventArgs.#ctor(System.String,System.String[])">
            <summary>Инициализация нового аргумента события изменения зависимого свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
            <param name="FromProperties">Список свойств, породивших изменение</param>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.__ObjectsSet">
            <summary>Перечень слабых ссылок на отслеживаемые объекты</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.__RegistrationPool">
            <summary>Словарь описаний связей между свойствами типов</summary>
        </member>
        <member name="T:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo">
            <summary>Информация о связях между свойствами типов</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo._Dependencies">
            <summary>Словарь связей имён свойств типа</summary>
        </member>
        <member name="F:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo._Handler">
            <summary>Обработчик события изменения свойства объекта</summary>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.#ctor(System.Collections.Generic.Dictionary{System.String,System.String[]})">
            <summary>Инициализация нового экземпляра информации и связях между свойствами типа</summary>
            <param name="Dependencies">Словарь имён свойств зависимостей</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.Subscribe(System.ComponentModel.INotifyPropertyChanged,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>Метод установки обработчика событий обновления свойства объекта, генерирующего вторичные события обновления зависимых свойств</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/> в объекте <paramref name="obj"/></param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.RegistratorInfo.UnSubscribe(System.ComponentModel.INotifyPropertyChanged)">
            <summary>Отписка от события обновления свойств объекта</summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.OnGarbageCollected(System.Object,System.EventArgs)">
            <summary>Обработка событий сборки мусора в системе</summary>
            <param name="Sender">Источник события - не используется</param>
            <param name="e">Аргумент события - не используется</param>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependencies_Register``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>Создание связей между свойствами объекта на основе атрибутов <see cref="T:System.AffectsTheAttribute"/> и <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события обновления свойства</param>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependencies_Register_Disposable``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})">
            <summary>Создание связей между свойствами объекта на основе атрибутов <see cref="T:System.AffectsTheAttribute"/> и <see cref="T:System.DependencyOnAttribute"/></summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <param name="OnPropertyChanged">Метод генерации события обновления свойства</param>
            <typeparam name="T">Тип объекта</typeparam>
            <returns></returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependencies_Unregister``1(``0)">
            <summary>Разрушение связей между свойствами, созданными методом <see cref="M:System.ComponentModel.INotifyPropertyChangedExtensions.PropertyDependencies_Register``1(``0,System.Action{System.ComponentModel.PropertyChangedEventArgs})"/></summary>
            <param name="obj">Объект, реализующий интерфейс <see cref="T:System.ComponentModel.INotifyPropertyChanged"/></param>
            <typeparam name="T">Тип объекта</typeparam>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.GetRegistrator(System.Type)">
            <summary>Метод получения информации о связях между свойствами объекта класса</summary>
            <param name="type">Тип рассматриваемого объекта</param>
            <returns>Информация о связях между свойствами объекта</returns>
        </member>
        <member name="M:System.ComponentModel.INotifyPropertyChangedExtensions.SubscribeTo``1(``0,System.String,System.ComponentModel.PropertyChangedEventHandler)">
            <summary>Подписаться на событие изменения свойства</summary>
            <typeparam name="T">Тип объекта, генерирующего событие</typeparam>
            <param name="obj">Объект, на событие изменения свойств которого производится подписка</param>
            <param name="PropertyName">Имя отслеживаемого свойства</param>
            <param name="Handler">Обработчик события</param>
        </member>
        <member name="T:System.BoolExtensions">
            <summary>Методы-расширения для логических значений</summary>
        </member>
        <member name="M:System.BoolExtensions.And(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Вычислить поэлементную операцию И со всеми элементами перечисления.
            Все элементы перечисления будут перебраны в обязательном порядке
            </summary>
            <param name="items">Перечисление логических значений</param>
            <returns>Результат вычисления логического И для всех значений перечисления</returns>
        </member>
        <member name="M:System.BoolExtensions.AndLazy(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Вычислить поэлементную операцию (ленивое) И со всеми элементами перечисления.
            Перебор элементов перечисления производится до появления первого значения <see langword="false"/>
            </summary>
            <param name="items">Перечисление логических значений</param>
            <returns>Результат вычисления логического И для значений перечисления</returns>
        </member>
        <member name="M:System.BoolExtensions.Or(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Вычислить поэлементную операцию ИЛИ со всеми элементами перечисления.
            Все элементы перечисления будут перебраны в обязательном порядке
            </summary>
            <param name="items">Перечисление логических значений</param>
            <returns>Результат вычисления логического ИЛИ для всех значений перечисления</returns>
        </member>
        <member name="M:System.BoolExtensions.OrLazy(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            Вычислить поэлементную операцию (ленивое) ИЛИ со всеми элементами перечисления.
            Перебор элементов перечисления производится до появления первого значения <see langword="false"/>
            </summary>
            <param name="items">Перечисление логических значений</param>
            <returns>Результат вычисления логического ИЛИ для значений перечисления</returns>
        </member>
        <member name="T:System.ByteArrayExtensions">
            <summary>Класс методов-расширений для массивов байт</summary>
        </member>
        <member name="M:System.ByteArrayExtensions.ComputeSHA256(System.Byte[])">
            <summary>Вычислить контрольную сумму массива с применением алгоритма SHA256</summary>
            <param name="bytes">Массив байт для которого производится вычисление суммы SHA256</param>
            <returns>Массив байт рассчитанной суммы SHA256</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ComputeSHA256(System.Byte[],System.Int32,System.Int32)">
            <summary>Вычислить контрольную сумму массива с применением алгоритма SHA256</summary>
            <param name="bytes">Массив байт для которого производится вычисление суммы SHA256</param>
            <param name="offset">Индекс элемента массива с которого требуется вычислить контрольную суммы</param>
            <param name="count">Число элементов массива, участвующих в расчёте суммы</param>
            <returns>Массив байт рассчитанной суммы SHA256</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ComputeMD5(System.Byte[])">
            <summary>Вычислить контрольную сумму массива с применением алгоритма MD5</summary>
            <param name="bytes">Массив байт для которого производится вычисление суммы MD5</param>
            <returns>Массив байт рассчитанной суммы MD5</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ComputeMD5(System.Byte[],System.Int32,System.Int32)">
            <summary>Вычислить контрольную сумму массива с применением алгоритма MD5</summary>
            <param name="bytes">Массив байт для которого производится вычисление суммы MD5</param>
            <param name="offset">Индекс элемента массива с которого требуется вычислить контрольную суммы</param>
            <param name="count">Число элементов массива, участвующих в расчёте суммы</param>
            <returns>Массив байт рассчитанной суммы MD5</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToInt16Array(System.Byte[],System.Int16[])">
            <summary>Преобразовать массив байт в массив целых чисел длиной два байта каждое</summary>
            <param name="array">Массив байт чётной</param>
            <param name="Destination">Массив двухбайтовых целых чисел, на который осуществляется проекция в памяти массива байт</param>
        </member>
        <member name="M:System.ByteArrayExtensions.ToInt16Array(System.Byte[])">
            <summary>Преобразовать массив байт в массив целых чисел длиной два байта каждое</summary>
            <param name="array">Массив байт чётной</param>
            <returns>Новый массив двухбайтовых целых чисел, на который осуществляется проекция в памяти массива байт</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToInt32Array(System.Byte[],System.Int32[])">
            <summary>Преобразовать массив байт в массив целых чисел длиной четыре байта каждое</summary>
            <param name="array">Массив байт чётной</param>
            <param name="Destination">Массив четырёхбайтных целых чисел, на который осуществляется проекция в памяти массива байт</param>
        </member>
        <member name="M:System.ByteArrayExtensions.ToInt32Array(System.Byte[])">
            <summary>Преобразовать массив байт в массив целых чисел длиной четыре байта каждое</summary>
            <param name="array">Массив байт чётной</param>
            <returns>Новый массив четырёхбайтных целых чисел, на который осуществляется проекция в памяти массива байт</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToInt(System.Byte[])">
            <summary>Рассчитать четырёхбайтную сумму массива байт с переполнением</summary>
            <param name="array">Массив байт, сумму которого требуется рассчитать</param>
            <returns>Целое четырёхбайтное со знаком, сверяющиеся результатом вычисления суммы байт исходного массива с переполнением</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToUInt(System.Byte[])">
            <summary>Рассчитать четырёхбайтную (без знака) сумму массива байт с переполнением</summary>
            <param name="array">Массив байт, сумму которого требуется рассчитать</param>
            <returns>Целое четырёхбайтное без знака, сверяющиеся результатом вычисления суммы байт исходного массива с переполнением</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToLong(System.Byte[])">
            <summary>Рассчитать восьмибайтную сумму массива байт с переполнением</summary>
            <param name="array">Массив байт, сумму которого требуется рассчитать</param>
            <returns>Целое восьмибайтное со знаком, сверяющиеся результатом вычисления суммы байт исходного массива с переполнением</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToULong(System.Byte[])">
            <summary>Рассчитать восьмибайтную (без знака) сумму массива байт с переполнением</summary>
            <param name="array">Массив байт, сумму которого требуется рассчитать</param>
            <returns>Целое восьмибайтное без знака, сверяющиеся результатом вычисления суммы байт исходного массива с переполнением</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToStringHex(System.Byte[],System.Boolean)">
            <summary>Преобразование массива байт в строку в HEX формате</summary>
            <param name="array">Кодируемый массив</param>
            <param name="UpperString">Преобразование в строку в верхнем регистре</param>
            <returns>Строковое представление массива</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToStringHexWords(System.UInt32[],System.Boolean)">
            <summary>Преобразование массива байт в строку в HEX формате</summary>
            <param name="array">Кодируемый массив</param>
            <param name="UpperString">Преобразование в строку в верхнем регистре</param>
            <returns>Строковое представление массива</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ToStringHexBytes(System.UInt32[],System.Boolean)">
            <summary>Преобразование массива байт в строку в HEX формате</summary>
            <param name="array">Кодируемый массив</param>
            <param name="UpperString">Преобразование в строку в верхнем регистре</param>
            <returns>Строковое представление массива</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.ClearByteArrayString(System.String)">
            <summary>Удаление технических символов из строки массива</summary>
            <param name="str">Сырая строка массива</param>
            <returns>Строка с удалёнными техническими символами</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.FromHexByteArrayString(System.String)">
            <summary>Преобразование массива байт из строкового представления в формате HEX в массив</summary>
            <param name="str">Строковое представление массива байт в HEX-формате</param>
            <returns>Массив байт</returns>
            <exception cref="T:System.FormatException"></exception>
        </member>
        <member name="M:System.ByteArrayExtensions.ToStringBase64(System.Byte[])">
            <summary>Преобразование массива в строковое представление в кодировке Base64</summary>
            <param name="array">Кодируемый массив</param>
            <returns>Строковое представление массива в представлении Base64</returns>
        </member>
        <member name="M:System.ByteArrayExtensions.FromBase64ByteArrayString(System.String)">
            <summary>Преобразование строки в кодировке Base64 в массив байт</summary>
            <param name="str">Строковое представление массива байт в кодировке Base64</param>
            <returns>Массив байт</returns>
        </member>
        <member name="T:System.DateTimeExtensions">
            <summary>Класс методов-расширений для даты-времени <see cref="T:System.DateTime"/></summary>
        </member>
        <member name="M:System.DateTimeExtensions.ToBytArray(System.DateTime)">
            <summary>Преобразование структуры <see cref="T:System.DateTime"/> в массив байт</summary>
            <param name="Time">Дата/время</param>
            <returns>Массив</returns>
        </member>
        <member name="M:System.DateTimeExtensions.ToByteArray(System.DateTime,System.Byte[],System.Int32)">
            <summary>Копирование значения структуры даты-времени в массив байт с заданным смещением</summary>
            <param name="Time">Структура даты-времени</param>
            <param name="Data">Массив байт, куда требуется записать значение</param>
            <param name="Offset">Смещение в массиве байт</param>
        </member>
        <member name="M:System.DateTimeExtensions.FromBytArray(System.Byte[],System.Int32)">
            <summary>Преобразование массива байт в <see cref="T:System.DateTime"/></summary>
            <param name="Data">Массив байт</param>
            <param name="Offset">Смещение в массиве</param>
            <returns>Структура <see cref="T:System.DateTime"/></returns>
        </member>
        <member name="T:System.FuncExtensions">
            <summary>Класс методов-расширений для функции</summary>
        </member>
        <member name="M:System.FuncExtensions.InvokeAsync``1(System.Func{``0})">
            <summary>синхронный вызов функции</summary>
            <param name="func">Вызываемая функция</param>
            <typeparam name="TResult">Тип значения функции</typeparam>
            <returns>Задача асинхронного вычисления значения функции</returns>
        </member>
        <member name="M:System.FuncExtensions.InvokeAsync``2(System.Func{``0,``1},``0)">
            <summary>синхронный вызов функции</summary>
            <param name="func">Вызываемая функция</param>
            <param name="value">Значение параметра функции</param>
            <typeparam name="TValue">Тип параметра функции</typeparam>
            <typeparam name="TResult">Тип значения функции</typeparam>
            <returns>Задача асинхронного вычисления значения функции</returns>
        </member>
        <member name="M:System.FuncExtensions.ToEvaluation``1(System.Func{``0},System.String)">
            <summary>Преобразование функции в вычисление</summary>
            <typeparam name="T">Тип возвращаемого функцией результата</typeparam>
            <param name="function">Преобразуемая функция</param>
            <param name="Name">Имя вычисления</param>
            <returns>Вычисление функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_NewtonsMethod(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом Ньютона</summary>
            <param name="f">Исследуемая функция</param>
            <param name="df">Дифференциал исследуемой функции</param>
            <param name="x0">Начальное приближение</param>
            <param name="MaxIterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_NewtonsMethodAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом Ньютона</summary>
            <param name="f">Исследуемая функция</param>
            <param name="df">Дифференциал исследуемой функции</param>
            <param name="x0">Начальное приближение</param>
            <param name="MaxIterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_BisectionMethod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary> Поиск нуля функции методом бисекции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="MaxIterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.ArithmeticException"><paramref name="f" /> is equal to <see cref="F:System.Double.NaN" />. </exception>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_BisectionMethodAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary> Поиск нуля функции методом бисекции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="MaxIterations">Максимальное количество итераций. <exception cref="T:System.IndexOutOfRangeException"/> при превышении</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.ArithmeticException"><paramref name="f" /> is equal to <see cref="F:System.Double.NaN" />. </exception>
            <exception cref="T:System.IndexOutOfRangeException">Если корень не найден за указанное число шагов</exception>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_GoldenSection(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Золотого сечения</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_GoldenSectionAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Золотого сечения</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_TernarySearch(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Троичного деления</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_TernarySearchAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом Троичного деления</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_FalsePositionMethod(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом False position</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="MaxIterations">Максимальное допустимое число итераций метода</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_FalsePositionMethodAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Поиск нуля функции методом False position</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="MaxIterations">Максимальное допустимое число итераций метода</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_MethodOfChords(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом хорд</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.GetRoot_MethodOfChordsAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary> Поиск нуля функции методом хорд</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала поиска</param>
            <param name="x2">Конец интервала поиска</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Значение аргумента нуля функции</returns>
            <exception cref="T:System.Exception">A delegate callback throws an exception.</exception>
        </member>
        <member name="M:System.FuncExtensions.Carrying``3(System.Func{``0,``1,``2})">
            <summary>Каррирование функции двух параметров</summary>
            <typeparam name="TArg1">Тип значение первого параметра функции</typeparam>
            <typeparam name="TArg2">Тип значение второго параметра функции</typeparam>
            <typeparam name="TResult">Тип результата функции</typeparam>
            <param name="f">Каррируемая функция</param>
        </member>
        <member name="M:System.FuncExtensions.Add(System.Func{System.Double,System.Double},System.Double)">
            <summary>Сложение функции с числом g(x) = f(x) + a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Прибавляемое число</param>
            <returns>Новая функция, значения которой равны значениям исходной функции плюс указанному числу</returns>
        </member>
        <member name="M:System.FuncExtensions.Add(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Сложение двух функций g(x) = f1(x) + f2(x)</summary>
            <param name="f1">Функция - первое слагаемое</param>
            <param name="f2">Функция - второе слагаемое</param>
            <returns>Функция, значения которой равны сумме значений двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtensions.ArgumentReverse(System.Func{System.Double,System.Double})">
            <summary>Изменение знака аргумента функции g(x) = f(-x)</summary>
            <param name="f">Исходная функция</param>
            <returns>Новая функция, значения аргумента которой отрицательны по отношению к аргументу исходной функции g(x) = f(-x)</returns>
        </member>
        <member name="M:System.FuncExtensions.ArgumentShift(System.Func{System.Double,System.Double},System.Double)">
            <summary>Смещение аргумента функции на указанное значение g(x) = f(x-a)</summary>
            <param name="f">Исходная функция</param>
            <param name="x0">Значение смещения аргумента</param>
            <returns>Новая функция со смещённым аргументом</returns>
        </member>
        <member name="M:System.FuncExtensions.ArgumentCompression(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Сжатие аргумента функции g(x) = f(k * x + b)</summary>
            <param name="f">Исходная функция</param>
            <param name="k">Коэффициент сжатия аргумента</param>
            <param name="b">Коэффициент смещения аргумента</param>
            <returns>Новая функция со сжатым и смещённым аргументом</returns>
        </member>
        <member name="M:System.FuncExtensions.Divide(System.Func{System.Double,System.Double},System.Double)">
            <summary>Деление функции на число g(x) = f(x) / a</summary>
            <param name="f">Делимая функция</param>
            <param name="a">Вещественный делитель</param>
            <returns>
            Функция, значения которой равны значениям исходной функции, делимые на вещественный делитель.
            Если вещественный делитель равен 0, то возвращается функция, значения которой равны +бесконечности если
            аргумент больше нуля, -бесконечности, если аргумент меньше нуля и NaN, если аргумент равен нулю.
            </returns>
        </member>
        <member name="M:System.FuncExtensions.Divide(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Деление функции на функцию g(x) = f1(x) / f2(x)</summary>
            <param name="f1">Функция - делимое</param>
            <param name="f2">Функция - делитель</param>
            <returns>Функция, значения которой равны отношению значений исходных функций</returns>
        </member>
        <member name="M:System.FuncExtensions.Func(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Функция от функции q(f(x))</summary>
            <param name="f">Внутренняя функция</param>
            <param name="q">Внешняя функция</param>
            <returns>Функция q от функции f</returns>
        </member>
        <member name="M:System.FuncExtensions.FuncFrom``2(System.Func{``0,``1},System.Func{System.Func{``0,``1},System.Func{``0,``1}})">
            <summary>Функция от функции - функционал (преобразователь функции)</summary>
            <typeparam name="TIn">Тип аргумента функции</typeparam>
            <typeparam name="TOut">Тип значения функции</typeparam>
            <param name="f">Исходная (преобразуемая) функция</param>
            <param name="q">Метод преобразования исходной функции, тип значения которого соответствует типу исходной функции</param>
            <returns>Новая функция, преобразованная указанным методом на основе исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.FuncFor(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Функция от функции f(q(x))</summary>
            <param name="f">Внешняя функция</param>
            <param name="q">Внутренняя функция</param>
            <returns>Функция f от функции q</returns>
        </member>
        <member name="M:System.FuncExtensions.GetAkf(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Получить автокорреляционную функцию от указанной функции</summary>
            <param name="f">Исходная функция</param>
            <param name="DeltaX">Диапазон корреляции</param>
            <param name="x0">Смещение</param>
            <returns>Автокорреляционная функция</returns>
        </member>
        <member name="M:System.FuncExtensions.GetConvolution(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Функция корреляции между двумя функциями на указанному интервале корреляции с указанным смещением</summary>
            <param name="f">Первая функция</param>
            <param name="g">Вторая функция</param>
            <param name="DeltaX">Интервал корреляции</param>
            <param name="x0">Смещение</param>
            <returns>Функция корреляции двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetDifferential(System.Func{System.Double,System.Double},System.Double,System.Int32)">
            <summary>Функция численного дифференцирования исходной функции</summary>
            <param name="f">Исходная функция</param>
            <param name="dx">Дифференциальный участок</param>
            <param name="n">Номер метода численного дифференцирования в пределах [0,4]</param>
            <returns>Функция численного дифференциала от исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetDifferentialValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Определение значения численного дифференциала в указанной точке, с указанным шагом дифференцирования и номером метода</summary>
            <param name="f">Дифференцируемая функция</param>
            <param name="x">Точка дифференцирования</param>
            <param name="dx">Шаг дифференцирования</param>
            <param name="n">Номер метода</param>
            <returns>Численное значение дифференциала функции в указанной точке</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValueAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral2Value(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Двойной определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата двойного численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral2ValueAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Определённый численный интеграл функции (метод трапеций)</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начальное значение интервала интегрирования</param>
            <param name="x2">Конечное значение интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение результата численного интегрирования функции методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Интегрирование функции с модификацией ядра интеграла</summary>
            <param name="f">Подинтегральная функция f(x)</param>
            <param name="Core">Ядро интегрирования: Core(f(x),x)</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение определённого интеграла от ядра интегрирования методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValueAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Рассчитать интеграл функции асинхронно</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="Core">Ядро интегрирования</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции (задача Коши)</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Задача расчёта значения интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral2Value(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Интегрирование функции с модификацией ядра интеграла</summary>
            <param name="f">Подинтегральная функция f(x)</param>
            <param name="Core">Ядро интегрирования: Core(f(x),x)</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <param name="f1">Начальное значение первой производной</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Значение определённого интеграла от ядра интегрирования методом трапеций</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral2ValueAsync(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Асинхронный расчёт двойного интеграла функции</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="Core">Ядро интегрирования</param>
            <param name="x1">Начало интервала интегрирования</param>
            <param name="x2">Конец интервала интегрирования</param>
            <param name="f0">Начальное значение функции (задача Коши)</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Задача численного расчёта второго интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_Simpson(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Численный расчёт определённого интеграла методом Симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Число интервалов интегрирования N > 2</param>
            <returns>Интеграл функции на отрезке методом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_Simpson(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="dx">Шаг интегрирования</param>
            <param name="f0">Начальное значение функции</param>
            <returns>Интеграл функции на отрезке методом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_SimpsonAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Численный расчёт определённого интеграла методом симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Число интервалов интегрирования N > 2</param>
            <returns>Интеграл функции на отрезке методом Симпсона</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_Adaptive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения с базовым алгоритмом Симпсона</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка (по умолчанию 2 точки)</param>
            <param name="Eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
            <remarks>
            Функция рекуррентно на каждом этапе рассчитывает два численных интеграла (методом Симпсона): для указанного числа точек и для удвоенного.
            Если разница между рассчитанными интегралами меньше указанной точности, то возвращается значение интеграла для удвоенного числа точек
            Иначе рекуррентно рассчитывается сумма двух интегралов (адаптивным методом) для правой и левой половины интервала интегрирования с удвоенным
            числом точек для каждого из них. Для каждой половины рекуррентно повторяется проделанная процедура 
            </remarks>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_AdaptiveTrapRecursive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения с базовым алгоритмом Трапеций</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка (по умолчанию 2 точки)</param>
            <param name="Eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
            <remarks>
            Функция рекуррентно на каждом этапе рассчитывает два численных интеграла (методом Трапеций): для указанного числа точек и для удвоенного.
            Если разница между рассчитанными интегралами меньше указанной точности, то возвращается значение интеграла для удвоенного числа точек
            Иначе рекуррентно рассчитывается сумма двух интегралов (адаптивным методом) для правой и левой половины интервала интегрирования с удвоенным
            числом точек для каждого из них. Для каждой половины рекуррентно повторяется проделанная процедура 
            </remarks>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_AdaptiveAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32,System.Double)">
            <summary>Численный расчёт определённого интеграла методом адаптивного разбиения</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Нижний предел интегрирования</param>
            <param name="x2">Верхний предел интегрирования</param>
            <param name="N">Начальное разбиение отрезка</param>
            <param name="Eps">Точность вычисления интеграла</param>
            <returns>Адаптивный интеграл функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_Spline(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Значение интеграла функции методом сплайнов</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начало отрезка интегрирования</param>
            <param name="x2">Конец отрезка интегрирования</param>
            <param name="N">Разбиение интервала интегрирования</param>
            <returns>Значение интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegralValue_SplineAsync(System.Func{System.Double,System.Double},System.Double,System.Double,System.Int32)">
            <summary>Значение интеграла функции методом сплайнов</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x1">Начало отрезка интегрирования</param>
            <param name="x2">Конец отрезка интегрирования</param>
            <param name="N">Разбиение интервала интегрирования</param>
            <returns>Значение интеграла функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetIntegral(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Получить функцию-интеграл от функции</summary>
            <param name="f">Подинтегральная функция</param>
            <param name="x0">Начальное положение интегрирования</param>
            <param name="C">Константа интегрирования</param>
            <param name="Eps">Точность интегрирования</param>
            <returns>Функция-интеграл от исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.GetPeriodic(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Создать периодическую функцию на основе исходной</summary>
            <param name="f">Исходная функция</param>
            <param name="T">Период</param>
            <param name="x0">Смещение</param>
            <returns>Периодическая функция</returns>
        </member>
        <member name="M:System.FuncExtensions.GetPower(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Определить мощность функции</summary>
            <param name="f">Исследуемая функция</param>
            <param name="x1">Начало интервала</param>
            <param name="x2">Конец интервала</param>
            <returns>Значение интеграла от квадрата функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Sampling``1(System.Func{System.Double,``0},System.Double,System.Double,System.Double)">
            <summary>Дискретизация функции</summary>
            <typeparam name="T">Тип значения функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Перечисление дискретных значений функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Sampling``1(System.Func{System.Double,``0},System.Double,System.Double,System.Int32)">
            <summary>Дискретизация функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="dx">Шаг изменения аргумента</param>
            <param name="SamplesCount">Число формируемых отсчётов</param>
            <typeparam name="T">Тип значения функции</typeparam>
            <returns>Массив значений функции, полученных в результате дискретизации</returns>
            <exception cref="T:System.ArgumentNullException">Если передана пустая ссылка на функцию</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Если указано число отсчётов меньше 0, либо если <paramref name="dx"/> равен 0</exception>
        </member>
        <member name="M:System.FuncExtensions.GetValues``2(System.Func{``0,``1},``0[])">
            <summary>Определение значений функции в дискретном перечне значений аргумента</summary>
            <typeparam name="TArgument">Тип аргумента</typeparam>
            <typeparam name="TResult">Тип значения функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="args">Массив аргументов функции</param>
            <returns>Массив значений функции для указанных значений аргументов</returns>
        </member>
        <member name="M:System.FuncExtensions.GetValues``1(System.Func{System.Double,``0},System.Double,System.Double,System.Double)">
            <summary>Получить массив значений функции на указанном интервале с указанным шагом дискретизации</summary>
            <typeparam name="TResult">Тип значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Inverse(System.Func{System.Double,System.Double})">
            <summary>Получить функцию, значения которой обратны к значениям исходной функции g(x) = 1 / f(x)</summary>
            <param name="f">Исходная функция</param>
            <returns>Функция, значения которой обратны по отношению исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Multiply(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Произведение двух функций g(x) = f1(x) * f2(x)</summary>
            <param name="f1">Функция - первый сомножитель</param>
            <param name="f2">Функция - второй сомножитель</param>
            <returns>Функция - произведение двух функций</returns>
        </member>
        <member name="M:System.FuncExtensions.Multiply(System.Func{System.Double,System.Double},System.Double)">
            <summary>Произведение функции на число g(x) = f(x) * a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Число</param>
            <returns>Функция, значения которой равны произведению значений исходной функции на указанное число</returns>
        </member>
        <member name="M:System.FuncExtensions.Power(System.Func{System.Double,System.Double},System.Double)">
            <summary>Возведение функции в вещественную степень</summary>
            <param name="f">Исходная функция</param>
            <param name="a">Вещественная степень</param>
            <returns>Функция, значения которой равны возведению в указанную степень значений исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.Reverse(System.Func{System.Double,System.Double})">
            <summary>Получение отрицательной функции</summary>
            <param name="f">Исходная функция</param>
            <returns>Функция, значения которой обратны по знаку к исходной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.SetParameter(System.Func{System.Double,System.Double,System.Double},System.Double,System.Boolean)">
            <summary>Установка значения параметра функции двух переменных</summary>
            <param name="f">Исходная функция двух переменных</param>
            <param name="a">Устанавливаемое значение параметра</param>
            <param name="IsFirst">Параметром является первый аргумент функции? (по умолчанию - нет)</param>
            <returns>Функция одного переменного, полученная на основе исходной функции двух переменных установкой одного в значение указанного параметра</returns>
        </member>
        <member name="M:System.FuncExtensions.Subtract(System.Func{System.Double,System.Double},System.Func{System.Double,System.Double})">
            <summary>Вычитание одной функции из другой g(x) = f1(x) - f2(x)</summary>
            <param name="f1">Функция - уменьшаемое</param>
            <param name="f2">Функция - вычитаемое</param>
            <returns>Функция, значения которой численно равны разности значений двух исходных функций</returns>
        </member>
        <member name="M:System.FuncExtensions.Subtract(System.Func{System.Double,System.Double},System.Double)">
            <summary>Вычитание из функции числа g(x) = f(x) - a</summary>
            <param name="f">Исходная функция</param>
            <param name="a">вычитаемое из функции число</param>
            <returns>Функция, значения которой численно равны разности значений исходной функции и указанного числа</returns>
        </member>
        <member name="M:System.FuncExtensions.GetValuesParallel``2(System.Func{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>Вычислить значения функции параллельно</summary>
            <param name="f">Вычисляемая функция</param>
            <param name="Arguments">Область определения</param>
            <typeparam name="TArgument">Тип аргумента</typeparam>
            <typeparam name="TResult">Тип значения</typeparam>
            <returns>Массив значений функции</returns>
        </member>
        <member name="T:System.FuncExtensions.Integrator">
            <summary>Интегратор функции</summary>
        </member>
        <member name="F:System.FuncExtensions.Integrator._LockObject">
            <summary>Объект синхронизации потоков при доступе к параметрам интегратора</summary>
        </member>
        <member name="P:System.FuncExtensions.Integrator.C">
            <summary>Константа интегрирования</summary>
        </member>
        <member name="P:System.FuncExtensions.Integrator.x0">
            <summary>Начальное положение интегратора</summary>
        </member>
        <member name="P:System.FuncExtensions.Integrator.f">
            <summary>Интегрируемая функция</summary>
        </member>
        <member name="M:System.FuncExtensions.Integrator.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>Инициализация нового интегратора функции</summary>
            <param name="f">Интегрируемая функция</param>
            <param name="x0">Начальное положение интегратора</param>
            <param name="C">Константа интегрирования</param>
        </member>
        <member name="M:System.FuncExtensions.Integrator.GetValue(System.Double,System.Double)">
            <summary>Метод расчёта интеграла от предыдущего положения интегратора до указанного</summary>
            <param name="x">Требуемое значение конца интервала интегрирования</param>
            <param name="Eps">Точность процесса интегрирования</param>
            <returns>Значение численного интеграла на интервале от предыдущего положения интегратора до указанного</returns>
        </member>
        <member name="M:System.FuncExtensions.Integrator.GetIntegral(System.Double)">
            <summary>Получить функцию, равную интегралу от интегрируемой функции</summary>
            <param name="Eps">Точность интегрирования</param>
            <returns>Интеграл функции</returns>
        </member>
        <member name="T:System.FuncExtensions.VectorAddDelegate">
            <summary>Делегат функции сложения двух векторов</summary>
            <param name="C">Вектор результата сложения</param>
            <param name="B">Вектор первого слагаемого</param>
            <param name="A">Вектор второго слагаемого</param>
            <param name="length">Длина векторов</param>
        </member>
        <member name="M:System.FuncExtensions.CreateFastFloatSummator">
            <summary>Метод генерации быстрого сумматора двух векторов вещественных чисел</summary>
            <returns>Метод сложения двух векторов вещественных чисел</returns>
        </member>
        <member name="T:System.FuncExtensions.SamplingResult`1">
            <summary>Результат дискретизации функции</summary>
            <typeparam name="TValue">Тип значений функции</typeparam>
        </member>
        <member name="T:System.FuncExtensions.SamplingResult`1.Result">
            <summary>Отсчёт функции</summary>
        </member>
        <member name="F:System.FuncExtensions.SamplingResult`1.Result.Argument">
            <summary>Значение аргумента отсчёта</summary>
        </member>
        <member name="F:System.FuncExtensions.SamplingResult`1.Result.Value">
            <summary>Значение функции</summary>
        </member>
        <member name="M:System.FuncExtensions.SamplingResult`1.Result.#ctor(System.Double,`0)">
            <summary>Инициализация нового отсчёта функции</summary>
            <param name="Argument">Значение аргумента функции</param>
            <param name="Value">Значение функции</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingResult`1.Result.op_Implicit(System.FuncExtensions.SamplingResult{`0}.Result)~System.ValueTuple{System.Double,`0}">
            <summary>Оператор неявного приведения отсчёта функции к кортежу двух элементов - значение отсчёта функции - значение функции</summary>
            <param name="result">Отсчёт функции</param>
        </member>
        <member name="P:System.FuncExtensions.SamplingResult`1.Values">
            <summary>Перечисление отсчётов функции</summary>
        </member>
        <member name="P:System.FuncExtensions.SamplingResult`1.Accuracy">
            <summary>Оценка точности дискретизации</summary>
        </member>
        <member name="M:System.FuncExtensions.SamplingResult`1.#ctor(System.Collections.Generic.IEnumerable{System.FuncExtensions.SamplingResult{`0}.Result},System.Double)">
            <summary>Инициализация нового результата дискретизации функции</summary>
            <param name="Values">Перечисление отсчётов функции</param>
            <param name="Accuracy">Оценка точности дискретизации</param>
        </member>
        <member name="T:System.FuncExtensions.SimpleSamplingResult">
            <summary>Результат дискретизации вещественной функции</summary>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.Sampling(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
            <returns>Кортеж, содержащий связанный список дискретов функции и оценку точности дискретизации</returns>
        </member>
        <member name="F:System.FuncExtensions.SimpleSamplingResult._F">
            <summary>Дискретизируемая функция</summary>
        </member>
        <member name="F:System.FuncExtensions.SimpleSamplingResult._List">
            <summary>Связанный список отсчётов функции</summary>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.#ctor(System.ValueTuple{System.Collections.Generic.LinkedList{System.FuncExtensions.SamplingResult{System.Double}.Result},System.Double})">
            <summary>Инициализация нового результата дискретизации по кортежу дискретов функции и оценки точности дискретизации</summary>
            <param name="SamplingResult">Кортеж дискретов функции и оценки точности дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового результата дискретизации</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="dx">Шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.ClarifySampling(System.Double)">
            <summary>Уточнение результата дискретизации</summary>
            <param name="accuracy">Требуемая точность</param>
            <returns>Истина, если требуемая точность достигнута</returns>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.GetValues">
            <summary>Метод получения отсчётов функции</summary>
            <returns>Массив отсчётов функции</returns>
        </member>
        <member name="M:System.FuncExtensions.SimpleSamplingResult.op_Implicit(System.FuncExtensions.SimpleSamplingResult)~System.FuncExtensions.SamplingResult{System.Double}.Result[]">
            <summary>Оператор неявного приведения типа результата дискретизации к типу массива отсчётов функции</summary>
            <param name="result">Результат дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Адаптивный метод дискретизации вещественной функции</summary>
            <param name="f">Дискретизируемая вещественная функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="Eps">Точность дискретизации</param>
            <returns>Результат дискретизации вещественной функции</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Адаптивный метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Конвертер преобразования значения функции в вещественное число для оценки точности дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Окончание интервала дискретизации</param>
            <param name="Eps">Точность дискретизации</param>
            <returns>Результат дискретизации функции</returns>
        </member>
        <member name="T:System.FuncExtensions.AdaptiveSamplingResult`1">
            <summary>Результат адаптивной дискретизации</summary>
            <typeparam name="T">Тип значения дискретизируемой функции</typeparam>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.Sampling(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественное число для оценки точности дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <returns>Кортеж со списком значений функции и вещественным число, оценивающим точность дискретизации</returns>
        </member>
        <member name="F:System.FuncExtensions.AdaptiveSamplingResult`1._List">
            <summary>Связанный список с дискретами функции</summary>
        </member>
        <member name="F:System.FuncExtensions.AdaptiveSamplingResult`1._F">
            <summary>Дискретизируемая функция</summary>
        </member>
        <member name="F:System.FuncExtensions.AdaptiveSamplingResult`1._Converter">
            <summary>Метод преобразования значений функции в вещественное число для оценки качества дискретизации</summary>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.#ctor(System.ValueTuple{System.Collections.Generic.LinkedList{System.FuncExtensions.SamplingResult{`0}.Result},System.Double})">
            <summary>Инициализация нового адаптивного дискретизатора</summary>
            <param name="SamplingResult">Список отсчётов дискретизации функции и оценка точности дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.#ctor(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового адаптивного дискретизатора</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественное число для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.ClarifySampling(System.Double)">
            <summary>Точная дискретизации</summary>
            <param name="accuracy">Требуемая точность</param>
            <returns>Полученная точность дискретизации</returns>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.GetValues">
            <summary>Получить отсчёты функции в виде массива значений</summary>
            <returns>Массив значений функции</returns>
        </member>
        <member name="M:System.FuncExtensions.AdaptiveSamplingResult`1.op_Implicit(System.FuncExtensions.AdaptiveSamplingResult{`0})~System.FuncExtensions.SamplingResult{`0}.Result[]">
            <summary>Оператор неявного преобразования результатов адаптивной дискретизации функции в массив её значений</summary>
            <param name="result">Результаты адаптивной дискретизации функции</param>
        </member>
        <member name="T:System.FuncExtensions.SamplingResultOneWay">
            <summary>Результаты дискретизации функции адаптивным однопроходным методом</summary>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultOneWay.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Инициализация нового результата адаптивной дискретизации однопроходным методом</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_OneWay(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Однопроходный адаптивный метод дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <returns>Результат дискретизации</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_OneWay(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double,System.Action{System.Double})">
            <summary>Метод однопроходной адаптивной дискретизации функции</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <param name="UpdateAccuracy">Метод обновления значения точности дискретизации в процесс самой дискретизации</param>
            <returns>Перечисление результатов дискретизации</returns>
        </member>
        <member name="T:System.FuncExtensions.SamplingResultOneWayT`1">
            <summary>Результаты адаптивной однопроходной дискретизации функции значений указанного типа</summary>
            <typeparam name="T">Тип значений функции</typeparam>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_OneWay``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>Адаптивная дискретизация функции в один проход</summary>
            <typeparam name="T">Тип значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="Converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность дискретизации</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <returns>Результат дискретизации функции</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_OneWayT``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double,System.Double,System.Action{System.Double})">
            <summary>Метод последовательной дискретизации функции с адаптивным шагом</summary>
            <typeparam name="T">Тип значений функции</typeparam>
            <param name="f">Дискретизируемая функция</param>
            <param name="Converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <param name="dx">Начальный шаг дискретизации</param>
            <param name="UpdateAccuracy">Метод обновления значения текущего уровня точности дискретизации</param>
            <returns>Перечисление отсчётов функции</returns>
        </member>
        <member name="T:System.FuncExtensions.SamplingResultHalfDivision">
            <summary>Результат дискретизации методом половинного деления</summary>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultHalfDivision.#ctor(System.ValueTuple{System.FuncExtensions.SamplingResult{System.Double}.Result[],System.Double})">
            <summary>Инициализация нового экземпляра результата дискретизации методом половинного деления</summary>
            <param name="Data">Результаты дискретизации, содержащие массив отсчётов функции и значение точности</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultHalfDivision.#ctor(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра результата дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_HalfDivision(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Дискретизация функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Результат дискретизации функции методом половинного деления</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_HalfDivision_(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Результаты дискретизации</returns>
        </member>
        <member name="T:System.FuncExtensions.SamplingResultHalfDivisionT`1">
            <summary>Результат дискретизации методом половинного деления</summary>
            <typeparam name="T">Тип значений функции</typeparam>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultHalfDivisionT`1.#ctor(System.ValueTuple{System.FuncExtensions.SamplingResult{`0}.Result[],System.Double})">
            <summary>Инициализация нового экземпляра результата дискретизации методом половинного деления</summary>
            <param name="Data">Результаты дискретизации, содержащие массив отсчётов функции и значение точности</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingResultHalfDivisionT`1.#ctor(System.Func{System.Double,`0},System.Func{`0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Инициализация нового экземпляра результата дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_HalfDivision``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Дискретизациия функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Результат дискретизации функции методом половинного деления</returns>
        </member>
        <member name="M:System.FuncExtensions.SamplingAdaptive_HalfDivision_``1(System.Func{System.Double,``0},System.Func{``0,System.Double},System.Double,System.Double,System.Double)">
            <summary>Метод дискретизации функции методом половинного деления</summary>
            <param name="f">Дискретизируемая функция</param>
            <param name="converter">Метод преобразования значений функции в вещественные числа для оценки качества дискретизации</param>
            <param name="x1">Начало интервала дискретизации</param>
            <param name="x2">Конец интервала дискретизации</param>
            <param name="Eps">Требуемая точность</param>
            <returns>Результаты дискретизации</returns>
        </member>
        <member name="T:System.EnumExtensions">
            <summary>Класс методов-расширений для перечислений <see cref="T:System.Enum"/></summary>
        </member>
        <member name="M:System.EnumExtensions.GetValueAttribute``1(System.Enum)">
            <summary>Получить описание поля - значение атрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
            <exception cref="T:System.TypeLoadException">Если невозможно загрузить атрибуты типа</exception>
            <exception cref="T:System.InvalidOperationException">
            Если этот член принадлежит типу, который загружается в контекст только для отражения.
            Смотрите раздел Как загрузить сборки в контекст только для отражения.
            </exception>
        </member>
        <member name="M:System.EnumExtensions.GetDescription(System.Enum)">
            <summary>Получить описание поля - значение атрибута <see cref="T:System.ComponentModel.DescriptionAttribute"/></summary>
            <exception cref="T:System.TypeLoadException">Если невозможно загрузить атрибуты типа</exception>
        </member>
        <member name="M:System.EnumExtensions.GetDisplayName(System.Enum)">
            <summary>Получить описание поля - значение атрибута <see cref="T:System.ComponentModel.DisplayNameAttribute"/></summary>
            <exception cref="T:System.TypeLoadException">Если невозможно загрузить атрибуты типа</exception>
        </member>
        <member name="M:System.EnumExtensions.GetDisplayNames(System.Enum)">
            <summary>Получить описание поля - значение атрибута <see cref="T:System.ComponentModel.DisplayNameAttribute"/></summary>
            <exception cref="T:System.TypeLoadException">Если невозможно загрузить атрибуты типа</exception>
        </member>
        <member name="T:System.EventHandlerExtension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerExtension.InvokeAsync(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Асинхронный запуск обработчика события с созданием новой задачи</summary>
            <param name="handler">Запускаемый обработчик события</param>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <returns>Задача асинхронного выполнения обработчика события</returns>
        </member>
        <member name="M:System.EventHandlerExtension.InvokeAsync``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Асинхронный запуск обработчика события с созданием новой задачи</summary>
            <param name="handler">Запускаемый обработчик события</param>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
            <returns>Задача асинхронного выполнения обработчика события</returns>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.Collections.Specialized.NotifyCollectionChangedEventHandler,System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.String)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.String[])">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="PropertyName">Имена изменившихся свойств</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.ComponentModel.PropertyChangedEventHandler,System.Object,System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerExtension.StartAsync(System.EventHandler,System.Object,System.EventArgs,System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart(System.EventHandler,System.Object)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart(System.EventHandler,System.Object,System.EventArgs)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.FastStart``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start``1(System.EventHandler{``0},System.Object,``0)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:System.EventHandlerExtension.StartAsync``1(System.EventHandler{``0},System.Object,``0,System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <param name="e">Аргументы события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerExtension.Start``3(System.EventHandler{``0,``1,``2},``1,``2)">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <typeparam name="TArgs">Тип аргумента события</typeparam>
            <param name="Args">Аргументы события</param>
            <typeparam name="TResult">Тип результата обработки события</typeparam>
            <typeparam name="TSender">Тип источника события</typeparam>
            <returns>Массив результатов обработки события</returns>
        </member>
        <member name="T:System.EventHandlerReturn`2">
            <summary>Тип обработчика события, подразумевающий возможность возврата значения</summary>
            <param name="Sender">Объект-источник события</param>
            <param name="args">Аргумент события</param>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
            <typeparam name="TReturn">Тип возвращаемого значения</typeparam>
        </member>
        <member name="T:System.EventHandlerTyped1Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.Start``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.StartAsync``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.FastStart``2(System.EventHandler{``0,``1},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped1Extension.FastStart``2(System.EventHandler{``0,``1},``0,System.EventArgs{``1})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.EventHandlerTyped2Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.Start``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.StartAsync``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.FastStart``3(System.EventHandler{``0,``1,``2},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped2Extension.FastStart``3(System.EventHandler{``0,``1,``2},``0,System.EventArgs{``1,``2})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.EventHandlerTyped3Extension">
            <summary>Класс методов расширений для обработчиков событий</summary>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.Start``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3})">
            <summary>Потоко-безопасная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.StartAsync``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3},System.AsyncCallback,System.Object)">
            <summary>Потоко-безопасная асинхронная генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргумент события</param>
            <param name="CallBack">Метод завершения генерации события</param>
            <param name="State">Объект-состояние, передаваемый в метод завершения генерации события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.FastStart``4(System.EventHandler{``0,``1,``2,``3},``0)">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
        </member>
        <member name="M:System.EventHandlerTyped3Extension.FastStart``4(System.EventHandler{``0,``1,``2,``3},``0,System.EventArgs{``1,``2,``3})">
            <summary>Быстрая генерация события</summary>
            <param name="Handler">Обработчик события</param>
            <param name="Sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:System.IComparableExtensions">
            <summary>Класс методов-расширений для объектов, поддерживающий интерфейс <see cref="T:System.IComparable`1"/></summary>
        </member>
        <member name="M:System.IComparableExtensions.SearchBinary``1(System.Collections.Generic.IReadOnlyList{``0},System.Int32,System.Int32,``0)">
            <summary>Метод поиска элемента в списке половинным делением</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="list">Список, упорядоченный по возрастанию</param>
            <param name="From">Начальный индекс поиска</param>
            <param name="To">Конечный индекс поиска</param>
            <param name="Item">Искомый элемент</param>
            <returns>Индекс элемента в списке, либо <see langword="null"/>, если элемент не был найден</returns>
        </member>
        <member name="M:System.IComparableExtensions.Max``1(``0,``0)">
            <summary>Возвращает максимальный элемент из текущего и, элемента, переданного в качестве параметра</summary>
            <typeparam name="T">Тип сравниваемых элементов</typeparam>
            <param name="x">Текущий элемент в процессе сравнения</param>
            <param name="y">Сравниваемый элемент в процессе сравнения</param>
            <returns>Максимальный из элементов</returns>
        </member>
        <member name="M:System.IComparableExtensions.Min``1(``0,``0)">
            <summary>Возвращает минимальный элемент из текущего и, элемента, переданного в качестве параметра</summary>
            <typeparam name="T">Тип сравниваемых элементов</typeparam>
            <param name="x">Текущий элемент в процессе сравнения</param>
            <param name="y">Сравниваемый элемент в процессе сравнения</param>
            <returns>Минимальный из элементов</returns>
        </member>
        <member name="M:System.IComparableExtensions.IsGreater``1(``0,``0)">
            <summary>Является ли текущий элемент элементом больше, чем элемент, переданный в параметре</summary>
            <typeparam name="T">Тип сравниваемых элементов</typeparam>
            <param name="a">Текущий элемент в процессе сравнения</param>
            <param name="b">Сравниваемый элемент в процессе сравнения</param>
            <returns>Истина, если текущий элемент больше, чем элемент, с которым производится сравнение</returns>
        </member>
        <member name="M:System.IComparableExtensions.IsLess``1(``0,``0)">
            <summary>Является ли текущий элемент элементом меньше, чем элемент, переданный в параметре</summary>
            <typeparam name="T">Тип сравниваемых элементов</typeparam>
            <param name="a">Текущий элемент в процессе сравнения</param>
            <param name="b">Сравниваемый элемент в процессе сравнения</param>
            <returns>Истина, если текущий элемент меньше, чем элемент, с которым производится сравнение</returns>
        </member>
        <member name="M:System.IComparableExtensions.IsGreaterEqual``1(``0,``0)">
            <summary>Является ли текущий элемент элементом больше, либо равен элементу, переданному в параметре</summary>
            <typeparam name="T">Тип сравниваемых элементов</typeparam>
            <param name="a">Текущий элемент в процессе сравнения</param>
            <param name="b">Сравниваемый элемент в процессе сравнения</param>
            <returns>Истина, если текущий элемент больше, либо равен элементу, переданному в параметре</returns>
        </member>
        <member name="M:System.IComparableExtensions.IsLessEqual``1(``0,``0)">
            <summary>Является ли текущий элемент элементом меньше, либо равен элементу, переданному в параметре</summary>
            <typeparam name="T">Тип сравниваемых элементов</typeparam>
            <param name="a">Текущий элемент в процессе сравнения</param>
            <param name="b">Сравниваемый элемент в процессе сравнения</param>
            <returns>Истина, если текущий элемент меньше, либо равен элементу, переданному в параметре</returns>
        </member>
        <member name="M:System.IComparableExtensions.Between``1(``0,``0,``0)">
            <summary>
            Возвращает значение <paramref name="x"/>, если оно находится в интервале между <paramref name="min"/> и
            <paramref name="max"/>, либо соответствующую границу интервала
            </summary>
            <typeparam name="T">Тип значения</typeparam>
            <param name="x">Проверяемое значение</param>
            <param name="min">Нижняя граница интервала</param>
            <param name="max">Верхняя граница интервала</param>
            <returns>Значение из интервала</returns>
        </member>
        <member name="T:System.Data.IDataReaderExtensions">
            <summary>Класс методов-расширений для <see cref="T:System.Data.IDataReader"/></summary>
        </member>
        <member name="M:System.Data.IDataReaderExtensions.ReadToEnd``1(System.Data.IDataReader,System.Func{System.Data.IDataRecord,``0})">
            <summary>Прочитать источник данных до конца</summary>
            <typeparam name="T">Тип читаемых данных</typeparam>
            <param name="Reader">Объект чтения данных</param>
            <param name="Read">Метод преобразования читаемых данных из <see cref="T:System.Data.IDataRecord"/> в <typeparamref name="T"/></param>
            <returns>Список прочитанных данных</returns>
        </member>
        <member name="M:System.Data.IDataReaderExtensions.AsEnumerable``1(System.Data.IDataReader,System.Func{System.Data.IDataRecord,``0})">
            <summary>Представление <see cref="T:System.Data.IDataReader"/> в виде перечисление значений</summary>
            <param name="Reader">Объект чтения данных</param>
            <param name="Read">Метод преобразования читаемых данных из <see cref="T:System.Data.IDataRecord"/> в <typeparamref name="T"/></param>
            <typeparam name="T">Тип результата (элементы данных)</typeparam>
            <returns>Перечисление читаемых данных</returns>
        </member>
        <member name="T:System.Data.IDataRecordExtensions">
            <summary>Класс методов-расширений для <see cref="T:System.Data.IDataRecord"/></summary>
        </member>
        <member name="M:System.Data.IDataRecordExtensions.Field``1(System.Data.IDataRecord,System.Int32)">
            <summary>Извлечение поля данных из записи по индексу поля</summary>
            <typeparam name="T">Тип значения</typeparam>
            <param name="record">Запись с данными</param>
            <param name="index">Индекс поля с данными в записи</param>
            <exception cref="T:System.NullReferenceException">Если запись с указанным индексом отсутствует, а тип данных не является ссылочным</exception>
            <returns>Значение поля, если в записи с указанным индексом оно есть, либо значение по умолчанию</returns>
        </member>
        <member name="M:System.Data.IDataRecordExtensions.Field``1(System.Data.IDataRecord,System.String)">
            <summary>Извлечение поля данных из записи по имени поля</summary>
            <typeparam name="T">Тип значения</typeparam>
            <param name="record">Запись с данными</param>
            <param name="ColumnName">Имя колонки</param>
            <exception cref="T:System.NullReferenceException">Если запись с указанным именем отсутствует, а тип данных не является ссылочным</exception>
            <returns>Значение поля, если в записи с указанным индексом оно есть, либо значение по умолчанию</returns>
        </member>
        <member name="T:System.IDisposableExtensions">
            <summary>Методы-расширения для интерфейса <see cref="T:System.IDisposable"/></summary>
        </member>
        <member name="M:System.IDisposableExtensions.AsDisposableGroup``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Представить в виде группы элементов, поддерживающих освобождение ресурсов</summary>
            <typeparam name="T">Тип элемента, поддерживающий <see cref="T:System.IDisposable"/></typeparam>
            <param name="items">Элементы, поддерживающие <see cref="T:System.IDisposable"/></param>
            <returns><see cref="T:MathCore.DisposableGroup`1"/></returns>
        </member>
        <member name="M:System.IDisposableExtensions.DisposeAfter``1(``0,System.Action{``0})">
            <summary>Выполнить действие, после чего освободить ресурсы</summary>
            <typeparam name="T">Тип объекта, над которым требуется выполнить действие</typeparam>
            <param name="obj">Объект, действие над которым требуется выполнить</param>
            <param name="action">Выполняемое над объектом действие</param>
        </member>
        <member name="M:System.IDisposableExtensions.DisposeAfter``2(``0,``1@,System.Action{``0,``1})">
            <summary>Выполнить действие, после чего освободить ресурсы</summary>
            <typeparam name="T">Тип объекта, над которым требуется выполнить действие</typeparam>
            <typeparam name="TP">Тип параметра действия</typeparam>
            <param name="obj">Объект, действие над которым требуется выполнить</param>
            <param name="p">Параметр, передаваемый в действие, чтобы избежать замыкания</param>
            <param name="action">Выполняемое над объектом действие</param>
        </member>
        <member name="M:System.IDisposableExtensions.DisposeAfter``3(``0,``1@,``2@,System.Action{``0,``1,``2})">
            <summary>Выполнить действие, после чего освободить ресурсы</summary>
            <typeparam name="T">Тип объекта, над которым требуется выполнить действие</typeparam>
            <typeparam name="TP1">Тип параметра 1 действия</typeparam>
            <typeparam name="TP2">Тип параметра 2 действия</typeparam>
            <param name="obj">Объект, действие над которым требуется выполнить</param>
            <param name="p1">Параметр 1, передаваемый в действие, чтобы избежать замыкания</param>
            <param name="p2">Параметр 2, передаваемый в действие, чтобы избежать замыкания</param>
            <param name="action">Выполняемое над объектом действие</param>
        </member>
        <member name="M:System.IDisposableExtensions.DisposeAfter``4(``0,``1@,``2@,``3@,System.Action{``0,``1,``2,``3})">
            <summary>Выполнить действие, после чего освободить ресурсы</summary>
            <typeparam name="T">Тип объекта, над которым требуется выполнить действие</typeparam>
            <typeparam name="TP1">Тип параметра 1 действия</typeparam>
            <typeparam name="TP2">Тип параметра 2 действия</typeparam>
            <typeparam name="TP3">Тип параметра 3 действия</typeparam>
            <param name="obj">Объект, действие над которым требуется выполнить</param>
            <param name="p1">Параметр 1, передаваемый в действие, чтобы избежать замыкания</param>
            <param name="p2">Параметр 2, передаваемый в действие, чтобы избежать замыкания</param>
            <param name="p3">Параметр 3, передаваемый в действие, чтобы избежать замыкания</param>
            <param name="action">Выполняемое над объектом действие</param>
        </member>
        <member name="M:System.IDisposableExtensions.DisposeAfter``2(``0,System.Func{``0,``1})">
            <summary>Выполнить действие и получить результат, после чего освободить ресурсы</summary>
            <typeparam name="T">Тип объекта, над которым требуется выполнить действие</typeparam>
            <typeparam name="TResult">Тип вычисляемого результата</typeparam>
            <param name="obj">Объект, действие над которым требуется выполнить</param>
            <param name="func">Функция, вычисляющая результат на основе переданного ей значения</param>
        </member>
        <member name="M:System.IDisposableExtensions.DisposeAfter``3(``0,``1@,System.Func{``0,``1,``2})">
            <summary>Выполнить действие и получить результат, после чего освободить ресурсы</summary>
            <typeparam name="T">Тип объекта, над которым требуется выполнить действие</typeparam>
            <typeparam name="TP">Тип параметра действия</typeparam>
            <typeparam name="TResult">Тип вычисляемого результата</typeparam>
            <param name="obj">Объект, действие над которым требуется выполнить</param>
            <param name="p">Параметр, передаваемый в функцию, чтобы избежать замыкания</param>
            <param name="func">Функция, вычисляющая результат на основе переданного ей значения</param>
        </member>
        <member name="M:System.IDisposableExtensions.DisposeAfter``4(``0,``1@,``2@,System.Func{``0,``1,``2,``3})">
            <summary>Выполнить действие и получить результат, после чего освободить ресурсы</summary>
            <typeparam name="T">Тип объекта, над которым требуется выполнить действие</typeparam>
            <typeparam name="TP1">Тип параметра 1 действия</typeparam>
            <typeparam name="TP2">Тип параметра 2 действия</typeparam>
            <typeparam name="TResult">Тип вычисляемого результата</typeparam>
            <param name="obj">Объект, действие над которым требуется выполнить</param>
            <param name="p1">Параметр 1, передаваемый в функцию, чтобы избежать замыкания</param>
            <param name="p2">Параметр 2, передаваемый в функцию, чтобы избежать замыкания</param>
            <param name="func">Функция, вычисляющая результат на основе переданного ей значения</param>
        </member>
        <member name="M:System.IDisposableExtensions.DisposeAfter``5(``0,``1@,``2@,``3@,System.Func{``0,``1,``2,``3,``4})">
            <summary>Выполнить действие и получить результат, после чего освободить ресурсы</summary>
            <typeparam name="T">Тип объекта, над которым требуется выполнить действие</typeparam>
            <typeparam name="TP1">Тип параметра 1 действия</typeparam>
            <typeparam name="TP2">Тип параметра 2 действия</typeparam>
            <typeparam name="TP3">Тип параметра 3 действия</typeparam>
            <typeparam name="TResult">Тип вычисляемого результата</typeparam>
            <param name="obj">Объект, действие над которым требуется выполнить</param>
            <param name="p1">Параметр 1, передаваемый в функцию, чтобы избежать замыкания</param>
            <param name="p2">Параметр 2, передаваемый в функцию, чтобы избежать замыкания</param>
            <param name="p3">Параметр 3, передаваемый в функцию, чтобы избежать замыкания</param>
            <param name="func">Функция, вычисляющая результат на основе переданного ей значения</param>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.IsEOF(System.IO.BinaryReader)">
            <summary>Признак конца потока</summary>
            <param name="reader">Объект чтения потока</param>
            <returns>Истина, если поток закончен</returns>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.GetByteBuffer(System.IO.BinaryReader,System.Int32)">
            <summary>Получить перечисление, содержащее массивы байт заданной длины из потока</summary>
            <param name="reader">Объект чтения потока данных</param>
            <param name="BufferSize">Размер буфера</param>
            <returns>Последовательность массивов байт указанной длины (последний массив будет меньше)</returns>
        </member>
        <member name="M:System.IO.BinaryReaderExtensions.GetByteBuffer(System.IO.BinaryReader,System.Byte[])">
            <summary>Получить перечисление, содержащее массивы байт заданной длины из потока</summary>
            <param name="reader">Объект чтения потока данных</param>
            <param name="Buffer">Буфер чтения</param>
            <returns>Перечислитель</returns>
        </member>
        <member name="T:System.IO.DirectoryInfoExtensions">
            <summary>Класс методов-расширений для объектов класса System.IO.DirectoryInfo</summary>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.ThrowIfNotFound(System.IO.DirectoryInfo,System.String)">
            <summary>Проверка, что директория существует</summary>
            <param name="Dir">Проверяемая директория</param>
            <param name="Message">Сообщение, добавляемое в исключение, если директория не найдена</param>
            <returns>Директория, гарантированно существующая</returns>
            <exception cref="T:System.IO.DirectoryNotFoundException">В случае если <paramref name="Dir"/> не существует.</exception>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.AsTreeNode(System.IO.DirectoryInfo)">
            <summary>Представить директорию в виде узла дерева</summary>
            <param name="dir">Преобразуемая директория</param>
            <returns>Узел дерева каталогов</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.AsTreeNode(System.IO.DirectoryInfo,System.Action{System.IO.DirectoryInfo,System.Exception})">
            <summary>Представить директорию в виде узла дерева</summary>
            <param name="dir">Преобразуемая директория</param>
            <param name="OnError">Метод обработки ошибок доступа</param>
            <returns>Узел дерева каталогов</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.IsSubDirectoryOf(System.IO.DirectoryInfo,System.IO.DirectoryInfo)">
            <summary>Является ли одна директория поддиректорией другой?</summary>
            <param name="target">Дочерняя директория</param>
            <param name="parent">Родительская директория</param>
            <returns>Истина, если путь к директории, заявленной как дочерняя является вложенным в путь к директории, заявленной как родительская</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.CreateFileInfo(System.IO.DirectoryInfo,System.String)">
            <summary>Создать объект с информацией о вложенном файле</summary>
            <param name="directory">Родительская директория</param>
            <param name="FileRelativePath">Относительный путь к файлу внутри директории</param>
            <returns>Фал по указанному пути внутри директории</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.CreateDirectoryInfo(System.IO.DirectoryInfo,System.String)">
            <summary>Создать объект с информацией о поддиректории</summary>
            <param name="directory">Родительская директория</param>
            <param name="DirectoryRelativePath">Относительный путь к дочерней директории</param>
            <returns>Дочерняя директория</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetFilesCount(System.IO.DirectoryInfo)">
            <summary>Определить число всех вложенных файлов</summary>
            <param name="Directory">Исследуемая директория</param>
            <returns>Число файлов во всех вложенных поддиректориях</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetFilesCount(System.IO.DirectoryInfo,System.String)">
            <summary>Определить число всех вложенных файлов</summary>
            <param name="Directory">Исследуемая директория</param>
            <param name="Pattern">Маска файлов</param>
            <returns>Число файлов во всех вложенных поддиректориях</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetSize(System.IO.DirectoryInfo)">
            <summary>Определить объём всех вложенных файлов включая поддиректории</summary>
            <param name="Directory">Исследуемая директория</param>
            <returns>Число байт всех вложенных файлов</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetSubdirectoriesCount(System.IO.DirectoryInfo)">
            <summary>Определить число поддиректорий</summary>
            <param name="Directory">Исследуемая директория</param>
            <returns>Число элементов в дереве поддиректорий</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.IsEmpty(System.IO.DirectoryInfo)">
            <summary>Проверить - является ли директория пустой</summary>
            <param name="Directory">Проверяемая директория</param>
            <returns>Истина, если директория пуста</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetWatcher(System.IO.DirectoryInfo,System.String)">
            <summary>Получить объект наблюдения за директорией</summary>
            <param name="directory">Наблюдаемая директория</param>
            <param name="filter">Фильтр файлов</param>
            <returns>Объект наблюдатель</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.SubDirectoryOrCreate(System.IO.DirectoryInfo,System.String)">
            <summary>Получение поддиректории по заданному пути. Если поддиректория отсутствует, то создать новую</summary>
            <param name="ParentDirectory">Родительская директория</param>
            <param name="SubDirectoryPath">Относительный путь к поддиректории</param>
            <returns>Поддиректория</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.SubDirectory(System.IO.DirectoryInfo,System.String)">
            <summary>Формирование информации о поддиректории, заданной своим именем, либо относительным путём</summary>
            <param name="Directory">Корневая директория</param><param name="SubDirectoryPath">Путь к поддиректории</param>
            <exception cref="T:System.ArgumentNullException">Если указана пустая ссылка на <paramref name="Directory"/></exception>
            <exception cref="T:System.ArgumentNullException">Если указана пустая ссылка на <paramref name="SubDirectoryPath"/></exception>
            <returns>Информация о поддиректории</returns>
        </member>
        <member name="M:System.IO.DirectoryInfoExtensions.GetFile(System.IO.DirectoryInfo,System.String)">
            <summary>Получить файл по указанному пути внутри директории</summary>
            <param name="dir">Исходная директория</param>
            <param name="RelativeFilePath">Путь к файлу относительно директории. Если указан абсолютный путь, то будет использован он.</param>
        </member>
        <member name="T:System.IO.FileInfoExtensions">
            <summary>Класс методов расширений для объектов класса System.IO.FileInfo</summary>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CreateBinary(System.IO.FileInfo)">
            <summary>Создать двоичный файл</summary>
            <param name="File">Информация о создаваемом файле</param>
            <returns>Объект для записи данных в двоичный файл</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CreateBinary(System.IO.FileInfo,System.Int32)">
            <summary>Создать двоичный файл</summary>
            <param name="File">Информация о создаваемом файле</param>
            <param name="BufferLength">Размер буфера записи</param>
            <returns>Объект для записи данных в двоичный файл</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CreateBinary(System.IO.FileInfo,System.Text.Encoding)">
            <summary>Создать двоичный файл</summary>
            <param name="File">Информация о создаваемом файле</param>
            <param name="Encoding">Кодировка</param>
            <returns>Объект для записи данных в двоичный файл</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CreateBinary(System.IO.FileInfo,System.Int32,System.Text.Encoding)">
            <summary>Создать двоичный файл</summary>
            <param name="File">Информация о создаваемом файле</param>
            <param name="BufferLength">Размер буфера записи</param>
            <param name="Encoding">Кодировка</param>
            <returns>Объект для записи данных в двоичный файл</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.OpenBinary(System.IO.FileInfo)">
            <summary>Открыть двоичный файл для чтения</summary>
            <param name="File">Информация о создаваемом файле</param>
            <returns>Объект для чтения данных из двоичного файла</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.OpenBinary(System.IO.FileInfo,System.Int32)">
            <summary>Открыть двоичный файл для чтения</summary>
            <param name="File">Информация о создаваемом файле</param>
            <param name="BufferLength">Размер буфера чтения</param>
            <returns>Объект для чтения данных из двоичного файла</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.OpenBinary(System.IO.FileInfo,System.Text.Encoding)">
            <summary>Открыть двоичный файл для чтения</summary>
            <param name="File">Информация о создаваемом файле</param>
            <param name="Encoding">Кодировка</param>
            <returns>Объект для чтения данных из двоичного файла</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.OpenBinary(System.IO.FileInfo,System.Int32,System.Text.Encoding)">
            <summary>Открыть двоичный файл для чтения</summary>
            <param name="File">Информация о создаваемом файле</param>
            <param name="BufferLength">Размер буфера чтения</param>
            <param name="Encoding">Кодировка</param>
            <returns>Объект для чтения данных из двоичного файла</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.ExecuteAsAdmin(System.IO.FileInfo,System.String,System.Boolean)">
            <summary>Выполнить файл с правами администратора</summary>
            <param name="File">Исполняемый файл</param>
            <param name="Args">Аргументы командной строки</param>
            <param name="UseShellExecute">Использовать интерпретацию файла операционной системой</param>
            <returns>Созданный процесс</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Execute(System.IO.FileInfo,System.String,System.Boolean,System.String)">
            <summary>Выполнить файл</summary>
            <param name="File">Исполняемый файл</param>
            <param name="Args">Аргументы командной строки</param>
            <param name="UseShellExecute">Использовать интерпретацию файла операционной системой</param>
            <returns>Созданный процесс</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.ThrowIfNotFound(System.IO.FileInfo,System.String)">
            <summary>Проверка на существование файла. Если файл не существует, то генерируется исключение</summary>
            <param name="file">Проверяемый файл</param>
            <param name="Message">Сообщение, добавляемое в исключение</param>
            <returns>Информация о файле</returns>
            <exception cref="T:System.IO.FileNotFoundException">если файл не существует</exception>
        </member>
        <member name="M:System.IO.FileInfoExtensions.ComputeSHA256(System.IO.FileInfo)">
            <summary>Вычислить хеш-сумму SHA256</summary>
            <param name="file">Файл, контрольную сумму которого надо вычислить</param>
            <returns>Массив байт контрольной суммы</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.ComputeSHA256Async(System.IO.FileInfo,System.Threading.CancellationToken)">
            <summary>Вычислить хеш-сумму SHA256</summary>
            <param name="file">Файл, контрольную сумму которого надо вычислить</param>
            <returns>Массив байт контрольной суммы</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.ComputeMD5(System.IO.FileInfo)">
            <summary>Вычислить хеш-сумму MD5</summary>
            <param name="file">Файл, контрольную сумму которого надо вычислить</param>
            <returns>Массив байт контрольной суммы</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo)">
            <summary>Скопировать файл в директорию</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationDirectory">Директория назначения</param>
            <returns>Файл копия</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.DirectoryInfo,System.Boolean)">
            <summary>Скопировать файл в директорию</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationDirectory">Директория назначения</param>
            <param name="Overwrite">Перезаписать в случае наличия файла</param>
            <returns>Файл копия</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>Скопировать файл</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationFile">Файл копия</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.CopyTo(System.IO.FileInfo,System.IO.FileInfo,System.Boolean)">
            <summary>Скопировать файл</summary>
            <param name="SourceFile">Файл источник</param>
            <param name="DestinationFile">Файл копия</param>
            <param name="Overwrite">Перезаписать в случае наличия файла</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFileNameWithoutExtension(System.IO.FileInfo)">
            <summary>Получить имя файла без расширения</summary>
            <param name="file">Файл</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFullFileNameWithoutExtension(System.IO.FileInfo)">
            <summary>Получить имя файла без расширения</summary>
            <param name="file">Файл</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetFullFileNameWithNewExtension(System.IO.FileInfo,System.String)">
            <summary>Получить имя файла c новым расширением</summary>
            <param name="file">Файл</param>
            <param name="NewExt">Новое расширение файла в формате ".exe"</param>
            <returns>Имя файла без расширения</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.WriteAllBytes(System.IO.FileInfo,System.Byte[],System.Boolean)">
            <summary>Записать массив байт в файл</summary>
            <param name="file">Файл данных</param>
            <param name="Data">Данные</param>
            <param name="Append">Если истина, то данные будут добавлены в конец файла</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.WriteAllBytes(System.IO.FileInfo,System.IO.Stream,System.Int32,System.Boolean,System.Func{System.Int64,System.Byte[],System.Boolean},System.EventHandler{System.EventArgs{System.IO.FileInfo,System.IO.Stream}})">
            <summary>Записать все данные из потока в файл</summary>
            <param name="file">Файл данных</param>
            <param name="DataStream">Поток - источник данных</param>
            <param name="BufferSize">Размер буфера чтения по умолчанию 1024 байта</param>
            <param name="Append">Флаг добавления данных в конец файла</param>
            <param name="CompleteHandler">
            Обработчик текущего положения каретки чтения данных из потока. 
            Вызывается после чтения данных в буфер и до помещения их в файл.
            Должен вернуть истину, что бы данные были переданы в файл и процесс был продолжен.
            </param>
            <param name="OnComplete">Обработчик события завершения процесса записи данных</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetWatcher(System.IO.FileInfo)">
            <summary>Получить объект наблюдения за файлом</summary>
            <param name="file">Наблюдаемый файл</param>
            <returns>Объект наблюдатель</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Execute(System.String,System.String,System.Boolean)">
            <summary>Запустить процесс в ОС на основе указанного файла</summary>
            <param name="File">Путь к запускаемому файлу</param>
            <param name="Args">Аргументы командной строки</param>
            <param name="UseShellExecute">Заставить ОС определить требуемый способ запуска</param>
            <returns>Созданный в ОС процесс в случае успеха операции и <c>null</c> в противном случае</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Execute(System.IO.FileInfo,System.String,System.Boolean)">
            <summary>Запустить процесс в ОС на основе указанного файла</summary>
            <param name="File">Файл для запуска</param>
            <param name="Args">Аргументы командной строки</param>
            <param name="UseShellExecute">Заставить ОС определить требуемый способ запуска</param>
            <returns>Созданный в ОС процесс в случае успеха операции и <c>null</c> в противном случае</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetStringLines(System.IO.FileInfo)">
            <summary>Получить перечисление строк файла без его загрузки в память целиком</summary>
            <param name="File">Файл, строки которого требуется прочитать</param>
            <returns>Перечисление строк файла</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.GetStringLines(System.IO.FileInfo,System.Text.Encoding)">
            <summary>Получить перечисление строк файла в указанной кодировке без его загрузки в память целиком</summary>
            <param name="File">Файл, строки которого требуется прочитать</param>
            <param name="encoding">Кодировка</param>
            <returns>Перечисление строк файла</returns>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Append(System.IO.FileInfo,System.String)">
            <summary>Добавить текст в конец файла</summary>
            <param name="file">Файл</param>
            <param name="Text">Добавляемый текст</param>
        </member>
        <member name="M:System.IO.FileInfoExtensions.Append(System.IO.FileInfo,System.String,System.Text.Encoding)">
            <summary>Добавить текст в конец файла</summary>
            <param name="file">Файл</param>
            <param name="Text">Добавляемый текст</param>
            <param name="encoding">Кодировка</param>
        </member>
        <member name="M:System.IO.StreamExtensions.GetBufferedStream(System.IO.Stream,System.Int32)">
            <summary>Создать буферизованный поток данных</summary>
            <param name="DataStream">Исходный поток данных</param>
            <param name="BufferSize">Размер буфера (по умолчанию 4096 байта)</param>
            <returns>Буферизованный поток данных</returns>
        </member>
        <member name="M:System.IProgressExtensions.DecimateByTimeSec``1(System.IProgress{``0},System.Double)">
            <summary>Выполнить децимацию вызовов по времени</summary>
            <typeparam name="T">Тип данных прогресса</typeparam>
            <param name="progress">Исходный прогресс операции</param>
            <param name="TimeoutInSeconds">Таймаут между вызовами в секундах</param>
            <returns>Информатор прогресса с прореживанием вызовов по времени</returns>
        </member>
        <member name="M:System.IProgressExtensions.DecimateByTimeMilliSec``1(System.IProgress{``0},System.Double)">
            <summary>Выполнить децимацию вызовов по времени</summary>
            <typeparam name="T">Тип данных прогресса</typeparam>
            <param name="progress">Исходный прогресс операции</param>
            <param name="TimeoutInMilliSeconds">Таймаут между вызовами в миллисекундах</param>
            <returns>Информатор прогресса с прореживанием вызовов по времени</returns>
        </member>
        <member name="M:System.IProgressExtensions.DecimateByTime``1(System.IProgress{``0},System.TimeSpan)">
            <summary>Выполнить децимацию вызовов по времени</summary>
            <typeparam name="T">Тип данных прогресса</typeparam>
            <param name="progress">Исходный прогресс операции</param>
            <param name="Timeout">Таймаут между вызовами</param>
            <returns>Информатор прогресса с прореживанием вызовов по времени</returns>
        </member>
        <member name="M:System.IProgressExtensions.DecimateByCallCount``1(System.IProgress{``0},System.Int32)">
            <summary>Выполнить децимацию вызовов по числу вызовов</summary>
            <typeparam name="T">Тип данных прогресса</typeparam>
            <param name="progress">Исходный прогресс операции</param>
            <param name="CallCount">Число пропускаемых вызовов</param>
            <returns>Информатор прогресса с прореживанием вызовов по количествоу</returns>
        </member>
        <member name="T:System.Xml.Serialization.XmlSerializerExtensions">
            <summary>Класс методов-расширений для XML-сериализаторов</summary>
        </member>
        <member name="F:System.Xml.Serialization.XmlSerializerExtensions.__XmlSerializersPool">
            <summary>Словарь типов - сериализаторов</summary>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerExtensions.GetXmlSerializer(System.Type)">
            <summary>Получить XML-сериализатор по указанному типу</summary>
            <param name="type">Тип XML-сериализатора</param>
            <returns>XML-сериализатор</returns>
        </member>
        <member name="M:System.Xml.Serialization.XmlSerializerExtensions.GetXmlSerializer``1">
            <summary>Получить XML-сериализатор по указанному типу</summary>
            <param name="type">Тип XML-сериализатора</param>
            <returns>XML-сериализатор</returns>
        </member>
        <member name="T:System.Xml.Serialization.IXmlSerializableAsync">
            <summary>Асинхронно сериализуемый в XML объект</summary>
        </member>
        <member name="M:System.Xml.Serialization.IXmlSerializableAsync.ReadXmlAsync(System.Xml.XmlReader)">
            <summary>Асинхронное чтение данных из XML</summary>
            <param name="reader">Источник данных XML</param>
            <returns>Задача процесса чтения данных</returns>
        </member>
        <member name="M:System.Xml.Serialization.IXmlSerializableAsync.WriteXmlAsync(System.Xml.XmlWriter)">
            <summary>Асинхронная запись данных в XML</summary>
            <param name="writer">Объект записи данных</param>
            <returns>Задача записи данных</returns>
        </member>
        <member name="M:System.Xml.XPath.ChildQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get the child value</exception>
        </member>
        <member name="M:System.Xml.XPath.DescendantQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get the decedent nodes value</exception>
        </member>
        <member name="M:System.Xml.XPath.FilterQuery.GetValue(System.Xml.XPath.XPathReader)">
            <exception cref="T:System.Xml.XPath.XPathReaderException">Can't get value</exception>
        </member>
        <member name="M:System.Xml.XPath.QueryBuilder.ProcessAxis(System.Xml.XPath.Axis,System.Xml.XPath.Query)">
            
        </member>
        <member name="T:System.Xml.XPath.XmlCaseOrder">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.None">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.UpperFirst">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlCaseOrder.LowerFirst">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XmlCharType">
            <internalonly />
            <devdoc>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XmlDataType">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlDataType.Text">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="F:System.Xml.XPath.XmlDataType.Number">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XmlReaderWrapper.Close">
            <inheritdoc />
        </member>
        <member name="M:System.Xml.XPath.XPathCollection.MatchesAny(System.Collections.ArrayList,System.Int32)">
            <exception cref="T:System.ArgumentNullException"><paramref name="list"/> is <see langword="null" />.</exception>
        </member>
        <member name="M:System.Xml.XPath.XPathParser.ParseXPathExpression(System.String)">
            <exception cref="T:System.Xml.XPath.XPathException"><see cref="P:System.Xml.XPath.XPathScanner.SourceText"/>  has an invalid token</exception>
        </member>
        <member name="M:System.Xml.XPath.XPathParser.ParseXPathPattern(System.String)">
            <exception cref="T:System.Xml.XPath.XPathException"><see cref="P:System.Xml.XPath.XPathScanner.SourceText"/>  has an invalid token</exception>
        </member>
        <member name="P:System.Xml.XPath.XPathQuery.GetXPathQueries">
            use can store this compiled expression to query other documents
        </member>
        <member name="M:System.Xml.XPath.XPathQuery.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Xml.XPath.XPathQuery.Match">
            <summary>Report if the current query is matched</summary>
            <returns>true if current query is matched</returns>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NodeType">
            <devdoc>
                <para>
                    Gets the type of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Name">
            <devdoc>
                <para>
                    Gets the name of
                    the current node, including the namespace prefix.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.LocalName">
            <devdoc>
                <para>
                    Gets the name of the current node without the namespace prefix.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NamespaceURI">
            <devdoc>
                <para>
                    Gets the namespace URN (as defined in the W3C Namespace Specification) of the current namespace scope.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Prefix">
            <devdoc>
                <para>
                    Gets the namespace prefix associated with the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.HasValue">
            <devdoc>
                <para>
                    Gets a value indicating whether
                    <see cref='P:System.Xml.XPath.XPathReader.Value' /> has a value to return.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Value">
            <devdoc>
                <para>
                    Gets the text value of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Depth">
            <devdoc>
                <para>
                    Gets the depth of the
                    current node in the XML element stack.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.BaseURI">
            <devdoc>
                <para>
                    Gets the base URI of the current node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.IsEmptyElement">
            <devdoc>
                <para>
                    Gets a value indicating whether
                    the current
                    node is an empty element (for example, &lt;MyElement/&gt;).
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.IsDefault">
            <devdoc>
                <para>
                    Gets a value indicating whether the current node is an
                    attribute that was generated from the default value defined
                    in the DTD or schema.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.QuoteChar">
            <devdoc>
                <para>
                    Gets the quotation mark character used to enclose the value of an attribute
                    node.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.XmlSpace">
            <devdoc>
                <para>Gets the current xml:space scope.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.XmlLang">
            <devdoc>
                <para>Gets the current xml:lang scope.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.AttributeCount">
            <devdoc>
                <para> The number of attributes on the current node.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.Int32)">
            <devdoc>
                <para>Gets the value of the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the specified
                    <see cref='P:System.Xml.XPath.XPathReader.Name' /> .
                </para>
            </devdoc>
            <exception cref="T:System.InvalidOperationException">
                An <see cref="T:System.Xml.XmlReader" /> method was called before a
                previous asynchronous operation finished. In this case, <see cref="T:System.InvalidOperationException" /> is thrown
                with the message “An asynchronous operation is already in progress.”
            </exception>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.Item(System.String,System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the
                    specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' /> and
                    <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.EOF">
            <devdoc>
                <para>
                    Gets
                    a value indicating whether XmlReader is positioned at the end of the
                    stream.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.ReadState">
            <devdoc>
                <para>
                    Returns
                    the read state of the stream.
                </para>
            </devdoc>
        </member>
        <member name="P:System.Xml.XPath.XPathReader.NameTable">
            <devdoc>
                <para>
                    Gets the XmlNameTable associated with this
                    implementation.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.Xml.XmlReader,System.Xml.XPath.XPathCollection)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.String,System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.IO.TextReader,System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.#ctor(System.String,System.Xml.XPath.XPathCollection)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.Int32)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.String)">
            <internalonly />
            <devdoc>
                <para>
                    Initializes a new instance of the XPathReader class with the specified XmlNameTable.
                    This constructor is used when creating reader with "new XPathReader(..)"
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Match(System.Xml.XPath.XPathQuery)">
            <internalonly />
            <devdoc>
                <para>return true when the </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MatchesAny(System.Collections.ArrayList)">
            <internalonly />
            <devdoc>
                <para> return true if one of the queries matches with the XmlReader context. </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadUntilMatch">
            <internalonly />
            <devdoc>
                <para> return true if one of the queries matches with the XmlReader context. </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Read">
            <devdoc>
                <para>
                    Reads the next
                    node from the stream.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.String)">
            <devdoc>
                <para>Moves to the attribute with the specified <see cref='P:System.Xml.XPath.XPathReader.Name' /> .</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.String,System.String)">
            <devdoc>
                <para>
                    Moves to the attribute with the specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' />
                    and <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToAttribute(System.Int32)">
            <devdoc>
                <para>Moves to the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToFirstAttribute">
            <devdoc>
                <para>
                    Moves to the first attribute.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToNextAttribute">
            <devdoc>
                <para>
                    Moves to the next attribute.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.MoveToElement">
            <devdoc>
                <para>
                    Moves to the element that contains the current attribute node.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the specified
                    <see cref='P:System.Xml.XPath.XPathReader.Name' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.String,System.String)">
            <devdoc>
                <para>
                    Gets the value of the attribute with the
                    specified <see cref='P:System.Xml.XPath.XPathReader.LocalName' /> and
                    <see cref='P:System.Xml.XPath.XPathReader.NamespaceURI' /> .
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.GetAttribute(System.Int32)">
            <devdoc>
                <para>Gets the value of the attribute with the specified index.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.Close">
            <devdoc>
                <para>
                    Closes the stream, changes the <see cref='P:System.Xml.XPath.XPathReader.ReadState' />
                    to Closed, and sets all the properties back to zero.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadString">
            <devdoc>
                <para>Reads the contents of an element as a string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.LookupNamespace(System.String)">
            <devdoc>
                <para>
                    Resolves a namespace prefix in the current element's scope.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ResolveEntity">
            <devdoc>
                <para>Resolves the entity reference for nodes of NodeType EntityReference.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadAttributeValue">
            <devdoc>
                <para>
                    Parses the attribute value into one or more Text and/or EntityReference node
                    types.
                </para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadInnerXml">
            <devdoc>
                <para>Reads all the content (including markup) as a string.</para>
            </devdoc>
        </member>
        <member name="M:System.Xml.XPath.XPathReader.ReadOuterXml">
            <devdoc>
                <para>[To be supplied.]</para>
            </devdoc>
        </member>
        <member name="T:System.Xml.XPath.XPathReaderException">
            <devdoc>
                <para>
                    Represents the exception that is thrown when there is error processing an
                    XPath expression.
                </para>
            </devdoc>
        </member>
        <member name="M:System.ByteExtensions.IsPrime(System.Byte)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.ByteExtensions.IsPrime(System.SByte)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.ByteExtensions.IsPowerOf2(System.Byte)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ByteExtensions.BitCount(System.Byte)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.ByteExtensions.BitReversing(System.Byte,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число резервируемых бит [ = 16 ]</param>
            <returns>Инверсированное число</returns>
        </member>
        <member name="M:System.ByteExtensions.IsOdd(System.Byte)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.ByteExtensions.IsEven(System.Byte)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="T:System.DecimalExtensions">
            <summary>Расширения для чисел двойной точности</summary>
        </member>
        <member name="M:System.DecimalExtensions.Sqrt(System.Decimal,System.Decimal)">
            <summary>Вычисление квадратного корня указанной точности последовательными приближениями</summary>
            <param name="x">Число, квадратный корень которого требуется вычислить</param>
            <param name="epsilon">Требуемая точность</param>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:System.DecimalExtensions.IsInt(System.Decimal,System.Decimal)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DecimalExtensions.GetInverse(System.Decimal)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="M:System.DecimalExtensions.GetZerosCount(System.Decimal)">
            <summary>
            Подсчёт количества нулей между целой частью и первым ненулевым дробным разрядом. На пример для числа 123.00123 значение будет равно 2.
            </summary>
        </member>
        <member name="T:System.DoubleArrayExtensions">
            <summary>Методы-расширения для массивов вещественных чисел</summary>
        </member>
        <member name="M:System.DoubleArrayExtensions.AddItself(System.Double[],System.Double)">
            <summary>Прибавить значение ко всем элементам массива</summary>
            <param name="array">Массив вещественных чисел</param>
            <param name="value">Прибавляемое ко всем элементам значение</param>
        </member>
        <member name="M:System.DoubleArrayExtensions.AddItself(System.Double[],System.Double[])">
            <summary>Поэлементно сложить два массива</summary>
            <param name="array">Массив - первое слагаемое</param>
            <param name="values">Массив - второе слагаемое</param>
        </member>
        <member name="M:System.DoubleArrayExtensions.Average(System.Double[][])">
            <summary>Усреднить значения всех массивов</summary>
            <param name="array">Усредняемые массивы</param>
            <returns>Массив средних значений</returns>
        </member>
        <member name="M:System.DoubleArrayExtensions.Dispersion(System.Double[])">
            <summary>Рассчитать дисперсию массива как M{X^2} - M{X}^2</summary>
            <param name="array">Массив, дисперсию элементов которого требуется рассчитать</param>
            <returns>Если длина 0, то NaN, если длина 1, то 0, иначе - дисперсия элементов массива</returns>
        </member>
        <member name="M:System.DoubleArrayExtensions.GetIntegral(System.Double[],System.Double)">
            <summary>Интегрирование значений методом трапеций с регулярной сеткой</summary>
            <param name="Y">Массив значений функции</param>
            <param name="dx">Шаг интегрирования</param>
            <returns>Площадь по кривой</returns>
        </member>
        <member name="M:System.DoubleArrayExtensions.GetIntegral(System.Double[],System.Double[])">
            <summary>Интегрирование значений методом трапеций</summary>
            <param name="Y">Массив значений функции</param>
            <param name="X">Массив значений аргумента точек значений функции</param>
            <returns>Площадь по кривой</returns>
        </member>
        <member name="M:System.DoubleArrayExtensions.GetMNKInterp(System.Double[],System.Int32,System.Double[])">
            <summary>Аппроксимация методом наименьших квадратов</summary>
            <param name="X">Массив аргументов</param>
            <param name="Y">Массив значений</param>
            <param name="m">Степень полинома интерполяции</param>
        </member>
        <member name="M:System.DoubleArrayExtensions.GetMNKInterp(System.Double[],System.Int32,System.Double,System.Double)">
            <summary>Аппроксимация методом наименьших квадратов</summary>
            <param name="Y">Массив значений</param>
            <param name="m">Степень полинома интерполяции</param>
            <param name="dx">Шаг аргумента</param>
            <param name="x0">Начальное смещение аргумента</param>
        </member>
        <member name="T:System.DoubleExtensions">
            <summary>Расширения для чисел двойной точности</summary>
        </member>
        <member name="M:System.DoubleExtensions.Abs(System.Double)">
            <summary>Модуль числа</summary>
            <param name="x">Действительное вещественное число</param>
            <returns>Модуль числа</returns>
        </member>
        <member name="M:System.DoubleExtensions.AbsMod(System.Double,System.Double)">
            <summary>Число по модулю</summary>
            <param name="x">Исходное число</param>
            <param name="mod">Модуль</param>
            <returns>Число по модулю</returns>
        </member>
        <member name="M:System.DoubleExtensions.Pow(System.Double,MathCore.Complex)">
            <summary>Возведение числа в комплексную степень</summary>
            <param name="x">Основание</param><param name="z">Комплексный показатель степень</param>
            <returns>Значение x^z, где x - действительное, z - комплексное</returns>
        </member>
        <member name="M:System.DoubleExtensions.Sqrt(System.Double)">
            <summary>Квадратный корень</summary>
            <param name="x">Число из которого извлекается квадратный корень</param>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:System.DoubleExtensions.Sqrt(System.Single)">
            <summary>Квадратный корень</summary>
            <param name="x">Число из которого извлекается квадратный корень</param>
            <returns>Квадратный корень числа</returns>
        </member>
        <member name="M:System.DoubleExtensions.IsInt(System.Double)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DoubleExtensions.IsInt(System.Single)">
            <summary>Является ли число целым?</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число целое</returns>
        </member>
        <member name="M:System.DoubleExtensions.IsNaN(System.Double)">
            <summary>Является ли значение "не числом"?</summary>
            <param name="x">Проверяемое значение</param>
            <returns>Истина, если значение - не число</returns>
        </member>
        <member name="M:System.DoubleExtensions.IsNaN(System.Single)">
            <summary>Является ли значение "не числом"?</summary>
            <param name="x">Проверяемое значение</param>
            <returns>Истина, если значение - не число</returns>
        </member>
        <member name="M:System.DoubleExtensions.Round(System.Double,System.Int32)">
            <summary>Округление числа до указанного количества знаков после запятой </summary>
            <param name="x">Округляемое число</param>
            <param name="n">Количество знаков после запятой при n >= 0 и до запятой при n меньше 0</param>
            <returns>Число, округлённое до указанной точности</returns>
        </member>
        <member name="M:System.DoubleExtensions.Round(System.Single,System.Int32)">
            <summary>Округление числа до указанного количества знаков после запятой </summary>
            <param name="x">Округляемое число</param>
            <param name="n">Количество знаков после запятой при n >= 0 и до запятой при n меньше 0</param>
            <returns>Число, округлённое до указанной точности</returns>
        </member>
        <member name="M:System.DoubleExtensions.RoundAdaptive(System.Double,System.Int32)">
            <summary>Адаптивное округление</summary>
            <param name="x">Округляемая величина</param>
            <param name="n">Количество значащих разрядов</param>
            <returns>Число с указанным количеством значащих разрядов</returns>
        </member>
        <member name="M:System.DoubleExtensions.RoundAdaptive(System.Single,System.Int32)">
            <summary>Адаптивное округление</summary>
            <param name="x">Округляемая величина</param>
            <param name="n">Количество значащих разрядов</param>
            <returns>Число с указанным количеством значащих разрядов</returns>
        </member>
        <member name="M:System.DoubleExtensions.GetInverse(System.Double)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="M:System.DoubleExtensions.GetInverse(System.Single)">
            <summary>Получить обратное число</summary>
            <param name="x">Инвертируемое число</param>
            <returns>Число, обратное к исходном</returns>
        </member>
        <member name="M:System.DoubleExtensions.In_dB(System.Double)">
            <summary>Преобразование в децибелы по амплитуде</summary>
            <param name="x">Амплитудное значение 20*lg(x)</param>
            <returns>Значение в децибелах</returns>
        </member>
        <member name="M:System.DoubleExtensions.In_dB_byPower(System.Double)">
            <summary>Преобразование в децибелы по мощности</summary>
            <param name="x">Значение мощности 10*lg(x)</param>
            <returns>Значение в децибелах</returns>
        </member>
        <member name="M:System.DoubleExtensions.From_dB(System.Double)">
            <summary>Преобразование из децибелов в разы по значению (амплитуде)</summary>
            <param name="db">Значение в децибелах 10^(x/20)</param>
            <returns>Значение в разах по амплитуде</returns>
        </member>
        <member name="M:System.DoubleExtensions.From_dB_byPower(System.Double)">
            <summary>Преобразование из децибелов в разы по мощности</summary>
            <param name="db">Значение в децибелах 10^(x/10)</param>
            <returns>Значение в разах по мощности</returns>
        </member>
        <member name="M:System.DoubleExtensions.ToRad(System.Double)">
            <summary>Преобразование значения в радианы</summary>
            <param name="deg">Значение в градусах</param>
            <returns>Значение в радианах</returns>
        </member>
        <member name="M:System.DoubleExtensions.ToDeg(System.Double)">
            <summary>Преобразование значения в градусы</summary>
            <param name="rad">Значение в радианах</param>
            <returns>Значение в градусах</returns>
        </member>
        <member name="M:System.DoubleExtensions.ToRad(System.Single)">
            <summary>Преобразование значения в радианы</summary>
            <param name="deg">Значение в градусах</param>
            <returns>Значение в радианах</returns>
        </member>
        <member name="M:System.DoubleExtensions.ToDeg(System.Single)">
            <summary>Преобразование значения в градусы</summary>
            <param name="rad">Значение в радианах</param>
            <returns>Значение в градусах</returns>
        </member>
        <member name="T:System.IntExtensions">
            <summary>Класс методов-расширений для класса целых 4-х-байтовых чисел со знаком</summary>
        </member>
        <member name="M:System.IntExtensions.Pow(System.Int32,System.Int32)">
            <summary>Возведение целого числа в целую степень</summary>
            <param name="x">Целое основание</param>
            <param name="p">Целый показатель степени</param>
            <returns>Результат возведения целого основания в целую степень</returns>
        </member>
        <member name="M:System.IntExtensions.Power(System.Int32,System.Double)">
            <summary>Возведение целого числа в вещественную степень</summary>
            <param name="x">Целое основание</param>
            <param name="q">Вещественный показатель степени</param>
            <returns>Результат возведения целого основания в вещественную степень</returns>
        </member>
        <member name="M:System.IntExtensions.Power(System.Int32,MathCore.Complex)">
            <summary>Возведение целого числа в комплексную степень</summary>
            <param name="x">Целое основание</param>
            <param name="z">Комплексный показатель степени</param>
            <returns>Результат возведения целого основания в комплексную степень</returns>
        </member>
        <member name="M:System.IntExtensions.FactorizationEnum(System.Int32)">
            <summary>Факторизация целого числа</summary>
            <param name="N">Раскладываемое число</param>
            <returns>Последовательность простых чисел составляющих раскладываемое число</returns>
        </member>
        <member name="M:System.IntExtensions.FactorizationList(System.Int32)">
            <summary>Разложение числа на простые множители</summary>
            <param name="N">Раскладываемое число</param>
            <returns>Массив простых множителей</returns>
        </member>
        <member name="M:System.IntExtensions.Factorization(System.Int32)">
            <summary>Разложение числа на простые множители</summary>
            <param name="N">Раскладываемое число</param>
            <returns>Словарь с делителями числа - значение элементов словаря - кратность делителя</returns>
        </member>
        <member name="M:System.IntExtensions.IsPrime(System.Int32)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.IntExtensions.IsPrime(System.UInt32)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.IntExtensions.IsPowerOf2(System.Int32)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.IntExtensions.IsPowerOf2(System.UInt32)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.IntExtensions.BitCount(System.Int32)">
            <summary>Определяет номер старшего бита в числе (индексация с 1)</summary>
            <param name="n">Исходное число</param>
            <returns>Число бит всех числа (включая нули)</returns>
        </member>
        <member name="M:System.IntExtensions.GetNumberOfDigits(System.Int32,System.Int32)">
            <summary>Получить число разрядов в указанной системе счисления</summary>
            <param name="n">Рассматриваемое число</param>
            <param name="Base">Основание системы счисления. По умолчанию = 10</param>
            <returns>Количество разрядов в указанной системе счисления</returns>
        </member>
        <member name="M:System.IntExtensions.GetBitArray(System.Int32,System.Int32)">
            <summary>Получить битовый массив из числа</summary>
            <param name="Value">Преобразуемое число</param>
            <param name="Length">Длина результирующего массива бит. По умолчанию = 32 битам</param>
            <returns>Битовый массив числа</returns>
        </member>
        <member name="M:System.IntExtensions.BitReversing(System.Int32,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.IntExtensions.BitReversing(System.Int32)">
            <summary>Реверсирование всех 32 бит числа</summary>
            <param name="x">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.IntExtensions.IsDeviatedTo(System.Int32,System.Int32)">
            <summary>Проверка делимости числа на делитель</summary>
            <param name="x">Делимое</param>
            <param name="y">Делитель</param>
            <returns>Истина, если остаток от целочисленного деления равен 0</returns>
        </member>
        <member name="M:System.IntExtensions.GetAbsMod(System.Int32,System.Int32)">
            <summary>Положительный остаток от деления</summary>
            <param name="x">Делимое</param>
            <param name="mod">Модуль</param>
            <returns>Остаток от деления</returns>
        </member>
        <member name="M:System.IntExtensions.GetAbs(System.Int32)">
            <summary>Получить абсолютное значение числа</summary>
            <param name="x">Вещественное число</param>
            <returns>Модуль числа</returns>
        </member>
        <member name="M:System.IntExtensions.GetNOD(System.Int32,System.Int32)">
            <summary>Наибольший общий делитель</summary>
            <param name="a">Первое число</param>
            <param name="b">Второе число</param>
            <returns>Наибольший общий делитель</returns>
        </member>
        <member name="M:System.IntExtensions.GetNOD(System.Int64,System.Int64)">
            <summary>Наибольший общий делитель</summary>
            <param name="a">Первое число</param>
            <param name="b">Второе число</param>
            <returns>Наибольший общий делитель</returns>
        </member>
        <member name="M:System.IntExtensions.GetNOD(System.UInt64,System.UInt64)">
            <summary>Наибольший общий делитель</summary>
            <param name="a">Первое число</param>
            <param name="b">Второе число</param>
            <returns>Наибольший общий делитель</returns>
        </member>
        <member name="M:System.IntExtensions.GetNOD(System.Numerics.BigInteger,System.Numerics.BigInteger)">
            <summary>Наибольший общий делитель</summary>
            <param name="a">Первое число</param>
            <param name="b">Второе число</param>
            <returns>Наибольший общий делитель</returns>
        </member>
        <member name="M:System.IntExtensions.IsOdd(System.Int32)">
            <summary>Является ли число нечётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.IntExtensions.IsEven(System.Int32)">
            <summary>Является ли число чётным</summary>
            <param name="x">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="M:System.IntExtensions.Factorial(System.Int32)">
            <summary>Факториал целого числа от 0 до 20</summary>
            <param name="n">Исходное число в пределах от 0 до 20</param>
            <exception cref="T:System.ArgumentOutOfRangeException">При 0 &gt; <paramref name="n"/> &gt; 20</exception>
            <returns>Факториал числа</returns>
        </member>
        <member name="M:System.IntExtensions.FactorialBigInt(System.Int32)">
            <summary>Факториал целого числа >= 0 и значение Г-функции для отрицательных значений</summary>
            <param name="n">Исходное число</param>
            <exception cref="T:System.ArgumentOutOfRangeException">При <paramref name="n"/> &lt; 0</exception>
            <returns>Факториал числа</returns>
        </member>
        <member name="M:System.IntExtensions.ToOctBase(System.Int32)">
            <summary>Приведение целого числа в 10 системе счисления к виду системы счисления по основанию 8</summary>
            <param name="n">Число в 10-ой системе счисления</param>
            <returns>Представление числа в 8-ричной системе счисления</returns>
        </member>
        <member name="M:System.IntExtensions.FromOctalBase(System.Int32)">
            <summary>Приведение целого числа в 8 системе счисления к виду системы счисления по основанию 10</summary>
            <param name="x">Число в 8-ой системе счисления</param>
            <returns>Представление числа в 10-ричной системе счисления</returns>
        </member>
        <member name="M:System.LongExtensions.IsPrime(System.Int64)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.LongExtensions.IsPrime(System.UInt64)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.LongExtensions.IsPowerOf2(System.Int64)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.LongExtensions.IsPowerOf2(System.UInt64)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.LongExtensions.BitCount(System.Int64)">
            <summary>Число бит числа</summary>
            <param name="x">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.LongExtensions.BitReversing(System.Int64,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.LongExtensions.BitReversing(System.Int64)">
            <summary>Реверсирование всех 64 бит числа</summary>
            <param name="N">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.LongExtensions.IsOdd(System.Int64)">
            <summary>Является ли число нечётным</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.LongExtensions.IsEven(System.Int64)">
            <summary>Является ли число чётным</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="M:System.LongExtensions.Factorial(System.Int64)">
            <summary>Факториал целого числа от 0 до 20</summary>
            <param name="n">Исходное число в пределах от 0 до 20</param>
            <exception cref="T:System.ArgumentOutOfRangeException">При 0 &gt; <paramref name="n"/> &gt; 20</exception>
            <returns>Факториал числа</returns>
        </member>
        <member name="M:System.LongExtensions.Factorial(System.UInt64)">
            <summary>Факториал целого числа от 0 до 20</summary>
            <param name="n">Исходное число в пределах от 0 до 20</param>
            <exception cref="T:System.ArgumentOutOfRangeException">При 0 &gt; <paramref name="n"/> &gt; 20</exception>
            <returns>Факториал числа</returns>
        </member>
        <member name="M:System.LongExtensions.Pow(System.Int64,System.Int32)">
            <summary>Возведение целого числа в целую степень</summary>
            <param name="x">Целое основание</param>
            <param name="p">Целый показатель степени</param>
            <returns>Результат возведения целого основания в целую степень</returns>
        </member>
        <member name="M:System.ShortExtensions.IsPrime(System.Int16)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.ShortExtensions.IsPrime(System.UInt16)">
            <summary>Проверка - является ли число простым?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число простое</returns>
        </member>
        <member name="M:System.ShortExtensions.IsPowerOf2(System.Int16)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ShortExtensions.IsPowerOf2(System.UInt16)">
            <summary>Является ли число степенью двойки?</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число - степень двойки 1,2,4...1024,2048...2^n</returns>
        </member>
        <member name="M:System.ShortExtensions.BitCount(System.Int16)">
            <summary>Число бит числа</summary>
            <param name="N">Значащее число</param>
            <returns>Число бит числа</returns>
        </member>
        <member name="M:System.ShortExtensions.BitReversing(System.Int16,System.Int32)">
            <summary>Реверсирование бит числа</summary>
            <param name="x">исходное число</param>
            <param name="N">Число реверсируемых бит</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ShortExtensions.BitReversing(System.Int16)">
            <summary>Реверсирование всех 16 бит числа</summary>
            <param name="N">исходное число</param>
            <returns>Реверсированное число</returns>
        </member>
        <member name="M:System.ShortExtensions.IsOdd(System.Int16)">
            <summary>Является ли число нечётным</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число нечётное</returns>
        </member>
        <member name="M:System.ShortExtensions.IsEven(System.Int16)">
            <summary>Является ли число чётным</summary>
            <param name="N">Проверяемое число</param>
            <returns>Истина, если число чётное</returns>
        </member>
        <member name="T:System.ObjectExtensions">
            <summary>Класс методов-расширений для объекта</summary>
        </member>
        <member name="M:System.ObjectExtensions.Try``1(``0,System.Action{``0},System.Action{``0,System.Exception})">
            <summary>Вызов к объекту с обработкой ошибок</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Объект, вызов к которому надо выполнить</param>
            <param name="action">Выполняемое над объектом действие, ошибки в котором требуется перехватить</param>
            <param name="OnError">Метод обработки исключения</param>
        </member>
        <member name="M:System.ObjectExtensions.Try``2(``0,System.Func{``0,``1},System.Func{``0,System.Exception,``1})">
            <summary>Вычислить значение для указанного объекта с обработкой ошибок</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="obj">Объект, для которого вычисляется значение</param>
            <param name="func">Метод вычисления значения</param>
            <param name="OnError">Функция обработки исключения, возвращающий значение в случае его возникновения</param>
            <returns>Результат вызова</returns>
        </member>
        <member name="M:System.ObjectExtensions.Try``2(``0,System.Func{``0,``1},System.Action{``0,System.Exception},``1)">
            <summary>Вычислить значение для указанного объекта с обработкой ошибок</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="obj">Объект, для которого вычисляется значение</param>
            <param name="func">Метод вычисления значения</param>
            <param name="OnError">Действие обработки исключения</param>
            <param name="DefaultResult">Значение по умолчанию, возвращаемое в случае возникновения исключения</param>
            <returns>Результат вызова</returns>
        </member>
        <member name="M:System.ObjectExtensions.AsEnumerable``1(``0,System.Func{``0,``0},System.Boolean)">
            <summary>Преобразование объекта в бесконечное перечисление</summary>
            <typeparam name="T">Тип элементов генерируемого перечисления</typeparam>
            <param name="obj">Объект, на основе которого создаётся перечисление</param>
            <param name="NextObject">Метод, генерирующий новый объект последовательности</param>
            <param name="TakeFirst">Выдать в последовательность исходный элемент</param>
            <returns>Бесконечная последовательность элементов, генерируемая указанным методом</returns>
        </member>
        <member name="T:System.ObjectExtensions.ObjectSelector`2">
            <summary>Селектор элементов</summary>
            <typeparam name="TSource">Тип объекта-источника</typeparam>
            <typeparam name="TResult">Тип объекта-значения</typeparam>
        </member>
        <member name="P:System.ObjectExtensions.ObjectSelector`2.Continue">
            <summary>Продолжать выборку?</summary>
        </member>
        <member name="P:System.ObjectExtensions.ObjectSelector`2.Object">
            <summary>Объект-источник</summary>
        </member>
        <member name="P:System.ObjectExtensions.ObjectSelector`2.Result">
            <summary>Объект-значение</summary>
        </member>
        <member name="P:System.ObjectExtensions.ObjectSelector`2.Iteration">
            <summary>Номер итерации</summary>
        </member>
        <member name="M:System.ObjectExtensions.ObjectSelector`2.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.ObjectExtensions.ObjectSelector`2"/></summary>
        </member>
        <member name="M:System.ObjectExtensions.ObjectSelector`2.Next(`1,System.Boolean)">
            <summary>Переход к следующей итерации</summary>
            <param name="result">Результат итерации</param>
            <param name="CanContinue">Продолжать выборку</param>
        </member>
        <member name="M:System.ObjectExtensions.SelectObj``2(``0,System.Action{System.ObjectExtensions.ObjectSelector{``0,``1}})">
            <summary>Генерация последовательности значений на основе алгоритма выборки</summary>
            <typeparam name="TSource">Тип объекта-источника</typeparam>
            <typeparam name="TResult">Тип объекта-значения последовательности</typeparam>
            <param name="source">Источник последовательности</param>
            <param name="Selector">Метод выборки элементов из источника</param>
            <returns>Последовательность объектов, генерируемых на основе объекта-источника</returns>
        </member>
        <member name="M:System.ObjectExtensions.SelectObject``2(``0,System.Func{``0,``1})">
            <summary>Метод преобразования объекта</summary>
            <typeparam name="TSource">Тип источника объекта</typeparam>
            <typeparam name="TResult">Тип результата</typeparam>
            <param name="source">Объект-источник</param>
            <param name="Selector">Метод генерации значения</param>
            <returns>Значение, определяемое на основе объекта-источника указанным методом</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToFormattedString(System.Object,System.String)">
            <summary>Преобразование объекта в форматированную строку</summary>
            <param name="obj">Преобразуемый объект</param>
            <param name="Format">Строка форматирования</param>
            <returns>Форматированная строка текстового представления объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToFormattedString(System.Object,System.String,System.Object[])">
            <summary>Преобразование объекта в форматированную строку</summary>
            <param name="obj">Преобразуемый объект (идущий нулевым аргументом)</param>
            <param name="Format">Строка форматирования</param>
            <param name="args">Массив аргументов, добавляемых к объекту для создание форматированной строки</param>
            <returns>Форматированная строка текстового представления объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToString``1(``0,System.Func{``0,System.String})">
            <summary>Метод преобразования объекта в строку</summary>
            <typeparam name="T">Тип исходного объекта</typeparam>
            <param name="t">Преобразуемый объект</param>
            <param name="converter">Метод преобразования объекта в строку</param>
            <returns>Сгенерированная строка указанным методом на основе указанного объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetHashCode(System.Object[])">
            <summary>Расчёт хеш-кода массива объектов</summary>
            <param name="Objects">Массив объектов, хеш-код которых надо рассчитать</param>
            <returns>Хеш-код массива объектов</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetComplexHashCode(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Расчёт хеш-кода перечисления объектов</summary>
            <param name="Objects">Перечисление объектов, хеш-код которых надо рассчитать</param>
            <returns>Хеш-код перечисления объектов</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetObjectAttribute``1(System.Object,System.Boolean)">
            <summary>Извлечение атрибута метаданных объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <param name="o">Объект, атрибут которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>Искомый атрибут в случае его наличия, либо null, если атрибут не определён</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetObjectAttributes``1(System.Object,System.Boolean)">
            <summary>Извлечение всех атрибутов указанного типа для объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <param name="o">Объект, атрибуты которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>Массив атрибутов указанного типа, определённых для объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.IsNotNull(System.Object)">
            <summary>Ссылка на объект не равна null</summary>
            <param name="o">Проверяемый объект</param>
            <returns>Истина, если проверяемый объект не null</returns>
        </member>
        <member name="M:System.ObjectExtensions.IsNull(System.Object)">
            <summary>Ссылка на объект равна null</summary>
            <param name="o">Проверяемый объект</param>
            <returns>Истина, если проверяемый объект null</returns>
        </member>
        <member name="M:System.ObjectExtensions.NotNull``1(``0,System.String,System.String)">
            <summary>Проверка на пустую ссылку</summary>
            <typeparam name="T">Тип проверяемого объекта</typeparam>
            <param name="obj">Проверяемое значение</param>
            <param name="Message">Сообщение ошибки</param>
            <param name="ParameterName">Название параметра</param>
            <returns>Значение, точно не являющееся пустой ссылкой</returns>
            <exception cref="T:System.InvalidOperationException">В случае если переданное значение <paramref name="obj"/> == <c>null</c> и <paramref name="ParameterName"/> == <c>null</c></exception>
            <exception cref="T:System.ArgumentNullException">В случае если переданное значение <paramref name="obj"/> == <c>null</c> и <paramref name="ParameterName"/> != <c>null</c></exception>
        </member>
        <member name="M:System.ObjectExtensions.GetAttributes``2(``1,System.Boolean)">
            <summary>Получение списка атрибутов указанного типа для типа переданного объекта</summary>
            <typeparam name="TAttribute">Тип извлекаемого атрибута</typeparam>
            <typeparam name="TObject">Тип исходного объекта</typeparam>
            <param name="_">Объект, атрибуты которого требуется получить</param>
            <param name="Inherited">Искать в цепочке наследования</param>
            <returns>Массив атрибутов указанного типа, определённых для типа объекта</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``1(``0,System.Action{``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="Initializer">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``2(``0,``1,System.Action{``0,``1})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializer">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``3(``0,``1,``2,System.Action{``0,``1,``2})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP1">Тип параметра 1 инициализации</typeparam>
            <typeparam name="TP2">Тип параметра 2 инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter1">Параметр 1 инициализации</param>
            <param name="parameter2">Параметр 2 инициализации</param>
            <param name="Initializer">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``4(``0,``1,``2,``3,System.Action{``0,``1,``2,``3})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP1">Тип параметра 1 инициализации</typeparam>
            <typeparam name="TP2">Тип параметра 2 инициализации</typeparam>
            <typeparam name="TP3">Тип параметра 3 инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter1">Параметр инициализации</param>
            <param name="parameter2">Параметр инициализации</param>
            <param name="parameter3">Параметр инициализации</param>
            <param name="Initializer">Действие инициализации</param>
            <returns>Инициализированный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``1(``0,System.Func{``0,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="Initializer">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``2(``0,``1,System.Func{``0,``1,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP">Тип параметра инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter">Параметр инициализации</param>
            <param name="Initializer">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``4(``0,``1,``2,``3,System.Func{``0,``1,``2,``3,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP1">Тип параметра 1 инициализации</typeparam>
            <typeparam name="TP2">Тип параметра 2 инициализации</typeparam>
            <typeparam name="TP3">Тип параметра 3 инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter1">Параметр 1 инициализации</param>
            <param name="parameter2">Параметр 2 инициализации</param>
            <param name="parameter3">Параметр 3 инициализации</param>
            <param name="Initializer">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtensions.InitializeObject``3(``0,``1,``2,System.Func{``0,``1,``2,``0})">
            <summary>Инициализировать объект ссылочного типа</summary>
            <typeparam name="T">Тип объекта</typeparam>
            <typeparam name="TP1">Тип параметра 1 инициализации</typeparam>
            <typeparam name="TP2">Тип параметра 2 инициализации</typeparam>
            <param name="obj">Инициализируемый объект</param>
            <param name="parameter1">Параметр 1 инициализации</param>
            <param name="parameter2">Параметр 2 инициализации</param>
            <param name="Initializer">Функция инициализации, определяющая значение конечного объекта</param>
            <returns>Объект, возвращённый функцией инициализации</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToConsole``1(``0)">
            <summary>Печать объекта на консоли без переноса строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtensions.ToConsole``1(``0,System.String,System.Object[])">
            <summary>Печать объекта на консоли в указанному формате без переноса строки в конце</summary>
            <typeparam name="TObject">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Format">Строка форматирования результата</param>
            <param name="args">Дополнительные аргументы строки форматирования</param>
        </member>
        <member name="M:System.ObjectExtensions.ToConsoleLN``1(``0)">
            <summary>Печать объекта на консоли с переносом строки в конце</summary>
            <typeparam name="T">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
        </member>
        <member name="M:System.ObjectExtensions.ToConsoleLN``1(``0,System.String,System.Object[])">
            <summary>Печать объекта на консоли в указанному формате с переносом строки в конце</summary>
            <typeparam name="TObject">Тип печатаемого объекта</typeparam>
            <param name="Obj">Печатаемый объект</param>
            <param name="Format">Строка форматирования результата</param>
            <param name="args">Дополнительные аргументы строки форматирования</param>
        </member>
        <member name="M:System.ObjectExtensions.ToByteArray``1(``0)">
            <summary>Преобразование структуры в массив байт</summary>
            <typeparam name="T">Тип преобразуемой структуры</typeparam>
            <param name="value">Значение преобразуемой структуры</param>
            <returns>Массив байт, представляющий указанную структуру</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToStructure``1(System.Byte[],System.Int32)">
            <summary>Преобразование массива байт в структуру</summary>
            <typeparam name="T">Тип структуры</typeparam>
            <param name="data">Массив байт</param>
            <param name="offset">Смещение в массиве байт</param>
        </member>
        <member name="M:System.ObjectExtensions.Switch(System.Object,System.Actions,System.Action{System.Object})">
            <summary>Выбор действия для объекта</summary>
            <param name="obj">Объект, на котором выполняется выбор действия</param>
            <param name="actions">Словарь возможных действий над объектом</param>
            <param name="Default">Действие по умолчанию</param>
        </member>
        <member name="M:System.ObjectExtensions.ToEvaluation``1(``0)">
            <summary>Преобразование объекта в вычисление</summary>
            <typeparam name="T">Тип исходного элемента</typeparam>
            <param name="obj">Оборачиваемый объект</param>
            <returns>Вычисление, возвращающее указанный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToEvaluation``1(``0,System.String)">
            <summary>Преобразование объекта в именованное вычисление</summary>
            <typeparam name="T">Тип исходного элемента</typeparam>
            <param name="obj">Оборачиваемый объект</param>
            <param name="Name">Имя вычисления</param>
            <returns>Вычисление, возвращающее указанный объект</returns>
        </member>
        <member name="M:System.ObjectExtensions.ToExpression(System.Object)">
            <summary>Преобразование объекта в выражение-константу</summary>
            <param name="obj">Преобразуемый объект</param>
            <returns>Выражение-константа</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetCallExpression(System.Object,System.Delegate,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="d">Делегат метода</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetCallExpression(System.Object,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="d">Описание метода</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="M:System.ObjectExtensions.GetCallExpression(System.Object,System.String,System.Linq.Expressions.Expression[])">
            <summary>Получить выражение вызова метода объекта</summary>
            <param name="obj">Объект, метод которого надо вызвать</param>
            <param name="MethodName">Имя метода</param>
            <param name="p">Параметры метода</param>
            <returns>Выражение вызова метода</returns>
        </member>
        <member name="T:System.Actions">
            <summary>Словарь действий</summary>
        </member>
        <member name="T:System.PredicateExtensions">
            <summary>Методы-расширения для функций-предикатов</summary>
        </member>
        <member name="M:System.PredicateExtensions.Invert``1(System.Predicate{``0})">
            <summary>Создать предикат, значение которого отрицает значение исходного предиката</summary>
            <param name="p">Предикат, значение которого необходимо инвертировать</param>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого обратно значению исходного предиката</returns>
        </member>
        <member name="M:System.PredicateExtensions.And``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "И" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "И" для двух исходных предикатов</returns>
        </member>
        <member name="M:System.PredicateExtensions.AndLazy``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "ленивого И" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "ленивого И" для двух исходных предикатов</returns>
        </member>
        <member name="M:System.PredicateExtensions.Or``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "ИЛИ" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "ИЛИ" для двух исходных предикатов</returns>
        </member>
        <member name="M:System.PredicateExtensions.OrLazy``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "ленивого ИЛИ" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "ленивого ИЛИ" для двух исходных предикатов</returns>
        </member>
        <member name="M:System.PredicateExtensions.XOr``1(System.Predicate{``0},System.Predicate{``0})">
            <summary>Вычисление логического "ленивого исключающего ИЛИ" для двух предикатов</summary>
            <typeparam name="T">Тип параметра предиката</typeparam>
            <returns>Предикат, значение которого является результатом вычисления логического "ленивого исключающего ИЛИ" для двух исходных предикатов</returns>
        </member>
        <member name="T:System.RandomExtensions">
            <summary>Методы-расширения для генератора случайных чисел</summary>
        </member>
        <member name="M:System.RandomExtensions.GetRandomizer``1(System.Random,System.Collections.Generic.IList{``0})">
            <summary>Создать генератор случных элементов</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <param name="Random">Датчик случайных чисел</param>
            <param name="Items">Список элементов, на основе которого надо создать генератор</param>
            <returns>Генератор случайного значения из элементов списка</returns>
        </member>
        <member name="M:System.RandomExtensions.GetRandomizer``1(System.Random,``0[])">
            <summary>Создать генератор случных элементов</summary>
            <typeparam name="T">Тип элементов списка</typeparam>
            <param name="Random">Датчик случайных чисел</param>
            <param name="Items">Элементы, на основе которых надо создать генератор</param>
            <returns>Генератор случайного значения из элементов списка</returns>
        </member>
        <member name="M:System.RandomExtensions.NextItem``1(System.Random,``0[])">
            <summary>Случайный элемент из указанного набора вариантов (ссылка на элемент)</summary>
            <typeparam name="T">Тип элементов</typeparam>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="items">Массив вариантов</param>
            <returns>Ссылка на случайный элемент массива</returns>
        </member>
        <member name="M:System.RandomExtensions.NextItem``1(System.Random,System.Collections.Generic.IList{``0})">
            <summary>Случайных элемент из списка</summary>
            <typeparam name="T">Тип элементов для выбора</typeparam>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="items">Список элементов для выбора</param>
            <returns>Случайный элемент из списка</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniform(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Массив случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Массив случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniformEnum(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Перечисление случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Перечисление случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniform(System.Random,System.Int32,MathCore.Interval)">
            <summary>Массив случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="Interval">Интервал</param>
            <returns>Массив случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniformEnum(System.Random,System.Int32,MathCore.Interval)">
            <summary>Перечисление случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="Interval">Интервал</param>
            <returns>Перечисление случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniform(System.Random,MathCore.Interval[])">
            <summary>Массив случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Intervals">Интервал</param>
            <returns>Массив случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniformInterval(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Массив случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="Min">Минимум</param>
            <param name="Max">Максимум</param>
            <returns>Массив случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniformIntervalEnum(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Перечисление случайных чисел с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="Min">Минимум</param>
            <param name="Max">Максимум</param>
            <returns>Перечисление случайных чисел с равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValues(System.Random,System.Int32)">
            <summary>Массив целых неотрицательных случайных чисел</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <returns>Массив целых неотрицательных случайных чисел</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValuesEnum(System.Random,System.Int32)">
            <summary>Перечисление целых неотрицательных случайных чисел</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <returns>перечисление целых неотрицательных случайных чисел</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValues(System.Random,System.Int32,System.Int32)">
            <summary>Массив целых неотрицательных случайных чисел ограниченный сверху (верхний предел не входит)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="Max">Максимум (не входит)</param>
            <returns>Массив целых неотрицательных случайных чисел (верхний предел не входит)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValuesEnum(System.Random,System.Int32,System.Int32)">
            <summary>Перечисление целых неотрицательных случайных чисел ограниченный сверху (верхний предел не входит)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="Max">Максимум (не входит)</param>
            <returns>Перечисление целых неотрицательных случайных чисел (верхний предел не входит)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValues(System.Random,System.Int32,System.Int32,System.Int32)">
            <summary>Массив целых неотрицательных случайных чисел в заданном интервале (верхний предел не входит)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="Min">Минимум</param>
            <param name="Max">Максимум (не входит)</param>
            <returns>Массив целых неотрицательных случайных чисел в заданном интервале (верхний предел не входит)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextValuesEnum(System.Random,System.Int32,System.Int32,System.Int32)">
            <summary>Перечисление целых неотрицательных случайных чисел в заданном интервале (верхний предел не входит)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер перечисления (если меньше 0, то бесконечное)</param>
            <param name="Min">Минимум</param>
            <param name="Max">Максимум (не входит)</param>
            <returns>Перечисление целых неотрицательных случайных чисел в заданном интервале (верхний предел не входит)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextNormal(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Массив случайных чисел с нормальным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Массив случайных чисел с нормальным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextNormalEnum(System.Random,System.Int32,System.Double,System.Double)">
            <summary>Перечисление случайных чисел с нормальным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="Count">Размер массива</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Перечисление случайных чисел с нормальным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextNormal(System.Random,System.Double,System.Double)">
            <summary>Случайное число с нормальным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="sigma">Среднеквадратичное отклонение</param>
            <param name="mu">Математическое ожидание</param>
            <returns>Случайное число с нормальным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextUniform(System.Random,System.Double,System.Double)">
            <summary>Случайное число с равномерным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="D">Дисперсия</param>
            <param name="M">Математическое ожидание</param>
            <returns>Случайное число в равномерным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.NextTriangular(System.Random,System.Double,System.Double,System.Double)">
            <summary>Случайное число с треугольным распределением</summary>
            <remarks>http://en.wikipedia.org/wiki/Triangular_distribution</remarks>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="min">Минимум</param>
            <param name="max">Максимум</param>
            <param name="mode">Медиана</param>
            <returns>Случайное число с треугольным распределением</returns>
        </member>
        <member name="M:System.RandomExtensions.FillUniform(System.Random,System.Double[])">
            <summary>Заполнить массив случайными числами с равномерным распределением в интервале [0, 1)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="Array">Заполняемый массив</param>
        </member>
        <member name="M:System.RandomExtensions.FillUniform(System.Random,System.Double[],System.Double)">
            <summary>Заполнить массив случайными числами с равномерным распределением в интервале [-D/2, D/2)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="Array">Заполняемый массив</param>
            <param name="D">Дисперсия значений</param>
        </member>
        <member name="M:System.RandomExtensions.FillUniform(System.Random,System.Double[],System.Double,System.Double)">
            <summary>Заполнить массив случайными числами с равномерным распределением в интервале [-D/2 + M, D/2 + M)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="Array">Заполняемый массив</param>
            <param name="D">Дисперсия значений</param>
            <param name="M">Математическое ожидание</param>
        </member>
        <member name="M:System.RandomExtensions.NextBoolean(System.Random)">
            <summary>Случайное значение <see langword="true"/>/<see langword="false"/></summary>
            <param name="rnd">Генератор случайных чисел</param>
        </member>
        <member name="M:System.RandomExtensions.NextDouble(System.Random,System.Double)">
            <summary>Случайное число с равномерным распределением в интервале [-D/2, D/2)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="D">Дисперсия значений</param>
            <returns>Случайное число в интервале  [-D/2, D/2)</returns>
        </member>
        <member name="M:System.RandomExtensions.NextDouble(System.Random,System.Double,System.Double)">
            <summary>Случайное число с равномерным распределением в интервале [-D/2 + M, D/2 + M)</summary>
            <param name="rnd">Генератор случайных чисел</param>
            <param name="D">Дисперсия значений</param>
            <param name="M">Математическое ожидание</param>
            <returns>Случайное число в интервале  [-D/2 + M, D/2 + M)</returns>
        </member>
        <member name="M:System.RandomExtensions.Mix(System.Random,System.Collections.IList)">
            <summary>Shuffles a list in O(n) time by using the Fisher-Yates/Knuth algorithm</summary>
            <param name="rnd"></param>
            <param name = "list"></param>
        </member>
        <member name="M:System.RandomExtensions.Permutation(System.Random,System.Int32,System.Int32)">
            <summary>
            Returns n unique random numbers in the range [1, n], inclusive. 
            This is equivalent to getting the first n numbers of some random permutation of the sequential numbers from 1 to max. 
            Runs in O(k^2) time.
            </summary>
            <param name="rnd"></param>
            <param name="n">Maximum number possible.</param>
            <param name="k">How many numbers to return.</param>
            <returns></returns>
        </member>
        <member name="M:System.RandomExtensions.Next``1(System.Random,System.Int32,``0[])">
            <summary>Случайных элемент из перечисленных вариантов</summary>
            <typeparam name="T">Тип вариантов выбора</typeparam>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="count">Количество результатов выбора</param>
            <param name="variants">Перечисление вариантов выбора</param>
            <returns>Последовательность случайных вариантов</returns>
        </member>
        <member name="M:System.RandomExtensions.SequenceInt(System.Random,System.Int32,System.Int32,System.Int32)">
            <summary>Последовательность случайных целых чисел в указанном интервале</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="min">Нижняя граница интервала (входит)</param>
            <param name="max">Верхняя граница интервала (не входит)</param>
            <param name="count">Размер выборки (если меньше 0), то бесконечная последовательность</param>
            <returns>Последовательность случайных целых чисел в указанном интервале</returns>
        </member>
        <member name="M:System.RandomExtensions.SequenceDouble(System.Random,System.Int32)">
            <summary>Последовательность случайных вещественных чисел с равномерным распределением в интервале (0,1)</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="count">Размер выборки (если меньше 0), то бесконечная последовательность</param>
            <returns>Последовательность случайных вещественных чисел в интервале (0,1)</returns>
        </member>
        <member name="M:System.RandomExtensions.SequenceNormal(System.Random,System.Double,System.Double,System.Int32)">
            <summary>Последовательность случайных вещественных чисел с нормальным распределением</summary>
            <param name="rnd">Датчик случайных чисел</param>
            <param name="M">Математическое ожидание</param>
            <param name="D">Дисперсия</param>
            <param name="count">Размер выборки (если меньше 0), то бесконечная последовательность</param>
            <returns>Последовательность случайных вещественных чисел</returns>
        </member>
        <member name="M:System.Text.RegularExpressions.RegExExtensions.OrDefault(System.Text.RegularExpressions.Match,System.String)">
            <summary>Метод получения значения из результатов совпадения поиска</summary>
            <param name="match">Результат совпадения поиска</param>
            <param name="DefaultString">Значение по умолчанию</param>
            <returns>Результат поиска, либо значение по умолчанию</returns>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.CreateReader(System.Text.StringBuilder)">
            <summary>Создать объект чтения</summary>
            <param name="str">Исходный объект <see cref="T:System.Text.StringBuilder"/></param>
            <returns>Объект чтения строк</returns>
        </member>
        <member name="M:System.Text.StringBuilderExtensions.CreateWriter(System.Text.StringBuilder)">
            <summary>Создать объект записи строк</summary>
            <param name="builder">Исходный объект <see cref="T:System.Text.StringBuilder"/></param>
            <returns>Объект записи строк</returns>
        </member>
        <member name="T:System.StringExtensions">
            <summary>Методы-расширения класса <see cref="T:System.String">строк</see></summary>
        </member>
        <member name="M:System.StringExtensions.EnumLines(System.String,System.Boolean)">
            <summary>Перечисление строк в строке</summary>
            <param name="str">Исходная строка</param>
            <param name="SkipEmpty">Пропускать пустые строки</param>
            <returns>Перечисление строк в строке</returns>
        </member>
        <member name="M:System.StringExtensions.EnumLines``1(System.String,System.Func{System.String,``0},System.Boolean)">
            <summary>Перечисление строк в строке</summary>
            <param name="str">Исходная строка</param>
            <param name="Selector">Преобразователь значения</param>
            <param name="SkipEmpty">Пропускать пустые строки</param>
            <returns>Перечисление строк в строке</returns>
        </member>
        <member name="M:System.StringExtensions.EnumLines``1(System.String,System.Func{System.String,System.Int32,``0},System.Boolean)">
            <summary>Перечисление строк в строке</summary>
            <param name="str">Исходная строка</param>
            <param name="Selector">Преобразователь значения</param>
            <param name="SkipEmpty">Пропускать пустые строки</param>
            <returns>Перечисление строк в строке</returns>
        </member>
        <member name="M:System.StringExtensions.CreateReader(System.String)">
            <summary>Создать объект чтения данных строки</summary>
            <param name="str">Исходная строка</param>
            <returns>Объект <see cref="T:System.IO.StringReader"/> для чтения данных строки</returns>
        </member>
        <member name="M:System.StringExtensions.CreateBuilder(System.String)">
            <summary>Создать построитель строки</summary>
            <param name="str">Исходная строка</param>
            <returns>Объект <see cref="T:System.Text.StringBuilder"/> для формирования строки</returns>
        </member>
        <member name="M:System.StringExtensions.AsStringPtr(System.String)">
            <summary>Преобразовать строку в указатель</summary>
            <param name="str">Исходная строка</param>
            <returns>Указатель на позицию в строке</returns>
        </member>
        <member name="M:System.StringExtensions.AsStringPtr(System.String,System.Int32)">
            <summary>Преобразовать строку в указатель</summary>
            <param name="str">Исходная строка</param>
            <param name="Pos">Положение в строке</param>
            <returns>Указатель на позицию в строке</returns>
        </member>
        <member name="M:System.StringExtensions.AsStringPtr(System.String,System.Int32,System.Int32)">
            <summary>Преобразовать строку в указатель</summary>
            <param name="str">Исходная строка</param>
            <param name="Pos">Положение в строке</param>
            <param name="Length">Длина подстроки</param>
            <returns>Указатель на позицию в строке</returns>
        </member>
        <member name="M:System.StringExtensions.Compress(System.String)">
            <summary>Сжать строку в последовательность байт</summary>
            <param name="str">Сжимаемая строка</param>
            <returns>Сжатая строка в виде последовательности байт</returns>
        </member>
        <member name="M:System.StringExtensions.CompressAsync(System.String,System.Threading.CancellationToken)">
            <summary>Сжать строку в последовательность байт</summary>
            <param name="str">Сжимаемая строка</param>
            <param name="Cancel">Отмена операции</param>
            <returns>Сжатая строка в виде последовательности байт</returns>
        </member>
        <member name="M:System.StringExtensions.DecompressAsString(System.Byte[])">
            <summary>Разархивировать последовательность байт в строку</summary>
            <param name="bytes">Сжатая последовательность бай, содержащая строку</param>
            <returns>Распакованная последовательность байт в строковом представлении</returns>
        </member>
        <member name="M:System.StringExtensions.DecompressAsStringAsync(System.Byte[],System.Threading.CancellationToken)">
            <summary>Разархивировать последовательность байт в строку</summary>
            <param name="bytes">Сжатая последовательность бай, содержащая строку</param>
            <param name="Cancel">Отмена операции</param>
            <returns>Распакованная последовательность байт в строковом представлении</returns>
        </member>
        <member name="M:System.StringExtensions.FindBlock(System.String,System.String)">
            <summary>Перечисление подстрок, разделяемых указанным строковым шаблоном</summary>
            <param name="Str">Разбиваемая строка</param>
            <param name="EndPattern">Строковый шаблон разбиения</param>
            <returns>Перечисление подстрок</returns>
        </member>
        <member name="M:System.StringExtensions.GetBracketText(System.String,System.Int32@,System.String,System.String)">
            <summary>Выделение подстроки, ограниченной шаблоном начала и шаблоном окончания строки начиная с указанного смещения</summary>
            <param name="Str">Входная строка</param>
            <param name="Offset">Смещение во входной строке начала поиска - в конце работы метода соответствует месту окончания поиска</param>
            <param name="Open">Шаблон начала подстроки</param>
            <param name="Close">Шаблон окончания подстроки</param>
            <returns>Подстрока, заключённая между указанными шаблонами начала и окончания</returns>
            <exception cref="T:System.FormatException">
            Если шаблон завершения строки на найден, либо если количество шаблонов начала строки превышает 
            количество шаблонов окончания во входной строке
            </exception>
        </member>
        <member name="M:System.StringExtensions.IsNullOrEmpty(System.String)">
            <summary>Проверка строки на пустоту, либо нулевую ссылку</summary>
            <param name="Str">Проверяемая строка</param>
            <returns>Истина, если строка пуста, либо если передана нулевая ссылка</returns>
        </member>
        <member name="M:System.StringExtensions.IsNotNullOrEmpty(System.String)">
            <summary>Строка присутствует и не пуста</summary>
            <param name="Str">Проверяемая строка</param>
            <returns>Истина, если строка не  пуста, и если передана ненулевая ссылка</returns>
        </member>
        <member name="M:System.StringExtensions.ClearSymbolsAtBegin(System.String,System.Char[])">
            <summary>Удаление символов в начале строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в начале</returns>
        </member>
        <member name="M:System.StringExtensions.ClearSymbolsAtEnd(System.String,System.Char[])">
            <summary>Удаление символов в конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в конце</returns>
        </member>
        <member name="M:System.StringExtensions.ClearSymbolsAtBeginAndEnd(System.String,System.Char[])">
            <summary>Удаление символов в начале и конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <param name="symbols">Перечень удаляемых символов</param>
            <returns>Новая строка с удалёнными символами в начале и конце</returns>
        </member>
        <member name="M:System.StringExtensions.ClearSystemSymbolsAtBeginAndEnd(System.String)">
            <summary>Удаление служебных символов в начале и конце строки</summary>
            <param name="str">Обрабатываемая строка</param>
            <returns>Новая строка с удалёнными служебными символами в начали и конце</returns>
        </member>
        <member name="M:System.StringExtensions.NotEmpty(System.String,System.String,System.String)">
            <summary>Проверка на пустоту строки</summary>
            <param name="str">Проверяемая строка</param>
            <param name="ParameterName">Имя параметра, добавляемое в исключение в случае его генерации</param>
            <param name="Message">Сообщение, добавляемое в исключение в случае его генерации</param>
            <exception cref="T:System.ArgumentNullException">Если переданная пустая ссылка на строку <paramref name="str"/></exception>
            <exception cref="T:System.ArgumentException">Если переданная строка <paramref name="str"/> является пустой</exception>
            <returns>Строка, гарантированно не являющаяся пустой</returns>
        </member>
        <member name="M:System.StringExtensions.Encrypt(System.String,System.String)">
            <summary>Зашифровать строку</summary>
            <param name="str">Шифруемая строка</param>
            <param name="password">Пароль шифрования</param>
            <returns>Зашифрованная строка</returns>
        </member>
        <member name="M:System.StringExtensions.Encrypt(System.String,System.String,System.Byte[])">
            <summary>Зашифровать строку</summary>
            <param name="str">Шифруемая строка</param>
            <param name="password">Пароль шифрования</param>
            <param name="Salt">Соль алгоритма</param>
            <returns>Зашифрованная строка</returns>
        </member>
        <member name="M:System.StringExtensions.Encrypt(System.Byte[],System.String)">
            <summary>Зашифровать массив байт</summary>
            <param name="data">Шифруемая последовательность байт</param>
            <param name="password">Ключ шифрования</param>
            <returns>Зашифрованная последовательность байт</returns>
        </member>
        <member name="M:System.StringExtensions.Encrypt(System.Byte[],System.String,System.Byte[])">
            <summary>Зашифровать</summary>
            <param name="data">Шифруемый массив байт</param>
            <param name="password">Пароль</param>
            <param name="Salt">Соль</param>
            <returns>Зашифрованный массив байт</returns>
        </member>
        <member name="M:System.StringExtensions.Decrypt(System.Byte[],System.String)">
            <summary>Расшифровать последовательность байт</summary>
            <param name="data">Расшифровываемая последовательность байт</param>
            <param name="password">Пароль шифрования</param>
            <returns>Расшифрованная последовательность байт</returns>
        </member>
        <member name="M:System.StringExtensions.Decrypt(System.String,System.String)">
            <summary>Расшифровать строку</summary>
            <param name="str">Зашифрованная строка</param>
            <param name="password">Пароль шифрования</param>
            <returns>Расшифрованная строка</returns>
        </member>
        <member name="F:System.StringExtensions.__Salt">
            <summary>Массив байт - "соль" алгоритма шифрования Rfc2898</summary>
        </member>
        <member name="M:System.StringExtensions.GetAlgorithm(System.String,System.Byte[])">
            <summary>Получить алгоритм шифрования с указанным паролем</summary>
            <param name="password">Пароль шифрования</param>
            <param name="Salt">Соль алгоритма</param>
            <returns>Алгоритм шифрования</returns>
        </member>
        <member name="M:System.StringExtensions.GetInverseAlgorithm(System.String)">
            <summary>Получить алгоритм для расшифровки</summary>
            <param name="password">Пароль</param>
            <returns>Алгоритм расшифровки</returns>
        </member>
        <member name="T:System.StringExtensionsTrim">
            <summary>Ограничение длины строки с удалением центральной её части</summary>
        </member>
        <member name="M:System.StringExtensionsTrim.TrimByLength(System.String,System.Int32,System.String)">
            <summary>Ограничение длины строки с удалением центральной её части</summary>
            <param name="Str">Обрезаемая строка</param>
            <param name="Length">Требуемая длина</param>
            <param name="ReplacementPattern">Шаблон замены</param>
            <returns>Строка с удалённой внутренней частью</returns>
        </member>
        <member name="T:System.TypeExtensions">
            <summary>Класс методов-расширений для <see cref="T:System.Type"/></summary>
        </member>
        <member name="M:System.TypeExtensions.IsCanBeNullRef(System.Type)">
            <summary>Значение данного типа допускают <see langword="null"/></summary>
            <param name="type">Проверяемый тип</param>
            <returns>Истина, если значение проверяемого типа допускают возможность пустой ссылки</returns>
        </member>
        <member name="F:System.TypeExtensions.__NoChangeTypeFunction">
            <summary>Функция, ничего не делающая</summary>
        </member>
        <member name="F:System.TypeExtensions.__CastersDictionary">
            <summary>Пул методов приведения типов</summary>
        </member>
        <member name="F:System.TypeExtensions.__ConvParameter">
            <summary>Выражение параметра конструируемой функции</summary>
        </member>
        <member name="M:System.TypeExtensions.GetCasterFrom``1(System.Type,``0)">
            <summary>Сформировать функцию, осуществляющую приведение типов</summary>
            <param name="TargetType">Целевой тип значения</param>
            <param name="Source">Объект, тип которого требуется привести</param>
            <returns>Функция, осуществляющая приведение типа объекта к целевому типу данных</returns>
        </member>
        <member name="M:System.TypeExtensions.GetCasterTo(System.Type,System.Type)">
            <summary>Сформировать функцию, осуществляющую приведение типа значения к указанному типу данных</summary>
            <param name="SourceType">Тип исходных данных</param>
            <param name="TargetType">Тип, к которому требуется выполнить приведение</param>
            <returns>Функция, осуществляющая приведение типа значения</returns>
        </member>
        <member name="M:System.TypeExtensions.GetCasterFrom(System.Type,System.Type)">
            <summary>Сформировать функцию, осуществляющую приведение типа значения из указанного типа данных</summary>
            <param name="SourceType">Тип исходных данных</param>
            <param name="TargetType">Тип, к которому требуется выполнить приведение</param>
            <returns>Функция, осуществляющая приведение типа значения</returns>
        </member>
        <member name="M:System.TypeExtensions.Cast``1(System.Type,``0)">
            <summary>Выполнить приведение типа значения объекта</summary>
            <param name="type">Целевой тип данных</param>
            <param name="obj">Приводимое значение</param>
            <returns>Объект-значение, приведённое к целевому типу данных</returns>
        </member>
        <member name="F:System.TypeExtensions.__ConvertersDictionary">
            <summary>Выражение параметра конструируемой функции</summary>
        </member>
        <member name="M:System.TypeExtensions.GetConverterTo(System.Type,System.Type)">
            <summary>Сформировать функцию, осуществляющую преобразование типа в указанный тип данных</summary>
            <param name="SourceType">Тип исходного значения</param>
            <param name="TargetType">Целевой тип данных</param>
            <returns>Функция, осуществляющая преобразование исходного значение в значение целевого типа данных</returns>
        </member>
        <member name="M:System.TypeExtensions.GetConverterFrom(System.Type,System.Type)">
            <summary>Сформировать функцию, осуществляющую преобразование типа в указанный тип данных</summary>
            <param name="SourceType">Тип исходного значения</param>
            <param name="TargetType">Целевой тип данных</param>
            <returns>Функция, осуществляющая преобразование исходного значение в значение целевого типа данных</returns>
        </member>
        <member name="M:System.TypeExtensions.GetCastExpression(System.Type,System.Type,System.Linq.Expressions.ParameterExpression@)">
            <summary>Сформировать выражение, осуществляющее приведение типа к указанному типу данных</summary>
            <param name="SourceType">Тип исходного значения</param>
            <param name="TargetType">Целевой тип данных</param>
            <returns>Выражение, осуществляющее приведение исходного значение к целевому типу данных</returns>
        </member>
        <member name="M:System.TypeExtensions.GetConvertExpression(System.Type,System.Type)">
            <summary>Сформировать выражение, осуществляющее преобразование типа данных</summary>
            <param name="SourceType">Тип исходного значения</param>
            <param name="TargetType">Целевой тип данных</param>
            <returns>Выражение, осуществляющее преобразование типа данных</returns>
            <exception cref="T:System.NotSupportedException">Если преобразование невозможно в виду отсутствия определённых конвертеров типов</exception>
        </member>
        <member name="M:System.TypeExtensions.GetConvertExpression_Object(System.Type,System.Type)">
            <summary>Сформировать лямбда-выражение для конвертации значения</summary>
            <param name="SourceType">Тип исходного значения</param>
            <param name="TargetType">Целевой тип данных</param>
            <exception cref="T:System.NotSupportedException">Если конвертация из <paramref name="SourceType"/> в <paramref name="TargetType"/> не реализована</exception>
            <returns>Лямбда-выражение, осуществляющее конвертацию значения</returns>
        </member>
        <member name="M:System.TypeExtensions.GetTypeConverter(System.Type)">
            <summary>Получить конвертер значений для указанного типа данных</summary>
            <param name="type">Тип, для которого требуется получить конвертер</param>
            <returns>Конвертер указанного типа данных</returns>
        </member>
        <member name="M:System.TypeExtensions.GetType(System.String)">
            <summary>Получить тип по его имени из всех загруженных сборок</summary>
            <param name="TypeName">Имя типа</param>
            <returns>Тип</returns>
        </member>
        <member name="M:System.TypeExtensions.GetCustomAttributes``1(System.Type)">
            <summary>Получить все атрибуты типа указанного типа</summary>
            <typeparam name="TAttribute">Тип требуемых атрибутов</typeparam>
            <param name="T">Тип, атрибуты которого требуется получить</param>
            <returns>Массив атрибутов типа указанного типа</returns>
        </member>
        <member name="M:System.TypeExtensions.GetCustomAttributes``1(System.Type,System.Boolean)">
            <summary>Получить атрибуты типа</summary>
            <typeparam name="TAttribute">Тип необходимых атрибутов</typeparam>
            <param name="T">Тип, из которого требуется получить атрибуты</param>
            <param name="Inherited">Искать атрибуты в базовых классах типа</param>
            <returns>Массив найденных атрибутов</returns>
        </member>
        <member name="M:System.TypeExtensions.CreateObject(System.Type)">
            <summary>Создать объект типа с помощью конструктора по умолчанию</summary>
            <param name="type">Тип создаваемого объекта</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:System.TypeExtensions.Create``1(System.Type)">
            <summary>Создать объект типа с помощью конструктора по умолчанию</summary>
            <typeparam name="T">Тип необходимого объекта</typeparam>
            <param name="type">Тип создаваемого объекта</param>
            <returns>Созданный объект, приведённый к типу <typeparamref name="T"/></returns>
        </member>
        <member name="M:System.TypeExtensions.Create``1(System.Type,System.Object[])">
            <summary>Создать объект типа с помощью конструктора по умолчанию</summary>
            <typeparam name="T">Тип необходимого объекта</typeparam>
            <param name="type">Тип создаваемого объекта</param>
            <param name="Params">Параметры конструктора</param>
            <returns>Созданный объект, приведённый к типу <typeparamref name="T"/></returns>
        </member>
        <member name="M:System.TypeExtensions.CreateObject(System.Type,System.Object[])">
            <summary>Создать объект типа с помощью конструктора с заданным набором параметров</summary>
            <param name="type">Тип создаваемого объекта</param>
            <param name="Params">Параметры конструктора</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:System.TypeExtensions.CreateObject(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[])">
            <summary>Создать объект типа с помощью конструктора по умолчанию</summary>
            <param name="type">Тип создаваемого объекта</param>
            <param name="Flags">Флаги, определяющие метод поиска конструктора</param>
            <param name="binder">Объект, определяющий способ поиска конструктора</param>
            <param name="Params">Параметры конструктора</param>
            <returns>Созданный объект</returns>
        </member>
        <member name="M:System.TypeExtensions.Create``1(System.Object[])">
            <summary>Создать объект типа с помощью конструктора по умолчанию</summary>
            <param name="Params">Параметры конструктора</param>
            <returns>Созданный объект, приведённый к типу <typeparamref name="T"/></returns>
        </member>
        <member name="M:System.TypeExtensions.Create``1(System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[])">
            <summary>Создать объект типа с помощью конструктора по умолчанию</summary>
            <typeparam name="T">Тип необходимого объекта</typeparam>
            <param name="Flags">Флаги, определяющие метод поиска конструктора</param>
            <param name="binder">Объект, определяющий способ поиска конструктора</param>
            <param name="Params">Параметры конструктора</param>
            <returns>Созданный объект, приведённый к типу <typeparamref name="T"/></returns>
        </member>
        <member name="M:System.TypeExtensions.AddConverter(System.Type,System.Type)">
            <summary>Добавить конвертер к типу</summary>
            <param name="type">Тип, к которому требуется добавить конвертер</param>
            <param name="ConverterType">Тип конвертера, который надо добавить к описанию типа</param>
        </member>
        <member name="M:System.TypeExtensions.AddConverter(System.Type,System.Type[])">
            <summary>Добавить конвертер к типу</summary>
            <param name="type">Тип, к которому требуется добавить конвертер</param>
            <param name="ConverterTypes">Типы конвертеров, которые требуется добавить к описанию типа</param>
        </member>
        <member name="M:System.TypeExtensions.GetProvider(System.Type)">
            <summary>Получить объект-описатель типа <see cref="T:System.ComponentModel.TypeDescriptionProvider"/></summary>
            <param name="type">Исследуемый тип</param>
            <returns>Объект, определяющий информацию о типе - <see cref="T:System.ComponentModel.TypeDescriptionProvider"/></returns>
        </member>
        <member name="M:System.TypeExtensions.AddProvider(System.Type,System.ComponentModel.TypeDescriptionProvider)">
            <summary>Добавить описатель типа - <see cref="T:System.ComponentModel.TypeDescriptionProvider"/></summary>
            <param name="type">Тип, к которому требуется добавить описатель</param>
            <param name="provider">Добавляемый описатель типа <see cref="T:System.ComponentModel.TypeDescriptionProvider"/></param>
        </member>
        <member name="T:System.IInitializable">
            <summary>Объект, поддерживающий инициализацию</summary>
        </member>
        <member name="M:System.IInitializable.Initialize">
            <summary>Инициализация</summary>
        </member>
        <member name="T:System.IInitializable`1">
            <summary>Объект, поддерживающий инициализацию с параметром</summary>
            <typeparam name="T">Тип параметра инициализации</typeparam>
        </member>
        <member name="M:System.IInitializable`1.Initialize(`0)">
            <summary>Инициализация</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="T:System.IInitializable`2">
            <summary>Объект, поддерживающий инициализацию с двумя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`2.Initialize(`0,`1)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
        </member>
        <member name="T:System.IInitializable`3">
            <summary>Объект, поддерживающий инициализацию с тремя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`3.Initialize(`0,`1,`2)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
        </member>
        <member name="T:System.IInitializable`4">
            <summary>Объект, поддерживающий инициализацию с четырьмя параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
            <typeparam name="T4">Тип четвёртого параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`4.Initialize(`0,`1,`2,`3)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
            <param name="t4">Четвёртый параметр</param>
        </member>
        <member name="T:System.IInitializable`5">
            <summary>Объект, поддерживающий инициализацию с пятью параметрами</summary>
            <typeparam name="T1">Тип первого параметра</typeparam>
            <typeparam name="T2">Тип второго параметра</typeparam>
            <typeparam name="T3">Тип третьего параметра</typeparam>
            <typeparam name="T4">Тип четвёртого параметра</typeparam>
            <typeparam name="T5">Тип пятого параметра</typeparam>
        </member>
        <member name="M:System.IInitializable`5.Initialize(`0,`1,`2,`3,`4)">
            <summary>Инициализация</summary>
            <param name="t1">Первый параметр</param>
            <param name="t2">Второй параметр</param>
            <param name="t3">Третий параметр</param>
            <param name="t4">Четвёртый параметр</param>
            <param name="t5">Пятый параметр</param>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="FromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:System.LambdaDisposable">
            <summary>Объект, выполняющий указанное действие при сборке мусора</summary>
        </member>
        <member name="M:System.LambdaDisposable.OnDisposed(System.Action)">
            <summary>При освобождении выполнить указанное действие</summary>
            <param name="OnDispose">Действие, выполняемое при освобождении</param>
            <returns>Объект <see cref="T:System.LambdaDisposable"/></returns>
        </member>
        <member name="F:System.LambdaDisposable._DisposableAction">
            <summary>Действие, выполняемое при разрушении объекта</summary>
        </member>
        <member name="M:System.LambdaDisposable.#ctor(System.Action)">
            <summary>Инициализация нового уничтожаемого объекта с указанием действия при уничтожении</summary>
            <param name="DisposableAction">Действие, выполняемое при уничтожении объекта</param>
        </member>
        <member name="M:System.LambdaDisposable.Dispose">
            <summary>Метод уничтожения объекта, вызывающий указанное действие</summary>
        </member>
        <member name="M:System.LambdaDisposable.Dispose(System.Boolean)">
            <summary>Метод уничтожения объекта, вызывающий указанное действие</summary>
            <param name="Disposing">Если истина, то освободить управляемые ресурсы</param>
        </member>
        <member name="M:System.LambdaDisposableObject`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:System.LambdaProcessor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="T:System.Processor">
            <summary>Класс объектов, выполняющих некоторое циклическое действие в отдельном фоновом потоке</summary>
        </member>
        <member name="F:System.Processor.__AsyncException">
            <summary>Объект-исключение, передаваемое в качестве параметра события ошибки при рассинхронизации потока процессора</summary>
        </member>
        <member name="P:System.Processor.Now">
            <summary>Текущее время системы</summary>
        </member>
        <member name="E:System.Processor.System#ComponentModel#INotifyPropertyChanged#PropertyChanged">
            <summary>Событие изменения свойства объекта</summary>
        </member>
        <member name="M:System.Processor.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)">
            <summary>Вызов события изменения свойства объекта</summary>
             <param name="e">Параметры события изменения свойства объекта, содержащие имя свойства</param>
        </member>
        <member name="M:System.Processor.OnPropertyChanged(System.String)">
            <summary>Вызов события изменения свойства объекта с указанием имени свойства</summary>
            <param name="PropertyName">Имя изменившегося свойства</param>
        </member>
        <member name="E:System.Processor.EnableChanged">
            <summary>Событие изменения свойства активности процессора</summary>
        </member>
        <member name="M:System.Processor.OnEnableChanged(System.EventArgs)">
            <summary>Источник события изменения свойства активности процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.ProcessStarted">
            <summary>Событие запуска процессора</summary>
        </member>
        <member name="M:System.Processor.OnProcessStarted(System.EventArgs)">
            <summary>Источник события запуска процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.ProcessCompleted">
            <summary>Событие завершения работы процессора</summary>
        </member>
        <member name="M:System.Processor.OnProcessCompleted(System.EventArgs)">
            <summary>Источник события завершения работы процессора</summary><param name="e">Параметры события</param>
        </member>
        <member name="E:System.Processor.Error">
            <summary>Событие, возникающие при возникновении исключений в процессе работы процессора</summary>
        </member>
        <member name="M:System.Processor.OnError(System.ExceptionEventHandlerArgs{System.Exception})">
            <summary>Источник события возникновения исключительной ситуации в процессе работы процессора</summary>
            <param name="e">Аргумент события ошибки, содержащий объект исключения</param>
        </member>
        <member name="F:System.Processor._JoinThreadTimeout">
            <summary>
            Таймаут времени ожидания синхронизации потока обработки при его завершении, 
            после которого поток прерывается методом Abort()
            По умолчанию 100 мс.
            </summary>
        </member>
        <member name="F:System.Processor._Enabled">
            <summary>Флаг активности потока обработки. Пока значение флага "истина" - поток выполняется</summary>
        </member>
        <member name="F:System.Processor._StartStopSectionLocker">
            <summary>Объект синхронизации запуска/остановки процессора - только для чтения</summary>
        </member>
        <member name="F:System.Processor._MainWorkThread">
            <summary>Основной поток работы процессора</summary>
        </member>
        <member name="F:System.Processor._StartTime">
            <summary>Время запуска</summary>
        </member>
        <member name="F:System.Processor._StopTime">
            <summary>Время остановки</summary>
        </member>
        <member name="F:System.Processor._Monitor">
            <summary>Объект-наблюдатель за состоянием процессора</summary>
        </member>
        <member name="F:System.Processor._Priority">
            <summary>Базовый приоритет потока процессора</summary>
        </member>
        <member name="F:System.Processor._ActionTimeout">
            <summary>Таймаут выполнения между циклами процессора </summary>
        </member>
        <member name="F:System.Processor._SetTimeout">
            <summary>Метод установки времени таймаута для работающего потока процессора</summary>
        </member>
        <member name="F:System.Processor._IsSynchronous">
            <summary>Признак синхронной работы</summary>
        </member>
        <member name="F:System.Processor._ErrorIfAsync">
            <summary>Флаг, разрешающий вызов события ошибки в случае рассинхронизации потока</summary>
        </member>
        <member name="F:System.Processor._CyclesCount">
            <summary>Количество выполненных циклов обработки</summary>
        </member>
        <member name="F:System.Processor._NameForeNewMainThread">
            <summary>Имя для генерируемой потока выполнения процессора</summary>
        </member>
        <member name="F:System.Processor._GetLastDeltaTime">
            <summary>Метод извлечения времени выполнения одного цикла основного метода процессора</summary>
        </member>
        <member name="F:System.Processor._StartWaitHandle">
            <summary>Объект синхронизации потоков по запуску процессора</summary>
        </member>
        <member name="F:System.Processor._StopWaitHandle">
            <summary>Объект синхронизации потоков по остановке процессора</summary>
        </member>
        <member name="P:System.Processor.Priority">
            <summary>Приоритет выполнения метода наблюдения</summary>
        </member>
        <member name="P:System.Processor.Enable">
            <summary>Признак активности процессора</summary>
        </member>
        <member name="P:System.Processor.MainThread">
            <summary>Основной поток работы процессора</summary>
        </member>
        <member name="P:System.Processor.JoinThreadTimeout">
            <summary>Таймаут времени синхронизации основного потока процессора с потоком, завершившим его работу.</summary>
        </member>
        <member name="P:System.Processor.StartTime">
            <summary>Время запуска</summary>
        </member>
        <member name="P:System.Processor.StopTime">
            <summary>Время остановки</summary>
        </member>
        <member name="P:System.Processor.ElapsedTime">
            <summary>Время, прошедшее после запуска</summary>
        </member>
        <member name="P:System.Processor.Monitor">
            <summary>Объект-наблюдатель за состоянием процессора</summary>
        </member>
        <member name="P:System.Processor.ActionTimeout">
            <summary>Таймаут основной циклической операции в миллисекундах</summary>
        </member>
        <member name="P:System.Processor.IsSynchronous">
            <summary>Признак синхронной работы</summary>
        </member>
        <member name="P:System.Processor.ErrorIfAsync">
            <summary>Генерировать ошибку в случае рассинхронизации?</summary>
        </member>
        <member name="P:System.Processor.CyclesCount">
            <summary>Количество пройденных циклов</summary>
        </member>
        <member name="M:System.Processor.#ctor">
            <summary>Инициализация нового экземпляра <see cref="T:System.Processor"/></summary>
        </member>
        <member name="M:System.Processor.Restart">
            <summary>Перезапуск</summary>
        </member>
        <member name="M:System.Processor.Start">
            <summary>Запуск обработки</summary>
        </member>
        <member name="M:System.Processor.Stop">
            <summary>Остановка обработки</summary>
        </member>
        <member name="M:System.Processor.WaitToStart(System.Nullable{System.TimeSpan})">
            <summary>Блокировать поток до запуска процессора</summary>
        </member>
        <member name="M:System.Processor.WaitToStop(System.Nullable{System.TimeSpan})">
            <summary>Блокировать поток до остановки процессора</summary>
        </member>
        <member name="M:System.Processor.ThreadMethod">
            <summary>Основной метод процессора, выполняемый в отдельном потоке </summary>
        </member>
        <member name="M:System.Processor.MainAction">
            <summary>Основной метод действия процессора, вызываемое в цикле. Должно быть переопределено в классах-наследниках</summary>
        </member>
        <member name="M:System.Processor.InitializeAction">
            <summary>Инициализация процесса</summary>
        </member>
        <member name="M:System.Processor.Initializer">
            <summary>
            Метод инициализации. Вызывается после запуска обработки перед началом основного цикла.
            По умолчанию вызывает генерацию события запуска процессора
            </summary>
        </member>
        <member name="M:System.Processor.Finalizer">
            <summary>
            Метод, завершающий процесс обработки. Вызывается после выхода процессора из основного цикла.
            По умолчанию вызывает генерацию события завершения работы процессора
            </summary>
        </member>
        <member name="M:System.Processor.FinalizeAction">
            <summary>Завершающее действие процесса</summary>
        </member>
        <member name="M:System.Processor.Dispose">
            <inheritdoc />
        </member>
        <member name="M:System.Processor.Dispose(System.Boolean)">
            <summary>Освобождение ресурсов</summary>
            <param name="disposing">Признак того, что требуется выполнить освобождение управляемых ресурсов</param>
        </member>
        <member name="T:System.Reflection.Constructor`1">
            <summary>Управление конструктором класса</summary>
            <typeparam name="T">Тип объектов, порождаемых конструктором</typeparam>
        </member>
        <member name="F:System.Reflection.Constructor`1._Info">
            <summary>Информация о конструкторе</summary>
        </member>
        <member name="F:System.Reflection.Constructor`1._ObjectType">
            <summary>Тип объекта, конструктор которого требуется контролировать</summary>
        </member>
        <member name="F:System.Reflection.Constructor`1._Private">
            <summary>Искать приватный конструктор?</summary>
        </member>
        <member name="F:System.Reflection.Constructor`1._ArgumentTypes">
            <summary>Массив типов параметров конструктора</summary>
        </member>
        <member name="P:System.Reflection.Constructor`1.IsExist">
            <summary>Конструктор найден</summary>
        </member>
        <member name="P:System.Reflection.Constructor`1.ObjectType">
            <summary>Тип объекта, конструктор которого требуется контролировать</summary>
        </member>
        <member name="P:System.Reflection.Constructor`1.Private">
            <summary>Искать приватный конструктор?</summary>
        </member>
        <member name="P:System.Reflection.Constructor`1.ArgumentTypes">
            <summary>Массив типов параметров конструктора</summary>
        </member>
        <member name="M:System.Reflection.Constructor`1.#ctor(`0,System.Boolean,System.Type[])">
            <summary>Инициализация нового экземпляра <see cref="T:System.Reflection.Constructor`1"/></summary>
            <param name="o">Объект, Конструктор которого используется</param>
            <param name="Private">Искать приватный конструктор?</param>
            <param name="ArgumentTypes">Массив типов параметров конструктора</param>
        </member>
        <member name="M:System.Reflection.Constructor`1.#ctor(System.Type,System.Boolean,System.Type[])">
            <summary>Инициализация нового экземпляра <see cref="T:System.Reflection.Constructor`1"/></summary>
            <param name="type">Тип, из которого извлекается конструктор</param>
            <param name="Private">Искать приватный конструктор?</param>
            <param name="ArgumentTypes">Массив типов параметров конструктора</param>
        </member>
        <member name="M:System.Reflection.Constructor`1.Initialize(System.Type,System.Type[],System.Boolean)">
            <summary>Инициализация контроля конструктора</summary>
            <param name="Type">Тип из которого извлекается конструктор</param>
            <param name="Types">Массив типов аргументов конструктора</param>
            <param name="IsPrivate">Искать приватный конструктор?</param>
        </member>
        <member name="M:System.Reflection.Constructor`1.Create">
            <inheritdoc />
        </member>
        <member name="M:System.Reflection.Constructor`1.Create(System.Object[])">
            <inheritdoc />
        </member>
        <member name="T:System.Reflection.ConstructorExtensions">
            <summary>Класс методов-расширений для взаимодействия с конструкторами классов по средствам рефлексии</summary>
        </member>
        <member name="M:System.Reflection.ConstructorExtensions.GetObjectConstructor``1(``0,System.Boolean,System.Type[])">
            <summary>Получить конструктор для объекта</summary>
            <param name="o">Объект, конструктор класса которого требуется получить</param>
            <param name="Private">Искать приватный конструктор?</param>
            <param name="ArgumentTypes">Перечисление типов параметров искомого конструктора</param>
            <typeparam name="TObject">Тип объекта, для которого извлекается конструктор</typeparam>
            <returns>Объект, управляющий конструктором класса объекта</returns>
        </member>
        <member name="M:System.Reflection.ConstructorExtensions.GetTypeConstructor``1(System.Type,System.Boolean,System.Type[])">
            <summary>Получить конструктор для объекта</summary>
            <param name="type">Тип, из которого требуется извлечь конструктор</param>
            <param name="Private">Искать приватный конструктор?</param>
            <param name="ArgumentTypes">Перечисление типов параметров искомого конструктора</param>
            <typeparam name="TObject">Тип объекта, для которого извлекается конструктор</typeparam>
            <returns>Объект, управляющий конструктором класса объекта</returns>
        </member>
        <member name="T:System.Reflection.Event`2">
            <summary>Событие</summary>
            <typeparam name="TObject">Тип объекта-источника события</typeparam>
            <typeparam name="TEventArgs">Тип аргумента события</typeparam>
        </member>
        <member name="E:System.Reflection.Event`2.EventHandler">
            <summary>Событие</summary>
        </member>
        <member name="F:System.Reflection.Event`2._EventInfo">
            <summary>Описание события</summary>
        </member>
        <member name="F:System.Reflection.Event`2._Object">
            <summary>Объект-источник</summary>
        </member>
        <member name="M:System.Reflection.Event`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Событие</summary>
            <param name="o">Объект-источник события</param>
            <param name="Name">Название события</param>
            <param name="Private">Приватность описания события в классе объекта</param>
        </member>
        <member name="T:System.Reflection.Field`2">
            <summary>Объект управления полем</summary>
            <typeparam name="TObject">Тип объекта, в котором определено управляемое полек</typeparam>
            <typeparam name="TValue">Тип поля</typeparam>
        </member>
        <member name="F:System.Reflection.Field`2._FieldInfo">
            <summary>Информация о поле</summary>
        </member>
        <member name="F:System.Reflection.Field`2._Name">
            <summary>Имя поля</summary>
        </member>
        <member name="F:System.Reflection.Field`2._Object">
            <summary>Объект, в котором определено поле</summary>
        </member>
        <member name="F:System.Reflection.Field`2._Private">
            <summary>Поле является приватным?</summary>
        </member>
        <member name="P:System.Reflection.Field`2.IsExist">
            <summary>Поле найдено и может быть управляемо</summary>
        </member>
        <member name="P:System.Reflection.Field`2.Name">
            <summary>Имя поля</summary>
        </member>
        <member name="P:System.Reflection.Field`2.Object">
            <summary>Объект, в котором определено поле</summary>
        </member>
        <member name="P:System.Reflection.Field`2.Private">
            <summary>Поле является приватным?</summary>
        </member>
        <member name="P:System.Reflection.Field`2.Value">
            <summary>Значение поля</summary>
        </member>
        <member name="M:System.Reflection.Field`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Reflection.Field`2"/></summary>
            <param name="o">Объект, в котором определено поле</param>
            <param name="Name">Имя поля</param>
            <param name="Private">Поле является приватным?</param>
        </member>
        <member name="M:System.Reflection.Field`2.Initialize(`0,System.String,System.Boolean)">
            <summary> Инициализация состояния <see cref="T:System.Reflection.Field`2"/></summary>
            <param name="o">Объект, в котором определено поле</param>
            <param name="FieldName">Имя поля</param>
            <param name="IsPrivate">Поле является приватным?</param>
        </member>
        <member name="T:System.Reflection.FieldExtensions">
            <summary>Класс методов-расширений для полей класса</summary>
        </member>
        <member name="M:System.Reflection.FieldExtensions.GetField``2(``0,System.String,System.Boolean)">
            <summary>Получить объект контроля поля объекта</summary>
            <typeparam name="TObject">Тип объекта, поле которого требуется контролировать</typeparam>
            <typeparam name="TValue">Тип значения поля</typeparam>
            <param name="o">Объект, поле которого требуется контролировать</param>
            <param name="Name">Имя контролируемого поля</param>
            <param name="Private">Искать приватное поле?</param>
            <returns>Объект, осуществляющий контроль поля</returns>
        </member>
        <member name="T:System.Reflection.Method`2">
            <summary>Объект, осуществляющий контроль метода объекта <typeparamref name="TObject"/></summary>
            <typeparam name="TObject">Тип объекта, метод которого требуется контролировать</typeparam>
            <typeparam name="TResult">Тип значения метода</typeparam>
        </member>
        <member name="F:System.Reflection.Method`2._MethodInfo">
            <summary>Информация о контролируемом методе</summary>
        </member>
        <member name="F:System.Reflection.Method`2._Name">
            <summary>Имя метод</summary>
        </member>
        <member name="F:System.Reflection.Method`2._Object">
            <summary>Объект, метод которого контролируется</summary>
        </member>
        <member name="F:System.Reflection.Method`2._Private">
            <summary>Метод не является публичным?</summary>
        </member>
        <member name="F:System.Reflection.Method`2._Method">
            <summary>Функция, вычисляющая результат вызова метода</summary>
        </member>
        <member name="P:System.Reflection.Method`2.Name">
            <summary>Имя контролируемого метода</summary>
        </member>
        <member name="P:System.Reflection.Method`2.Object">
            <summary>Объект, метод которого контролируется</summary>
        </member>
        <member name="P:System.Reflection.Method`2.Private">
            <summary>Метод не является публичным?</summary>
        </member>
        <member name="M:System.Reflection.Method`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Инициализация нового экземпляра <see cref="T:System.Reflection.Method`2"/></summary>
            <param name="o">Объект, метод которого контролируется</param>
            <param name="Name">Имя контролируемого метода</param>
            <param name="Private">Метод не является публичным?</param>
        </member>
        <member name="M:System.Reflection.Method`2.Initialize(`0,System.String,System.Boolean)">
            <summary>Инициализация <see cref="T:System.Reflection.Method`2"/></summary>
            <param name="obj">Объект, метод которого контролируется</param>
            <param name="MethodName">Имя контролируемого метода</param>
            <param name="IsPrivate">Метод не является публичным?</param>
        </member>
        <member name="M:System.Reflection.Method`2.Invoke(System.Object[])">
            <summary>Вызвать метод</summary>
            <param name="Args">Набор параметров, передаваемый методу</param>
            <returns>Результат вызова метода</returns>
        </member>
        <member name="M:System.Reflection.Method`2.PrivateInvoke(System.Object[])">
            <summary>Внутренний метод, осуществляющий вызов метода</summary>
            <param name="Args">Параметры вызова метода</param>
            <returns>Результат вызова метода</returns>
        </member>
        <member name="T:System.Reflection.MethodExtensions">
            <summary>Класс методов-расширения для <see cref="T:System.Object"/>, осуществляющих доступ к методам</summary>
        </member>
        <member name="M:System.Reflection.MethodExtensions.GetMethod``2(``0,System.String,System.Boolean)">
            <summary>Получить объект контроля метода</summary>
            <param name="o">Объект, Метод которого требуется контролировать</param>
            <param name="Name">Имя метода, контроль над которым требуется получить</param>
            <param name="Private">Метод является непубличным?</param>
            <typeparam name="TObject">Тип объекта</typeparam>
            <typeparam name="TValue">Тип значения метода</typeparam>
            <returns>Объект контроля метода</returns>
        </member>
        <member name="T:System.Reflection.Property`2">
            <summary>"Свойство" позднего связывания</summary>
            <typeparam name="TObject">Тип объекта, для которого определяется свойство</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
        </member>
        <member name="E:System.Reflection.Property`2.ValueChanged">
            <summary>Событие возникает если свойство <see cref="P:System.Reflection.Property`2.Value"/> изменило своё значение</summary>
        </member>
        <member name="M:System.Reflection.Property`2.OnValueChanged(System.EventArgs)">
            <summary>Генерация события <see cref="E:System.Reflection.Property`2.ValueChanged"/></summary>
            <param name="E">Аргумент события</param>
        </member>
        <member name="F:System.Reflection.Property`2._PropertyInfo">
            <summary>Информация о свойстве</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Name">
            <summary>Имя свойства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Object">
            <summary>Объект, которому принадлежит свойство</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Private">
            <summary>Флаг приватности свойства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._SetMethod">
            <summary>Действие, осуществляющее установку значения свойства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._GetMethod">
            <summary>Функция, вычисляющая значение свойства</summary>
        </member>
        <member name="F:System.Reflection.Property`2._Descriptor">
            <summary>Описание свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.PropertyType">
            <summary>Тип значения свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Name">
            <summary>Имя свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Object">
            <summary>Объект, определяющий свойство</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Private">
            <summary>Признак - является ли свойство приватным</summary>
        </member>
        <member name="P:System.Reflection.Property`2.IsExist">
            <summary>Признак </summary>
        </member>
        <member name="P:System.Reflection.Property`2.Value">
            <summary>Значение свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.CanRead">
            <summary>Признак возможности читать значение</summary>
        </member>
        <member name="P:System.Reflection.Property`2.CanWrite">
            <summary>Признак возможности устанавливать значение</summary>
        </member>
        <member name="P:System.Reflection.Property`2.SupportsChangeEvents">
            <summary>Поддерживает генерацию событий изменения значения</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Attributes">
            <summary>Атрибуты свойства</summary>
        </member>
        <member name="P:System.Reflection.Property`2.Descriptor">
            <summary>Дескриптор свойства объекта</summary>
        </member>
        <member name="P:System.Reflection.Property`2.DisplayName">
            <summary>Значение <see cref="P:System.ComponentModel.DisplayNameAttribute.DisplayName"/></summary>
        </member>
        <member name="P:System.Reflection.Property`2.Description">
            <summary>Значение <see cref="P:System.ComponentModel.DescriptionAttribute.Description"/></summary>
        </member>
        <member name="M:System.Reflection.Property`2.#ctor(System.String,System.Boolean)">
            <summary>Новый объект "Свойство" для позднего связывания</summary>
            <param name="Name">Имя свойства</param>
            <param name="Private">Является ли свойство скрытым</param>
        </member>
        <member name="M:System.Reflection.Property`2.#ctor(`0,System.String,System.Boolean)">
            <summary>Новый объект "Свойство" для позднего связывания</summary>
            <param name="o">Объект, для которого определяется свойство</param>
            <param name="Name">Имя свойства</param>
            <param name="Private">Является ли свойство скрытым</param>
        </member>
        <member name="M:System.Reflection.Property`2.Initialize(`0,System.String,System.Boolean)">
            <summary>Инициализация данных о свойстве</summary>
            <param name="o">Объект, свойство которого требуется контролировать</param>
            <param name="PropertyName">Имя запрашиваемого свойства</param>
            <param name="IsPrivate">Искать непубличные свойства</param>
        </member>
        <member name="M:System.Reflection.Property`2.PropertyValueChanged(System.Object,System.EventArgs)">
            <summary>Обработчик события изменения значения свойства</summary>
            <param name="Sender">Источник события - объект, свойство которого контролируется</param>
            <param name="Args">Аргумент события</param>
        </member>
        <member name="M:System.Reflection.Property`2.SetValue(`1)">
            <summary>Метод, позволяющий установить значение свойства</summary>
            <param name="value">Устанавливаемое значение свойства</param>
        </member>
        <member name="M:System.Reflection.Property`2.GetValue">
            <summary>Метод, позволяющий получить значение свойства</summary>
            <returns>Значение свойства</returns>
        </member>
        <member name="M:System.Reflection.Property`2.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.Reflection.PropertyExtensions">
            <summary>Класс методов-расширений для <see cref="T:System.Object"/>, обеспечивающих взаимодействие с его свойствами</summary>
        </member>
        <member name="M:System.Reflection.PropertyExtensions.GetProperty``2(``0,System.String,System.Boolean)">
            <summary>Получить объект управления и доступа к информации указанного свойства</summary>
            <param name="o">Объект, свойство которого требуется контролировать</param>
            <param name="Name">Имя контролируемого свойства</param>
            <param name="Private">Осуществить доступ к непубличным свойствам</param>
            <typeparam name="TObject">Тип объекта, свойство которого запрашивается</typeparam>
            <typeparam name="TValue">Тип значения свойства</typeparam>
            <returns>Объект контроля свойства объекта</returns>
        </member>
        <member name="T:System.StreamingObjectReader`1">
            <summary>Класс поточного чтения объектов из потока данных</summary>
            <typeparam name="T">Тип читаемых объектов</typeparam>
        </member>
        <member name="E:System.StreamingObjectReader`1.Readed">
            <summary>Событие чтения нового объекта из потока данных</summary>
        </member>
        <member name="M:System.StreamingObjectReader`1.OnReaded(System.EventArgs{`0})">
            <summary>Источник события чтения объекта из потока данных</summary>
            <param name="e">Аргумент события, содержащий прочитанный объект</param>
        </member>
        <member name="M:System.StreamingObjectReader`1.OnReaded(`0)">
            <summary>Источник события чтения объекта из потока данных</summary>
            <param name="obj">Прочитанный объект</param>
        </member>
        <member name="F:System.StreamingObjectReader`1._DataStream">
            <summary>Потока данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.DataStream">
            <summary>Потока данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.Completed">
            <summary>Процент готовности</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.Speed">
            <summary>Скорость обработки данных</summary>
        </member>
        <member name="P:System.StreamingObjectReader`1.RemainingTime">
            <summary>Оставшееся время до окончания обработки</summary>
        </member>
        <member name="M:System.StreamingObjectReader`1.#ctor(System.IO.Stream)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamingObjectReader`1"/></summary>
            <param name="DataStream">Поток байт из которого требуется читать объекты</param>
        </member>
        <member name="M:System.StreamingObjectReader`1.Initializer">
            <inheritdoc />
        </member>
        <member name="M:System.StreamingObjectReader`1.MainAction">
            <inheritdoc />
        </member>
        <member name="M:System.StreamingObjectReader`1.Subscribe(System.IObserver{`0})">
            <inheritdoc />
        </member>
        <member name="M:System.StreamingObjectReader`1.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:System.StreamWrapper">
            <summary>Объект с интерфейсом потока байт данных, обеспечивающий слежение за процессами чтения/записи данных</summary>
        </member>
        <member name="T:System.StreamWrapper.SeekArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnSeek"/></summary>
        </member>
        <member name="P:System.StreamWrapper.SeekArgs.Offset">
            <summary>Величина заданного смещения в потоке</summary>
        </member>
        <member name="P:System.StreamWrapper.SeekArgs.Origin">
            <summary>Направление смещения в потоке</summary>
        </member>
        <member name="P:System.StreamWrapper.SeekArgs.Result">
            <summary>Результат выполнения смещения в потоке</summary>
        </member>
        <member name="M:System.StreamWrapper.SeekArgs.#ctor(System.Int64,System.IO.SeekOrigin,System.Int64)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.SeekArgs"/></summary>
            <param name="Offset">Величина заданного смещения в потоке</param>
            <param name="Origin">Направление смещения в потоке</param>
            <param name="Result">Результат выполнения смещения в потоке</param>
        </member>
        <member name="T:System.StreamWrapper.SetLengthArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnSetLength"/></summary>
        </member>
        <member name="P:System.StreamWrapper.SetLengthArgs.OldLength">
            <summary>Предыдущая длина потока</summary>
        </member>
        <member name="P:System.StreamWrapper.SetLengthArgs.Length">
            <summary>Установленная длина потока</summary>
        </member>
        <member name="M:System.StreamWrapper.SetLengthArgs.#ctor(System.Int64,System.Int64)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.SetLengthArgs"/></summary>
            <param name="OldLength">Предыдущая длина потока</param>
            <param name="Length">Установленная длина потока</param>
        </member>
        <member name="T:System.StreamWrapper.ReadArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnRead"/></summary>
        </member>
        <member name="P:System.StreamWrapper.ReadArgs.Buffer">
            <summary>Прочитанный массив байт</summary>
        </member>
        <member name="P:System.StreamWrapper.ReadArgs.Offset">
            <summary>Смещение в массиве</summary>
        </member>
        <member name="P:System.StreamWrapper.ReadArgs.Count">
            <summary>Число читаемых байт</summary>
        </member>
        <member name="P:System.StreamWrapper.ReadArgs.Result">
            <summary>Число прочитанных байт</summary>
        </member>
        <member name="M:System.StreamWrapper.ReadArgs.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.ReadArgs"/></summary>
            <param name="Buffer">Прочитанный массив байт</param>
            <param name="Offset">Смещение в массиве</param>
            <param name="Count">Число читаемых байт</param>
            <param name="Result">Число прочитанных байт</param>
        </member>
        <member name="T:System.StreamWrapper.WriteArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnWrite"/></summary>
        </member>
        <member name="P:System.StreamWrapper.WriteArgs.Buffer">
            <summary>Записываемый массив байт</summary>
        </member>
        <member name="P:System.StreamWrapper.WriteArgs.Offset">
            <summary>Смещение в массиве</summary>
        </member>
        <member name="P:System.StreamWrapper.WriteArgs.Count">
            <summary>Число записываемых байт</summary>
        </member>
        <member name="M:System.StreamWrapper.WriteArgs.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.WriteArgs"/></summary>
            <param name="Buffer">Записываемый массив байт</param>
            <param name="Offset">Смещение в массиве</param>
            <param name="Count">Число записываемых байт</param>
        </member>
        <member name="T:System.StreamWrapper.PositionChangedArgs">
            <summary>Аргумент события <see cref="E:System.StreamWrapper.OnPositionChanged"/></summary>
        </member>
        <member name="P:System.StreamWrapper.PositionChangedArgs.OldPosition">
            <summary>Предыдущее положение в потоке данных</summary>
        </member>
        <member name="P:System.StreamWrapper.PositionChangedArgs.NewPosition">
            <summary>Новое положение в потоке данных</summary>
        </member>
        <member name="M:System.StreamWrapper.PositionChangedArgs.#ctor(System.Int64,System.Int64)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper.PositionChangedArgs"/></summary>
            <param name="OldPosition">Предыдущее положение в потоке данных</param>
            <param name="NewPosition">Новое положение в потоке данных</param>
        </member>
        <member name="E:System.StreamWrapper.OnFlush">
            <summary>Событие возникает при вызове метода <see cref="M:System.StreamWrapper.Flush"/></summary>
        </member>
        <member name="E:System.StreamWrapper.OnSeek">
            <summary>Событие возникает при изменении положения считывания/записи</summary>
        </member>
        <member name="E:System.StreamWrapper.OnSetLength">
            <summary>Событие возникает при изменении длины потока</summary>
        </member>
        <member name="E:System.StreamWrapper.OnRead">
            <summary>Событие возникает при чтении данных из потока</summary>
        </member>
        <member name="E:System.StreamWrapper.OnWrite">
            <summary>Событие возникает при записи данных в поток</summary>
        </member>
        <member name="E:System.StreamWrapper.OnPositionChanged">
            <summary>Событие возникает в момент, когда положение чтение/записи в потоке смещается</summary>
        </member>
        <member name="E:System.StreamWrapper.OnEndOfStream">
            <summary>Событие, возникающее когда положение чтение/записи выходит на конец потока</summary>
        </member>
        <member name="F:System.StreamWrapper._DataStream">
            <summary>Внутренний поток</summary>
        </member>
        <member name="F:System.StreamWrapper._ExplicitLength">
            <summary>Ожидаемая длани потока в случае если поток не поддерживает поиск</summary>
        </member>
        <member name="F:System.StreamWrapper._Position">
            <summary>Положение в потоке (используется если поток не поддерживает поиск)</summary>
        </member>
        <member name="M:System.StreamWrapper.#ctor(System.IO.Stream,System.Int64)">
            <summary>Инициализация нового экземпляра <see cref="T:System.StreamWrapper"/></summary>
            <param name="Source">Поток, доступ к которому требуется контролировать</param>
            <param name="ExplicitLength">Если поток не поддерживает поиск, то тут указать его длину (если она определена)</param>
        </member>
        <member name="M:System.StreamWrapper.Flush">
            <inheritdoc />
        </member>
        <member name="M:System.StreamWrapper.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:System.StreamWrapper.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:System.StreamWrapper.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:System.StreamWrapper.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:System.StreamWrapper.CanRead">
            <summary>Можно ли осуществлять чтение данных из потока (определяется внутренним потоком)</summary>
        </member>
        <member name="P:System.StreamWrapper.CanSeek">
            <summary>Можно ли осуществлять перемещение позиции чтения/записи в потоке (определяется внутренним потоком)</summary>
        </member>
        <member name="P:System.StreamWrapper.CanWrite">
            <summary>Можно ли осуществлять запись данных в поток (определяется внутренним потоком)</summary>
        </member>
        <member name="P:System.StreamWrapper.Length">
            <summary>Длина потока</summary>
        </member>
        <member name="P:System.StreamWrapper.Position">
            <summary>Текущее положение в потоке (при установке значения осуществляется проверка на предмет конца потока)</summary>
        </member>
        <member name="P:System.StreamWrapper.EndOfStream">
            <summary>Признак конца потока</summary>
        </member>
        <member name="P:System.StreamWrapper.Progress">
            <summary>Прогресс</summary>
        </member>
        <member name="M:System.StreamWrapper.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
    </members>
</doc>
